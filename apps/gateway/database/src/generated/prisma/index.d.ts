
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model achievement
 * 
 */
export type achievement = $Result.DefaultSelection<Prisma.$achievementPayload>
/**
 * Model bank
 * 
 */
export type bank = $Result.DefaultSelection<Prisma.$bankPayload>
/**
 * Model chatmessage
 * 
 */
export type chatmessage = $Result.DefaultSelection<Prisma.$chatmessagePayload>
/**
 * Model chatroom
 * 
 */
export type chatroom = $Result.DefaultSelection<Prisma.$chatroomPayload>
/**
 * Model friendship
 * 
 */
export type friendship = $Result.DefaultSelection<Prisma.$friendshipPayload>
/**
 * Model gamesession
 * 
 */
export type gamesession = $Result.DefaultSelection<Prisma.$gamesessionPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model operator
 * 
 */
export type operator = $Result.DefaultSelection<Prisma.$operatorPayload>
/**
 * Model operatorgame
 * 
 */
export type operatorgame = $Result.DefaultSelection<Prisma.$operatorgamePayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model tournament
 * 
 */
export type tournament = $Result.DefaultSelection<Prisma.$tournamentPayload>
/**
 * Model tournamententry
 * 
 */
export type tournamententry = $Result.DefaultSelection<Prisma.$tournamententryPayload>
/**
 * Model tournamentgame
 * 
 */
export type tournamentgame = $Result.DefaultSelection<Prisma.$tournamentgamePayload>
/**
 * Model transaction
 * 
 */
export type transaction = $Result.DefaultSelection<Prisma.$transactionPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userachievement
 * 
 */
export type userachievement = $Result.DefaultSelection<Prisma.$userachievementPayload>
/**
 * Model RainBet
 * 
 */
export type RainBet = $Result.DefaultSelection<Prisma.$RainBetPayload>
/**
 * Model RainHistory
 * 
 */
export type RainHistory = $Result.DefaultSelection<Prisma.$RainHistoryPayload>
/**
 * Model RainTip
 * 
 */
export type RainTip = $Result.DefaultSelection<Prisma.$RainTipPayload>
/**
 * Model RainWinner
 * 
 */
export type RainWinner = $Result.DefaultSelection<Prisma.$RainWinnerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ChatChannel: {
  LOBBY: 'LOBBY',
  GAME: 'GAME',
  TOURNAMENT: 'TOURNAMENT',
  PRIVATE: 'PRIVATE'
};

export type ChatChannel = (typeof ChatChannel)[keyof typeof ChatChannel]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  BLOCKED: 'BLOCKED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


export const Gender: {
  BOY: 'BOY',
  GIRL: 'GIRL',
  ALIEN: 'ALIEN',
  UNSURE: 'UNSURE',
  ROBOT: 'ROBOT',
  COMPLICATED: 'COMPLICATED'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const NotificationType: {
  SYSTEM: 'SYSTEM',
  FRIEND_REQUEST: 'FRIEND_REQUEST',
  ACHIEVEMENT: 'ACHIEVEMENT',
  BALANCE_UPDATE: 'BALANCE_UPDATE',
  PROMOTIONAL: 'PROMOTIONAL',
  TOURNAMENT: 'TOURNAMENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const TransactionType: {
  DEPOSIT: 'DEPOSIT',
  WITHDRAWAL: 'WITHDRAWAL',
  BET: 'BET',
  WIN: 'WIN',
  BONUS: 'BONUS',
  DONATION: 'DONATION',
  ADJUSTMENT: 'ADJUSTMENT',
  TOURNAMENT_BUYIN: 'TOURNAMENT_BUYIN',
  TOURNAMENT_PRIZE: 'TOURNAMENT_PRIZE'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]

}

export type ChatChannel = $Enums.ChatChannel

export const ChatChannel: typeof $Enums.ChatChannel

export type FriendshipStatus = $Enums.FriendshipStatus

export const FriendshipStatus: typeof $Enums.FriendshipStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Achievements
 * const achievements = await prisma.achievement.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Achievements
   * const achievements = await prisma.achievement.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.achievement`: Exposes CRUD operations for the **achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.achievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.bankDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatmessage`: Exposes CRUD operations for the **chatmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatmessages
    * const chatmessages = await prisma.chatmessage.findMany()
    * ```
    */
  get chatmessage(): Prisma.chatmessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): Prisma.chatroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.friendshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gamesession`: Exposes CRUD operations for the **gamesession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamesessions
    * const gamesessions = await prisma.gamesession.findMany()
    * ```
    */
  get gamesession(): Prisma.gamesessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operator`: Exposes CRUD operations for the **operator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operators
    * const operators = await prisma.operator.findMany()
    * ```
    */
  get operator(): Prisma.operatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operatorgame`: Exposes CRUD operations for the **operatorgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Operatorgames
    * const operatorgames = await prisma.operatorgame.findMany()
    * ```
    */
  get operatorgame(): Prisma.operatorgameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.tournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamententry`: Exposes CRUD operations for the **tournamententry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamententries
    * const tournamententries = await prisma.tournamententry.findMany()
    * ```
    */
  get tournamententry(): Prisma.tournamententryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentgame`: Exposes CRUD operations for the **tournamentgame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournamentgames
    * const tournamentgames = await prisma.tournamentgame.findMany()
    * ```
    */
  get tournamentgame(): Prisma.tournamentgameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.transactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userachievement`: Exposes CRUD operations for the **userachievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userachievements
    * const userachievements = await prisma.userachievement.findMany()
    * ```
    */
  get userachievement(): Prisma.userachievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainBet`: Exposes CRUD operations for the **RainBet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainBets
    * const rainBets = await prisma.rainBet.findMany()
    * ```
    */
  get rainBet(): Prisma.RainBetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainHistory`: Exposes CRUD operations for the **RainHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainHistories
    * const rainHistories = await prisma.rainHistory.findMany()
    * ```
    */
  get rainHistory(): Prisma.RainHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainTip`: Exposes CRUD operations for the **RainTip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainTips
    * const rainTips = await prisma.rainTip.findMany()
    * ```
    */
  get rainTip(): Prisma.RainTipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rainWinner`: Exposes CRUD operations for the **RainWinner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RainWinners
    * const rainWinners = await prisma.rainWinner.findMany()
    * ```
    */
  get rainWinner(): Prisma.RainWinnerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    achievement: 'achievement',
    bank: 'bank',
    chatmessage: 'chatmessage',
    chatroom: 'chatroom',
    friendship: 'friendship',
    gamesession: 'gamesession',
    notification: 'notification',
    operator: 'operator',
    operatorgame: 'operatorgame',
    profile: 'profile',
    session: 'session',
    tournament: 'tournament',
    tournamententry: 'tournamententry',
    tournamentgame: 'tournamentgame',
    transaction: 'transaction',
    user: 'user',
    userachievement: 'userachievement',
    RainBet: 'RainBet',
    RainHistory: 'RainHistory',
    RainTip: 'RainTip',
    RainWinner: 'RainWinner'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "achievement" | "bank" | "chatmessage" | "chatroom" | "friendship" | "gamesession" | "notification" | "operator" | "operatorgame" | "profile" | "session" | "tournament" | "tournamententry" | "tournamentgame" | "transaction" | "user" | "userachievement" | "rainBet" | "rainHistory" | "rainTip" | "rainWinner"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      achievement: {
        payload: Prisma.$achievementPayload<ExtArgs>
        fields: Prisma.achievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.achievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.achievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          findFirst: {
            args: Prisma.achievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.achievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          findMany: {
            args: Prisma.achievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          create: {
            args: Prisma.achievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          createMany: {
            args: Prisma.achievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.achievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          delete: {
            args: Prisma.achievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          update: {
            args: Prisma.achievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          deleteMany: {
            args: Prisma.achievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.achievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.achievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>[]
          }
          upsert: {
            args: Prisma.achievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$achievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.achievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.achievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      bank: {
        payload: Prisma.$bankPayload<ExtArgs>
        fields: Prisma.bankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          findFirst: {
            args: Prisma.bankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          findMany: {
            args: Prisma.bankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>[]
          }
          create: {
            args: Prisma.bankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          createMany: {
            args: Prisma.bankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bankCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>[]
          }
          delete: {
            args: Prisma.bankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          update: {
            args: Prisma.bankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          deleteMany: {
            args: Prisma.bankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bankUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>[]
          }
          upsert: {
            args: Prisma.bankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bankPayload>
          }
          aggregate: {
            args: Prisma.BankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBank>
          }
          groupBy: {
            args: Prisma.bankGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankGroupByOutputType>[]
          }
          count: {
            args: Prisma.bankCountArgs<ExtArgs>
            result: $Utils.Optional<BankCountAggregateOutputType> | number
          }
        }
      }
      chatmessage: {
        payload: Prisma.$chatmessagePayload<ExtArgs>
        fields: Prisma.chatmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findFirst: {
            args: Prisma.chatmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findMany: {
            args: Prisma.chatmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          create: {
            args: Prisma.chatmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          createMany: {
            args: Prisma.chatmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatmessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          delete: {
            args: Prisma.chatmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          update: {
            args: Prisma.chatmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          deleteMany: {
            args: Prisma.chatmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatmessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          upsert: {
            args: Prisma.chatmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          aggregate: {
            args: Prisma.ChatmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatmessage>
          }
          groupBy: {
            args: Prisma.chatmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatmessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageCountAggregateOutputType> | number
          }
        }
      }
      chatroom: {
        payload: Prisma.$chatroomPayload<ExtArgs>
        fields: Prisma.chatroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findFirst: {
            args: Prisma.chatroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findMany: {
            args: Prisma.chatroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          create: {
            args: Prisma.chatroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          createMany: {
            args: Prisma.chatroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          delete: {
            args: Prisma.chatroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          update: {
            args: Prisma.chatroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          deleteMany: {
            args: Prisma.chatroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          upsert: {
            args: Prisma.chatroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          aggregate: {
            args: Prisma.ChatroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom>
          }
          groupBy: {
            args: Prisma.chatroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatroomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomCountAggregateOutputType> | number
          }
        }
      }
      friendship: {
        payload: Prisma.$friendshipPayload<ExtArgs>
        fields: Prisma.friendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.friendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.friendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findFirst: {
            args: Prisma.friendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.friendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          findMany: {
            args: Prisma.friendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          create: {
            args: Prisma.friendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          createMany: {
            args: Prisma.friendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.friendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          delete: {
            args: Prisma.friendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          update: {
            args: Prisma.friendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          deleteMany: {
            args: Prisma.friendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.friendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.friendshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>[]
          }
          upsert: {
            args: Prisma.friendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$friendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.friendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.friendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      gamesession: {
        payload: Prisma.$gamesessionPayload<ExtArgs>
        fields: Prisma.gamesessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamesessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamesessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          findFirst: {
            args: Prisma.gamesessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamesessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          findMany: {
            args: Prisma.gamesessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          create: {
            args: Prisma.gamesessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          createMany: {
            args: Prisma.gamesessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.gamesessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          delete: {
            args: Prisma.gamesessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          update: {
            args: Prisma.gamesessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          deleteMany: {
            args: Prisma.gamesessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamesessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.gamesessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>[]
          }
          upsert: {
            args: Prisma.gamesessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamesessionPayload>
          }
          aggregate: {
            args: Prisma.GamesessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamesession>
          }
          groupBy: {
            args: Prisma.gamesessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamesessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamesessionCountArgs<ExtArgs>
            result: $Utils.Optional<GamesessionCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      operator: {
        payload: Prisma.$operatorPayload<ExtArgs>
        fields: Prisma.operatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          findFirst: {
            args: Prisma.operatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          findMany: {
            args: Prisma.operatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>[]
          }
          create: {
            args: Prisma.operatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          createMany: {
            args: Prisma.operatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.operatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>[]
          }
          delete: {
            args: Prisma.operatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          update: {
            args: Prisma.operatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          deleteMany: {
            args: Prisma.operatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.operatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.operatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>[]
          }
          upsert: {
            args: Prisma.operatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorPayload>
          }
          aggregate: {
            args: Prisma.OperatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperator>
          }
          groupBy: {
            args: Prisma.operatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.operatorCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorCountAggregateOutputType> | number
          }
        }
      }
      operatorgame: {
        payload: Prisma.$operatorgamePayload<ExtArgs>
        fields: Prisma.operatorgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.operatorgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.operatorgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          findFirst: {
            args: Prisma.operatorgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.operatorgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          findMany: {
            args: Prisma.operatorgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          create: {
            args: Prisma.operatorgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          createMany: {
            args: Prisma.operatorgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.operatorgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          delete: {
            args: Prisma.operatorgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          update: {
            args: Prisma.operatorgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          deleteMany: {
            args: Prisma.operatorgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.operatorgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.operatorgameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>[]
          }
          upsert: {
            args: Prisma.operatorgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$operatorgamePayload>
          }
          aggregate: {
            args: Prisma.OperatorgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperatorgame>
          }
          groupBy: {
            args: Prisma.operatorgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.operatorgameCountArgs<ExtArgs>
            result: $Utils.Optional<OperatorgameCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.profileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      tournament: {
        payload: Prisma.$tournamentPayload<ExtArgs>
        fields: Prisma.tournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          findFirst: {
            args: Prisma.tournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          findMany: {
            args: Prisma.tournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          create: {
            args: Prisma.tournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          createMany: {
            args: Prisma.tournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          delete: {
            args: Prisma.tournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          update: {
            args: Prisma.tournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          deleteMany: {
            args: Prisma.tournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>[]
          }
          upsert: {
            args: Prisma.tournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.tournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      tournamententry: {
        payload: Prisma.$tournamententryPayload<ExtArgs>
        fields: Prisma.tournamententryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamententryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamententryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          findFirst: {
            args: Prisma.tournamententryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamententryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          findMany: {
            args: Prisma.tournamententryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          create: {
            args: Prisma.tournamententryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          createMany: {
            args: Prisma.tournamententryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamententryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          delete: {
            args: Prisma.tournamententryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          update: {
            args: Prisma.tournamententryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          deleteMany: {
            args: Prisma.tournamententryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamententryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamententryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>[]
          }
          upsert: {
            args: Prisma.tournamententryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamententryPayload>
          }
          aggregate: {
            args: Prisma.TournamententryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamententry>
          }
          groupBy: {
            args: Prisma.tournamententryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamententryGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamententryCountArgs<ExtArgs>
            result: $Utils.Optional<TournamententryCountAggregateOutputType> | number
          }
        }
      }
      tournamentgame: {
        payload: Prisma.$tournamentgamePayload<ExtArgs>
        fields: Prisma.tournamentgameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tournamentgameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tournamentgameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          findFirst: {
            args: Prisma.tournamentgameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tournamentgameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          findMany: {
            args: Prisma.tournamentgameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          create: {
            args: Prisma.tournamentgameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          createMany: {
            args: Prisma.tournamentgameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tournamentgameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          delete: {
            args: Prisma.tournamentgameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          update: {
            args: Prisma.tournamentgameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          deleteMany: {
            args: Prisma.tournamentgameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tournamentgameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tournamentgameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>[]
          }
          upsert: {
            args: Prisma.tournamentgameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tournamentgamePayload>
          }
          aggregate: {
            args: Prisma.TournamentgameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentgame>
          }
          groupBy: {
            args: Prisma.tournamentgameGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameGroupByOutputType>[]
          }
          count: {
            args: Prisma.tournamentgameCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentgameCountAggregateOutputType> | number
          }
        }
      }
      transaction: {
        payload: Prisma.$transactionPayload<ExtArgs>
        fields: Prisma.transactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findFirst: {
            args: Prisma.transactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          findMany: {
            args: Prisma.transactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          create: {
            args: Prisma.transactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          createMany: {
            args: Prisma.transactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          delete: {
            args: Prisma.transactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          update: {
            args: Prisma.transactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          deleteMany: {
            args: Prisma.transactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>[]
          }
          upsert: {
            args: Prisma.transactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.transactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userachievement: {
        payload: Prisma.$userachievementPayload<ExtArgs>
        fields: Prisma.userachievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userachievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userachievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          findFirst: {
            args: Prisma.userachievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userachievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          findMany: {
            args: Prisma.userachievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          create: {
            args: Prisma.userachievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          createMany: {
            args: Prisma.userachievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userachievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          delete: {
            args: Prisma.userachievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          update: {
            args: Prisma.userachievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          deleteMany: {
            args: Prisma.userachievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userachievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userachievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>[]
          }
          upsert: {
            args: Prisma.userachievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userachievementPayload>
          }
          aggregate: {
            args: Prisma.UserachievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserachievement>
          }
          groupBy: {
            args: Prisma.userachievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserachievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.userachievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserachievementCountAggregateOutputType> | number
          }
        }
      }
      RainBet: {
        payload: Prisma.$RainBetPayload<ExtArgs>
        fields: Prisma.RainBetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainBetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainBetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findFirst: {
            args: Prisma.RainBetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainBetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          findMany: {
            args: Prisma.RainBetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          create: {
            args: Prisma.RainBetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          createMany: {
            args: Prisma.RainBetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainBetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          delete: {
            args: Prisma.RainBetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          update: {
            args: Prisma.RainBetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          deleteMany: {
            args: Prisma.RainBetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainBetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainBetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>[]
          }
          upsert: {
            args: Prisma.RainBetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainBetPayload>
          }
          aggregate: {
            args: Prisma.RainBetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainBet>
          }
          groupBy: {
            args: Prisma.RainBetGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainBetGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainBetCountArgs<ExtArgs>
            result: $Utils.Optional<RainBetCountAggregateOutputType> | number
          }
        }
      }
      RainHistory: {
        payload: Prisma.$RainHistoryPayload<ExtArgs>
        fields: Prisma.RainHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findFirst: {
            args: Prisma.RainHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          findMany: {
            args: Prisma.RainHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          create: {
            args: Prisma.RainHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          createMany: {
            args: Prisma.RainHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          delete: {
            args: Prisma.RainHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          update: {
            args: Prisma.RainHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          deleteMany: {
            args: Prisma.RainHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>[]
          }
          upsert: {
            args: Prisma.RainHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainHistoryPayload>
          }
          aggregate: {
            args: Prisma.RainHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainHistory>
          }
          groupBy: {
            args: Prisma.RainHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<RainHistoryCountAggregateOutputType> | number
          }
        }
      }
      RainTip: {
        payload: Prisma.$RainTipPayload<ExtArgs>
        fields: Prisma.RainTipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainTipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainTipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findFirst: {
            args: Prisma.RainTipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainTipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          findMany: {
            args: Prisma.RainTipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          create: {
            args: Prisma.RainTipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          createMany: {
            args: Prisma.RainTipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainTipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          delete: {
            args: Prisma.RainTipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          update: {
            args: Prisma.RainTipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          deleteMany: {
            args: Prisma.RainTipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainTipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainTipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>[]
          }
          upsert: {
            args: Prisma.RainTipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainTipPayload>
          }
          aggregate: {
            args: Prisma.RainTipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainTip>
          }
          groupBy: {
            args: Prisma.RainTipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainTipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainTipCountArgs<ExtArgs>
            result: $Utils.Optional<RainTipCountAggregateOutputType> | number
          }
        }
      }
      RainWinner: {
        payload: Prisma.$RainWinnerPayload<ExtArgs>
        fields: Prisma.RainWinnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RainWinnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RainWinnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findFirst: {
            args: Prisma.RainWinnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RainWinnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          findMany: {
            args: Prisma.RainWinnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          create: {
            args: Prisma.RainWinnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          createMany: {
            args: Prisma.RainWinnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RainWinnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          delete: {
            args: Prisma.RainWinnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          update: {
            args: Prisma.RainWinnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          deleteMany: {
            args: Prisma.RainWinnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RainWinnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RainWinnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>[]
          }
          upsert: {
            args: Prisma.RainWinnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RainWinnerPayload>
          }
          aggregate: {
            args: Prisma.RainWinnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRainWinner>
          }
          groupBy: {
            args: Prisma.RainWinnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.RainWinnerCountArgs<ExtArgs>
            result: $Utils.Optional<RainWinnerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    achievement?: achievementOmit
    bank?: bankOmit
    chatmessage?: chatmessageOmit
    chatroom?: chatroomOmit
    friendship?: friendshipOmit
    gamesession?: gamesessionOmit
    notification?: notificationOmit
    operator?: operatorOmit
    operatorgame?: operatorgameOmit
    profile?: profileOmit
    session?: sessionOmit
    tournament?: tournamentOmit
    tournamententry?: tournamententryOmit
    tournamentgame?: tournamentgameOmit
    transaction?: transactionOmit
    user?: userOmit
    userachievement?: userachievementOmit
    rainBet?: RainBetOmit
    rainHistory?: RainHistoryOmit
    rainTip?: RainTipOmit
    rainWinner?: RainWinnerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userachievement: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | AchievementCountOutputTypeCountUserachievementArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
  }


  /**
   * Count Type BankCountOutputType
   */

  export type BankCountOutputType = {
    profile: number
  }

  export type BankCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | BankCountOutputTypeCountProfileArgs
  }

  // Custom InputTypes
  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankCountOutputType
     */
    select?: BankCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }


  /**
   * Count Type ChatroomCountOutputType
   */

  export type ChatroomCountOutputType = {
    chatmessage: number
  }

  export type ChatroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | ChatroomCountOutputTypeCountChatmessageArgs
  }

  // Custom InputTypes
  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomCountOutputType
     */
    select?: ChatroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }


  /**
   * Count Type GamesessionCountOutputType
   */

  export type GamesessionCountOutputType = {
    chatroom: number
    transaction: number
  }

  export type GamesessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | GamesessionCountOutputTypeCountChatroomArgs
    transaction?: boolean | GamesessionCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GamesessionCountOutputType
     */
    select?: GamesessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountChatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroomWhereInput
  }

  /**
   * GamesessionCountOutputType without action
   */
  export type GamesessionCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }


  /**
   * Count Type OperatorCountOutputType
   */

  export type OperatorCountOutputType = {
    bank: number
    operatorgame: number
    profile: number
    tournament: number
  }

  export type OperatorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank?: boolean | OperatorCountOutputTypeCountBankArgs
    operatorgame?: boolean | OperatorCountOutputTypeCountOperatorgameArgs
    profile?: boolean | OperatorCountOutputTypeCountProfileArgs
    tournament?: boolean | OperatorCountOutputTypeCountTournamentArgs
  }

  // Custom InputTypes
  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorCountOutputType
     */
    select?: OperatorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountBankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bankWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountOperatorgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorgameWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }

  /**
   * OperatorCountOutputType without action
   */
  export type OperatorCountOutputTypeCountTournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentWhereInput
  }


  /**
   * Count Type OperatorgameCountOutputType
   */

  export type OperatorgameCountOutputType = {
    gamesession: number
    tournamentgame: number
  }

  export type OperatorgameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | OperatorgameCountOutputTypeCountGamesessionArgs
    tournamentgame?: boolean | OperatorgameCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * OperatorgameCountOutputType without action
   */
  export type OperatorgameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperatorgameCountOutputType
     */
    select?: OperatorgameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OperatorgameCountOutputType without action
   */
  export type OperatorgameCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * OperatorgameCountOutputType without action
   */
  export type OperatorgameCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    gamesession: number
    tournamententry: number
    transaction: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | ProfileCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | ProfileCountOutputTypeCountTournamententryArgs
    transaction?: boolean | ProfileCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    gamesession: number
    tournamententry: number
    tournamentgame: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | TournamentCountOutputTypeCountGamesessionArgs
    tournamententry?: boolean | TournamentCountOutputTypeCountTournamententryArgs
    tournamentgame?: boolean | TournamentCountOutputTypeCountTournamentgameArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountGamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    RainBet: number
    RainHistory: number
    RainTip: number
    RainWinner: number
    chatmessage: number
    friendship_friendship_friendIdTouser: number
    friendship_friendship_userIdTouser: number
    notification: number
    operator: number
    profile_profile_userIdTouser: number
    session: number
    tournamententry: number
    userachievement: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | UserCountOutputTypeCountRainBetArgs
    RainHistory?: boolean | UserCountOutputTypeCountRainHistoryArgs
    RainTip?: boolean | UserCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | UserCountOutputTypeCountRainWinnerArgs
    chatmessage?: boolean | UserCountOutputTypeCountChatmessageArgs
    friendship_friendship_friendIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_friendIdTouserArgs
    friendship_friendship_userIdTouser?: boolean | UserCountOutputTypeCountFriendship_friendship_userIdTouserArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    operator?: boolean | UserCountOutputTypeCountOperatorArgs
    profile_profile_userIdTouser?: boolean | UserCountOutputTypeCountProfile_profile_userIdTouserArgs
    session?: boolean | UserCountOutputTypeCountSessionArgs
    tournamententry?: boolean | UserCountOutputTypeCountTournamententryArgs
    userachievement?: boolean | UserCountOutputTypeCountUserachievementArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_friendIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriendship_friendship_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOperatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfile_profile_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
  }


  /**
   * Count Type RainHistoryCountOutputType
   */

  export type RainHistoryCountOutputType = {
    RainBet: number
    RainTip: number
    RainWinner: number
  }

  export type RainHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistoryCountOutputTypeCountRainBetArgs
    RainTip?: boolean | RainHistoryCountOutputTypeCountRainTipArgs
    RainWinner?: boolean | RainHistoryCountOutputTypeCountRainWinnerArgs
  }

  // Custom InputTypes
  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistoryCountOutputType
     */
    select?: RainHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
  }

  /**
   * RainHistoryCountOutputType without action
   */
  export type RainHistoryCountOutputTypeCountRainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    targetXp: number | null
    reward: Decimal | null
  }

  export type AchievementSumAggregateOutputType = {
    targetXp: number | null
    reward: Decimal | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    targetXp: number | null
    reward: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    targetXp: number
    reward: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementSumAggregateInputType = {
    targetXp?: true
    reward?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    targetXp?: true
    reward?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievement to aggregate.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type achievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: achievementWhereInput
    orderBy?: achievementOrderByWithAggregationInput | achievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: achievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    targetXp: number
    reward: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends achievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type achievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userachievement?: boolean | achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type achievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    targetXp?: boolean
    reward?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type achievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "targetXp" | "reward" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type achievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userachievement?: boolean | achievement$userachievementArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type achievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type achievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $achievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "achievement"
    objects: {
      userachievement: Prisma.$userachievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      targetXp: number
      reward: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type achievementGetPayload<S extends boolean | null | undefined | achievementDefaultArgs> = $Result.GetResult<Prisma.$achievementPayload, S>

  type achievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<achievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface achievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['achievement'], meta: { name: 'achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {achievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends achievementFindUniqueArgs>(args: SelectSubset<T, achievementFindUniqueArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {achievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends achievementFindUniqueOrThrowArgs>(args: SelectSubset<T, achievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends achievementFindFirstArgs>(args?: SelectSubset<T, achievementFindFirstArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends achievementFindFirstOrThrowArgs>(args?: SelectSubset<T, achievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends achievementFindManyArgs>(args?: SelectSubset<T, achievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {achievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends achievementCreateArgs>(args: SelectSubset<T, achievementCreateArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {achievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends achievementCreateManyArgs>(args?: SelectSubset<T, achievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {achievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends achievementCreateManyAndReturnArgs>(args?: SelectSubset<T, achievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {achievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends achievementDeleteArgs>(args: SelectSubset<T, achievementDeleteArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {achievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends achievementUpdateArgs>(args: SelectSubset<T, achievementUpdateArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {achievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends achievementDeleteManyArgs>(args?: SelectSubset<T, achievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends achievementUpdateManyArgs>(args: SelectSubset<T, achievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {achievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends achievementUpdateManyAndReturnArgs>(args: SelectSubset<T, achievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {achievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends achievementUpsertArgs>(args: SelectSubset<T, achievementUpsertArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends achievementCountArgs>(
      args?: Subset<T, achievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {achievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends achievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: achievementGroupByArgs['orderBy'] }
        : { orderBy?: achievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, achievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the achievement model
   */
  readonly fields: achievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__achievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userachievement<T extends achievement$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, achievement$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the achievement model
   */
  interface achievementFieldRefs {
    readonly id: FieldRef<"achievement", 'String'>
    readonly name: FieldRef<"achievement", 'String'>
    readonly description: FieldRef<"achievement", 'String'>
    readonly targetXp: FieldRef<"achievement", 'Int'>
    readonly reward: FieldRef<"achievement", 'Decimal'>
    readonly isActive: FieldRef<"achievement", 'Boolean'>
    readonly createdAt: FieldRef<"achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * achievement findUnique
   */
  export type achievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement findUniqueOrThrow
   */
  export type achievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement findFirst
   */
  export type achievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement findFirstOrThrow
   */
  export type achievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievement to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement findMany
   */
  export type achievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter, which achievements to fetch.
     */
    where?: achievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of achievements to fetch.
     */
    orderBy?: achievementOrderByWithRelationInput | achievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing achievements.
     */
    cursor?: achievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * achievement create
   */
  export type achievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The data needed to create a achievement.
     */
    data: XOR<achievementCreateInput, achievementUncheckedCreateInput>
  }

  /**
   * achievement createMany
   */
  export type achievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many achievements.
     */
    data: achievementCreateManyInput | achievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * achievement createManyAndReturn
   */
  export type achievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * The data used to create many achievements.
     */
    data: achievementCreateManyInput | achievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * achievement update
   */
  export type achievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The data needed to update a achievement.
     */
    data: XOR<achievementUpdateInput, achievementUncheckedUpdateInput>
    /**
     * Choose, which achievement to update.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement updateMany
   */
  export type achievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update achievements.
     */
    data: XOR<achievementUpdateManyMutationInput, achievementUncheckedUpdateManyInput>
    /**
     * Filter which achievements to update
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to update.
     */
    limit?: number
  }

  /**
   * achievement updateManyAndReturn
   */
  export type achievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * The data used to update achievements.
     */
    data: XOR<achievementUpdateManyMutationInput, achievementUncheckedUpdateManyInput>
    /**
     * Filter which achievements to update
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to update.
     */
    limit?: number
  }

  /**
   * achievement upsert
   */
  export type achievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * The filter to search for the achievement to update in case it exists.
     */
    where: achievementWhereUniqueInput
    /**
     * In case the achievement found by the `where` argument doesn't exist, create a new achievement with this data.
     */
    create: XOR<achievementCreateInput, achievementUncheckedCreateInput>
    /**
     * In case the achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<achievementUpdateInput, achievementUncheckedUpdateInput>
  }

  /**
   * achievement delete
   */
  export type achievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
    /**
     * Filter which achievement to delete.
     */
    where: achievementWhereUniqueInput
  }

  /**
   * achievement deleteMany
   */
  export type achievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which achievements to delete
     */
    where?: achievementWhereInput
    /**
     * Limit how many achievements to delete.
     */
    limit?: number
  }

  /**
   * achievement.userachievement
   */
  export type achievement$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    cursor?: userachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * achievement without action
   */
  export type achievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the achievement
     */
    select?: achievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the achievement
     */
    omit?: achievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: achievementInclude<ExtArgs> | null
  }


  /**
   * Model bank
   */

  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankMinAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    operatorId: string | null
  }

  export type BankMaxAggregateOutputType = {
    id: string | null
    name: string | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    operatorId: string | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    name: number
    currency: number
    isActive: number
    createdAt: number
    operatorId: number
    _all: number
  }


  export type BankMinAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    isActive?: true
    createdAt?: true
    operatorId?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    isActive?: true
    createdAt?: true
    operatorId?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    name?: true
    currency?: true
    isActive?: true
    createdAt?: true
    operatorId?: true
    _all?: true
  }

  export type BankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bank to aggregate.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type bankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bankWhereInput
    orderBy?: bankOrderByWithAggregationInput | bankOrderByWithAggregationInput[]
    by: BankScalarFieldEnum[] | BankScalarFieldEnum
    having?: bankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }

  export type BankGroupByOutputType = {
    id: string
    name: string
    currency: string
    isActive: boolean
    createdAt: Date
    operatorId: string
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends bankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type bankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    operatorId?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    profile?: boolean | bank$profileArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank"]>

  export type bankSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    operatorId?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank"]>

  export type bankSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    operatorId?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bank"]>

  export type bankSelectScalar = {
    id?: boolean
    name?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    operatorId?: boolean
  }

  export type bankOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "currency" | "isActive" | "createdAt" | "operatorId", ExtArgs["result"]["bank"]>
  export type bankInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    profile?: boolean | bank$profileArgs<ExtArgs>
    _count?: boolean | BankCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bankIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }
  export type bankIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }

  export type $bankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bank"
    objects: {
      operator: Prisma.$operatorPayload<ExtArgs>
      profile: Prisma.$profilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      currency: string
      isActive: boolean
      createdAt: Date
      operatorId: string
    }, ExtArgs["result"]["bank"]>
    composites: {}
  }

  type bankGetPayload<S extends boolean | null | undefined | bankDefaultArgs> = $Result.GetResult<Prisma.$bankPayload, S>

  type bankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bankFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface bankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bank'], meta: { name: 'bank' } }
    /**
     * Find zero or one Bank that matches the filter.
     * @param {bankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bankFindUniqueArgs>(args: SelectSubset<T, bankFindUniqueArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bank that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bankFindUniqueOrThrowArgs>(args: SelectSubset<T, bankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bankFindFirstArgs>(args?: SelectSubset<T, bankFindFirstArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bankFindFirstOrThrowArgs>(args?: SelectSubset<T, bankFindFirstOrThrowArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bankFindManyArgs>(args?: SelectSubset<T, bankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bank.
     * @param {bankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
     */
    create<T extends bankCreateArgs>(args: SelectSubset<T, bankCreateArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Banks.
     * @param {bankCreateManyArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const bank = await prisma.bank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bankCreateManyArgs>(args?: SelectSubset<T, bankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Banks and returns the data saved in the database.
     * @param {bankCreateManyAndReturnArgs} args - Arguments to create many Banks.
     * @example
     * // Create many Banks
     * const bank = await prisma.bank.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Banks and only return the `id`
     * const bankWithIdOnly = await prisma.bank.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bankCreateManyAndReturnArgs>(args?: SelectSubset<T, bankCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bank.
     * @param {bankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
     */
    delete<T extends bankDeleteArgs>(args: SelectSubset<T, bankDeleteArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bank.
     * @param {bankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bankUpdateArgs>(args: SelectSubset<T, bankUpdateArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Banks.
     * @param {bankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bankDeleteManyArgs>(args?: SelectSubset<T, bankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bankUpdateManyArgs>(args: SelectSubset<T, bankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks and returns the data updated in the database.
     * @param {bankUpdateManyAndReturnArgs} args - Arguments to update many Banks.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Banks and only return the `id`
     * const bankWithIdOnly = await prisma.bank.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bankUpdateManyAndReturnArgs>(args: SelectSubset<T, bankUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bank.
     * @param {bankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
     */
    upsert<T extends bankUpsertArgs>(args: SelectSubset<T, bankUpsertArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends bankCountArgs>(
      args?: Subset<T, bankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bankGroupByArgs['orderBy'] }
        : { orderBy?: bankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bank model
   */
  readonly fields: bankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operator<T extends operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorDefaultArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends bank$profileArgs<ExtArgs> = {}>(args?: Subset<T, bank$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bank model
   */
  interface bankFieldRefs {
    readonly id: FieldRef<"bank", 'String'>
    readonly name: FieldRef<"bank", 'String'>
    readonly currency: FieldRef<"bank", 'String'>
    readonly isActive: FieldRef<"bank", 'Boolean'>
    readonly createdAt: FieldRef<"bank", 'DateTime'>
    readonly operatorId: FieldRef<"bank", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bank findUnique
   */
  export type bankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank findUniqueOrThrow
   */
  export type bankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank findFirst
   */
  export type bankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank findFirstOrThrow
   */
  export type bankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter, which bank to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banks.
     */
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank findMany
   */
  export type bankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter, which banks to fetch.
     */
    where?: bankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banks to fetch.
     */
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banks.
     */
    cursor?: bankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banks.
     */
    skip?: number
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * bank create
   */
  export type bankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * The data needed to create a bank.
     */
    data: XOR<bankCreateInput, bankUncheckedCreateInput>
  }

  /**
   * bank createMany
   */
  export type bankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banks.
     */
    data: bankCreateManyInput | bankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bank createManyAndReturn
   */
  export type bankCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * The data used to create many banks.
     */
    data: bankCreateManyInput | bankCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank update
   */
  export type bankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * The data needed to update a bank.
     */
    data: XOR<bankUpdateInput, bankUncheckedUpdateInput>
    /**
     * Choose, which bank to update.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank updateMany
   */
  export type bankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banks.
     */
    data: XOR<bankUpdateManyMutationInput, bankUncheckedUpdateManyInput>
    /**
     * Filter which banks to update
     */
    where?: bankWhereInput
    /**
     * Limit how many banks to update.
     */
    limit?: number
  }

  /**
   * bank updateManyAndReturn
   */
  export type bankUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * The data used to update banks.
     */
    data: XOR<bankUpdateManyMutationInput, bankUncheckedUpdateManyInput>
    /**
     * Filter which banks to update
     */
    where?: bankWhereInput
    /**
     * Limit how many banks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bank upsert
   */
  export type bankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * The filter to search for the bank to update in case it exists.
     */
    where: bankWhereUniqueInput
    /**
     * In case the bank found by the `where` argument doesn't exist, create a new bank with this data.
     */
    create: XOR<bankCreateInput, bankUncheckedCreateInput>
    /**
     * In case the bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bankUpdateInput, bankUncheckedUpdateInput>
  }

  /**
   * bank delete
   */
  export type bankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    /**
     * Filter which bank to delete.
     */
    where: bankWhereUniqueInput
  }

  /**
   * bank deleteMany
   */
  export type bankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which banks to delete
     */
    where?: bankWhereInput
    /**
     * Limit how many banks to delete.
     */
    limit?: number
  }

  /**
   * bank.profile
   */
  export type bank$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * bank without action
   */
  export type bankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
  }


  /**
   * Model chatmessage
   */

  export type AggregateChatmessage = {
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  export type ChatmessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    channel: $Enums.ChatChannel | null
    createdAt: Date | null
    userId: string | null
    roomId: string | null
  }

  export type ChatmessageCountAggregateOutputType = {
    id: number
    content: number
    channel: number
    metadata: number
    createdAt: number
    userId: number
    roomId: number
    _all: number
  }


  export type ChatmessageMinAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageMaxAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    createdAt?: true
    userId?: true
    roomId?: true
  }

  export type ChatmessageCountAggregateInputType = {
    id?: true
    content?: true
    channel?: true
    metadata?: true
    createdAt?: true
    userId?: true
    roomId?: true
    _all?: true
  }

  export type ChatmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessage to aggregate.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatmessages
    **/
    _count?: true | ChatmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatmessageMaxAggregateInputType
  }

  export type GetChatmessageAggregateType<T extends ChatmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatmessage[P]>
      : GetScalarType<T[P], AggregateChatmessage[P]>
  }




  export type chatmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithAggregationInput | chatmessageOrderByWithAggregationInput[]
    by: ChatmessageScalarFieldEnum[] | ChatmessageScalarFieldEnum
    having?: chatmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatmessageCountAggregateInputType | true
    _min?: ChatmessageMinAggregateInputType
    _max?: ChatmessageMaxAggregateInputType
  }

  export type ChatmessageGroupByOutputType = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    roomId: string | null
    _count: ChatmessageCountAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  type GetChatmessageGroupByPayload<T extends chatmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
        }
      >
    >


  export type chatmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>

  export type chatmessageSelectScalar = {
    id?: boolean
    content?: boolean
    channel?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    roomId?: boolean
  }

  export type chatmessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "channel" | "metadata" | "createdAt" | "userId" | "roomId", ExtArgs["result"]["chatmessage"]>
  export type chatmessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type chatmessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type chatmessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatmessage$chatroomArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $chatmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatmessage"
    objects: {
      chatroom: Prisma.$chatroomPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      channel: $Enums.ChatChannel
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
      roomId: string | null
    }, ExtArgs["result"]["chatmessage"]>
    composites: {}
  }

  type chatmessageGetPayload<S extends boolean | null | undefined | chatmessageDefaultArgs> = $Result.GetResult<Prisma.$chatmessagePayload, S>

  type chatmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatmessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatmessageCountAggregateInputType | true
    }

  export interface chatmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatmessage'], meta: { name: 'chatmessage' } }
    /**
     * Find zero or one Chatmessage that matches the filter.
     * @param {chatmessageFindUniqueArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatmessageFindUniqueArgs>(args: SelectSubset<T, chatmessageFindUniqueArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatmessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatmessageFindUniqueOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, chatmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatmessageFindFirstArgs>(args?: SelectSubset<T, chatmessageFindFirstArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, chatmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany()
     * 
     * // Get first 10 Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatmessageFindManyArgs>(args?: SelectSubset<T, chatmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatmessage.
     * @param {chatmessageCreateArgs} args - Arguments to create a Chatmessage.
     * @example
     * // Create one Chatmessage
     * const Chatmessage = await prisma.chatmessage.create({
     *   data: {
     *     // ... data to create a Chatmessage
     *   }
     * })
     * 
     */
    create<T extends chatmessageCreateArgs>(args: SelectSubset<T, chatmessageCreateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatmessages.
     * @param {chatmessageCreateManyArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatmessageCreateManyArgs>(args?: SelectSubset<T, chatmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatmessages and returns the data saved in the database.
     * @param {chatmessageCreateManyAndReturnArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatmessages and only return the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatmessageCreateManyAndReturnArgs>(args?: SelectSubset<T, chatmessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatmessage.
     * @param {chatmessageDeleteArgs} args - Arguments to delete one Chatmessage.
     * @example
     * // Delete one Chatmessage
     * const Chatmessage = await prisma.chatmessage.delete({
     *   where: {
     *     // ... filter to delete one Chatmessage
     *   }
     * })
     * 
     */
    delete<T extends chatmessageDeleteArgs>(args: SelectSubset<T, chatmessageDeleteArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatmessage.
     * @param {chatmessageUpdateArgs} args - Arguments to update one Chatmessage.
     * @example
     * // Update one Chatmessage
     * const chatmessage = await prisma.chatmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatmessageUpdateArgs>(args: SelectSubset<T, chatmessageUpdateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatmessages.
     * @param {chatmessageDeleteManyArgs} args - Arguments to filter Chatmessages to delete.
     * @example
     * // Delete a few Chatmessages
     * const { count } = await prisma.chatmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatmessageDeleteManyArgs>(args?: SelectSubset<T, chatmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatmessageUpdateManyArgs>(args: SelectSubset<T, chatmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages and returns the data updated in the database.
     * @param {chatmessageUpdateManyAndReturnArgs} args - Arguments to update many Chatmessages.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatmessages and only return the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatmessageUpdateManyAndReturnArgs>(args: SelectSubset<T, chatmessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatmessage.
     * @param {chatmessageUpsertArgs} args - Arguments to update or create a Chatmessage.
     * @example
     * // Update or create a Chatmessage
     * const chatmessage = await prisma.chatmessage.upsert({
     *   create: {
     *     // ... data to create a Chatmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatmessage we want to update
     *   }
     * })
     */
    upsert<T extends chatmessageUpsertArgs>(args: SelectSubset<T, chatmessageUpsertArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageCountArgs} args - Arguments to filter Chatmessages to count.
     * @example
     * // Count the number of Chatmessages
     * const count = await prisma.chatmessage.count({
     *   where: {
     *     // ... the filter for the Chatmessages we want to count
     *   }
     * })
    **/
    count<T extends chatmessageCountArgs>(
      args?: Subset<T, chatmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatmessageAggregateArgs>(args: Subset<T, ChatmessageAggregateArgs>): Prisma.PrismaPromise<GetChatmessageAggregateType<T>>

    /**
     * Group by Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatmessageGroupByArgs['orderBy'] }
        : { orderBy?: chatmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatmessage model
   */
  readonly fields: chatmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends chatmessage$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, chatmessage$chatroomArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatmessage model
   */
  interface chatmessageFieldRefs {
    readonly id: FieldRef<"chatmessage", 'String'>
    readonly content: FieldRef<"chatmessage", 'String'>
    readonly channel: FieldRef<"chatmessage", 'ChatChannel'>
    readonly metadata: FieldRef<"chatmessage", 'Json'>
    readonly createdAt: FieldRef<"chatmessage", 'DateTime'>
    readonly userId: FieldRef<"chatmessage", 'String'>
    readonly roomId: FieldRef<"chatmessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatmessage findUnique
   */
  export type chatmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findUniqueOrThrow
   */
  export type chatmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findFirst
   */
  export type chatmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findFirstOrThrow
   */
  export type chatmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findMany
   */
  export type chatmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessages to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage create
   */
  export type chatmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to create a chatmessage.
     */
    data: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
  }

  /**
   * chatmessage createMany
   */
  export type chatmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatmessages.
     */
    data: chatmessageCreateManyInput | chatmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatmessage createManyAndReturn
   */
  export type chatmessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * The data used to create many chatmessages.
     */
    data: chatmessageCreateManyInput | chatmessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatmessage update
   */
  export type chatmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to update a chatmessage.
     */
    data: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
    /**
     * Choose, which chatmessage to update.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage updateMany
   */
  export type chatmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatmessages.
     */
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyInput>
    /**
     * Filter which chatmessages to update
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to update.
     */
    limit?: number
  }

  /**
   * chatmessage updateManyAndReturn
   */
  export type chatmessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * The data used to update chatmessages.
     */
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyInput>
    /**
     * Filter which chatmessages to update
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatmessage upsert
   */
  export type chatmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The filter to search for the chatmessage to update in case it exists.
     */
    where: chatmessageWhereUniqueInput
    /**
     * In case the chatmessage found by the `where` argument doesn't exist, create a new chatmessage with this data.
     */
    create: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
    /**
     * In case the chatmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
  }

  /**
   * chatmessage delete
   */
  export type chatmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter which chatmessage to delete.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage deleteMany
   */
  export type chatmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessages to delete
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to delete.
     */
    limit?: number
  }

  /**
   * chatmessage.chatroom
   */
  export type chatmessage$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    where?: chatroomWhereInput
  }

  /**
   * chatmessage without action
   */
  export type chatmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
  }


  /**
   * Model chatroom
   */

  export type AggregateChatroom = {
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  export type ChatroomMinAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isGameRoom: boolean | null
    createdAt: Date | null
    gameSessionId: string | null
  }

  export type ChatroomCountAggregateOutputType = {
    id: number
    name: number
    isGameRoom: number
    createdAt: number
    gameSessionId: number
    _all: number
  }


  export type ChatroomMinAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomMaxAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
  }

  export type ChatroomCountAggregateInputType = {
    id?: true
    name?: true
    isGameRoom?: true
    createdAt?: true
    gameSessionId?: true
    _all?: true
  }

  export type ChatroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatroom to aggregate.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatrooms
    **/
    _count?: true | ChatroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMaxAggregateInputType
  }

  export type GetChatroomAggregateType<T extends ChatroomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom[P]>
      : GetScalarType<T[P], AggregateChatroom[P]>
  }




  export type chatroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroomWhereInput
    orderBy?: chatroomOrderByWithAggregationInput | chatroomOrderByWithAggregationInput[]
    by: ChatroomScalarFieldEnum[] | ChatroomScalarFieldEnum
    having?: chatroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomCountAggregateInputType | true
    _min?: ChatroomMinAggregateInputType
    _max?: ChatroomMaxAggregateInputType
  }

  export type ChatroomGroupByOutputType = {
    id: string
    name: string
    isGameRoom: boolean
    createdAt: Date
    gameSessionId: string | null
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  type GetChatroomGroupByPayload<T extends chatroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
        }
      >
    >


  export type chatroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    chatmessage?: boolean | chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectScalar = {
    id?: boolean
    name?: boolean
    isGameRoom?: boolean
    createdAt?: boolean
    gameSessionId?: boolean
  }

  export type chatroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isGameRoom" | "createdAt" | "gameSessionId", ExtArgs["result"]["chatroom"]>
  export type chatroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | chatroom$chatmessageArgs<ExtArgs>
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }
  export type chatroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | chatroom$gamesessionArgs<ExtArgs>
  }

  export type $chatroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatroom"
    objects: {
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      gamesession: Prisma.$gamesessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isGameRoom: boolean
      createdAt: Date
      gameSessionId: string | null
    }, ExtArgs["result"]["chatroom"]>
    composites: {}
  }

  type chatroomGetPayload<S extends boolean | null | undefined | chatroomDefaultArgs> = $Result.GetResult<Prisma.$chatroomPayload, S>

  type chatroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatroomCountAggregateInputType | true
    }

  export interface chatroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatroom'], meta: { name: 'chatroom' } }
    /**
     * Find zero or one Chatroom that matches the filter.
     * @param {chatroomFindUniqueArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatroomFindUniqueArgs>(args: SelectSubset<T, chatroomFindUniqueArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatroomFindUniqueOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatroomFindUniqueOrThrowArgs>(args: SelectSubset<T, chatroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatroomFindFirstArgs>(args?: SelectSubset<T, chatroomFindFirstArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatroomFindFirstOrThrowArgs>(args?: SelectSubset<T, chatroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatrooms
     * const chatrooms = await prisma.chatroom.findMany()
     * 
     * // Get first 10 Chatrooms
     * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatroomFindManyArgs>(args?: SelectSubset<T, chatroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatroom.
     * @param {chatroomCreateArgs} args - Arguments to create a Chatroom.
     * @example
     * // Create one Chatroom
     * const Chatroom = await prisma.chatroom.create({
     *   data: {
     *     // ... data to create a Chatroom
     *   }
     * })
     * 
     */
    create<T extends chatroomCreateArgs>(args: SelectSubset<T, chatroomCreateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatrooms.
     * @param {chatroomCreateManyArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatroomCreateManyArgs>(args?: SelectSubset<T, chatroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatrooms and returns the data saved in the database.
     * @param {chatroomCreateManyAndReturnArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatroomCreateManyAndReturnArgs>(args?: SelectSubset<T, chatroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatroom.
     * @param {chatroomDeleteArgs} args - Arguments to delete one Chatroom.
     * @example
     * // Delete one Chatroom
     * const Chatroom = await prisma.chatroom.delete({
     *   where: {
     *     // ... filter to delete one Chatroom
     *   }
     * })
     * 
     */
    delete<T extends chatroomDeleteArgs>(args: SelectSubset<T, chatroomDeleteArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatroom.
     * @param {chatroomUpdateArgs} args - Arguments to update one Chatroom.
     * @example
     * // Update one Chatroom
     * const chatroom = await prisma.chatroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatroomUpdateArgs>(args: SelectSubset<T, chatroomUpdateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatrooms.
     * @param {chatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
     * @example
     * // Delete a few Chatrooms
     * const { count } = await prisma.chatroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatroomDeleteManyArgs>(args?: SelectSubset<T, chatroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatroomUpdateManyArgs>(args: SelectSubset<T, chatroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms and returns the data updated in the database.
     * @param {chatroomUpdateManyAndReturnArgs} args - Arguments to update many Chatrooms.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatroomUpdateManyAndReturnArgs>(args: SelectSubset<T, chatroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatroom.
     * @param {chatroomUpsertArgs} args - Arguments to update or create a Chatroom.
     * @example
     * // Update or create a Chatroom
     * const chatroom = await prisma.chatroom.upsert({
     *   create: {
     *     // ... data to create a Chatroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom we want to update
     *   }
     * })
     */
    upsert<T extends chatroomUpsertArgs>(args: SelectSubset<T, chatroomUpsertArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomCountArgs} args - Arguments to filter Chatrooms to count.
     * @example
     * // Count the number of Chatrooms
     * const count = await prisma.chatroom.count({
     *   where: {
     *     // ... the filter for the Chatrooms we want to count
     *   }
     * })
    **/
    count<T extends chatroomCountArgs>(
      args?: Subset<T, chatroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomAggregateArgs>(args: Subset<T, ChatroomAggregateArgs>): Prisma.PrismaPromise<GetChatroomAggregateType<T>>

    /**
     * Group by Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatroomGroupByArgs['orderBy'] }
        : { orderBy?: chatroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatroom model
   */
  readonly fields: chatroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatmessage<T extends chatroom$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    gamesession<T extends chatroom$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$gamesessionArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatroom model
   */
  interface chatroomFieldRefs {
    readonly id: FieldRef<"chatroom", 'String'>
    readonly name: FieldRef<"chatroom", 'String'>
    readonly isGameRoom: FieldRef<"chatroom", 'Boolean'>
    readonly createdAt: FieldRef<"chatroom", 'DateTime'>
    readonly gameSessionId: FieldRef<"chatroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatroom findUnique
   */
  export type chatroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findUniqueOrThrow
   */
  export type chatroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findFirst
   */
  export type chatroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findFirstOrThrow
   */
  export type chatroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findMany
   */
  export type chatroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatrooms to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom create
   */
  export type chatroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to create a chatroom.
     */
    data: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
  }

  /**
   * chatroom createMany
   */
  export type chatroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatroom createManyAndReturn
   */
  export type chatroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom update
   */
  export type chatroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to update a chatroom.
     */
    data: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
    /**
     * Choose, which chatroom to update.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom updateMany
   */
  export type chatroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
  }

  /**
   * chatroom updateManyAndReturn
   */
  export type chatroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom upsert
   */
  export type chatroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The filter to search for the chatroom to update in case it exists.
     */
    where: chatroomWhereUniqueInput
    /**
     * In case the chatroom found by the `where` argument doesn't exist, create a new chatroom with this data.
     */
    create: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
    /**
     * In case the chatroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
  }

  /**
   * chatroom delete
   */
  export type chatroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter which chatroom to delete.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom deleteMany
   */
  export type chatroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatrooms to delete
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to delete.
     */
    limit?: number
  }

  /**
   * chatroom.chatmessage
   */
  export type chatroom$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatroom.gamesession
   */
  export type chatroom$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
  }

  /**
   * chatroom without action
   */
  export type chatroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
  }


  /**
   * Model friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    status: $Enums.FriendshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    friendId: string | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    userId: number
    friendId: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    friendId?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendship to aggregate.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type friendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithAggregationInput | friendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: friendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    status: $Enums.FriendshipStatus
    createdAt: Date
    updatedAt: Date
    userId: string
    friendId: string
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends friendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type friendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type friendshipSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    friendId?: boolean
  }

  export type friendshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "userId" | "friendId", ExtArgs["result"]["friendship"]>
  export type friendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }
  export type friendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }
  export type friendshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_friendship_friendIdTouser?: boolean | userDefaultArgs<ExtArgs>
    user_friendship_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $friendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "friendship"
    objects: {
      user_friendship_friendIdTouser: Prisma.$userPayload<ExtArgs>
      user_friendship_userIdTouser: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.FriendshipStatus
      createdAt: Date
      updatedAt: Date
      userId: string
      friendId: string
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type friendshipGetPayload<S extends boolean | null | undefined | friendshipDefaultArgs> = $Result.GetResult<Prisma.$friendshipPayload, S>

  type friendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<friendshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface friendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['friendship'], meta: { name: 'friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {friendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends friendshipFindUniqueArgs>(args: SelectSubset<T, friendshipFindUniqueArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {friendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends friendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, friendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends friendshipFindFirstArgs>(args?: SelectSubset<T, friendshipFindFirstArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends friendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, friendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends friendshipFindManyArgs>(args?: SelectSubset<T, friendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friendship.
     * @param {friendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends friendshipCreateArgs>(args: SelectSubset<T, friendshipCreateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friendships.
     * @param {friendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends friendshipCreateManyArgs>(args?: SelectSubset<T, friendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {friendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends friendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, friendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friendship.
     * @param {friendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends friendshipDeleteArgs>(args: SelectSubset<T, friendshipDeleteArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friendship.
     * @param {friendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends friendshipUpdateArgs>(args: SelectSubset<T, friendshipUpdateArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friendships.
     * @param {friendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends friendshipDeleteManyArgs>(args?: SelectSubset<T, friendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends friendshipUpdateManyArgs>(args: SelectSubset<T, friendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships and returns the data updated in the database.
     * @param {friendshipUpdateManyAndReturnArgs} args - Arguments to update many Friendships.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends friendshipUpdateManyAndReturnArgs>(args: SelectSubset<T, friendshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friendship.
     * @param {friendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends friendshipUpsertArgs>(args: SelectSubset<T, friendshipUpsertArgs<ExtArgs>>): Prisma__friendshipClient<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends friendshipCountArgs>(
      args?: Subset<T, friendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {friendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends friendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: friendshipGroupByArgs['orderBy'] }
        : { orderBy?: friendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, friendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the friendship model
   */
  readonly fields: friendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__friendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_friendship_friendIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_friendship_userIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the friendship model
   */
  interface friendshipFieldRefs {
    readonly id: FieldRef<"friendship", 'String'>
    readonly status: FieldRef<"friendship", 'FriendshipStatus'>
    readonly createdAt: FieldRef<"friendship", 'DateTime'>
    readonly updatedAt: FieldRef<"friendship", 'DateTime'>
    readonly userId: FieldRef<"friendship", 'String'>
    readonly friendId: FieldRef<"friendship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * friendship findUnique
   */
  export type friendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findUniqueOrThrow
   */
  export type friendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship findFirst
   */
  export type friendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findFirstOrThrow
   */
  export type friendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendship to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship findMany
   */
  export type friendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter, which friendships to fetch.
     */
    where?: friendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of friendships to fetch.
     */
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing friendships.
     */
    cursor?: friendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * friendship create
   */
  export type friendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a friendship.
     */
    data: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
  }

  /**
   * friendship createMany
   */
  export type friendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many friendships.
     */
    data: friendshipCreateManyInput | friendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * friendship createManyAndReturn
   */
  export type friendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * The data used to create many friendships.
     */
    data: friendshipCreateManyInput | friendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * friendship update
   */
  export type friendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a friendship.
     */
    data: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
    /**
     * Choose, which friendship to update.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship updateMany
   */
  export type friendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update friendships.
     */
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyInput>
    /**
     * Filter which friendships to update
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to update.
     */
    limit?: number
  }

  /**
   * friendship updateManyAndReturn
   */
  export type friendshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * The data used to update friendships.
     */
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyInput>
    /**
     * Filter which friendships to update
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * friendship upsert
   */
  export type friendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the friendship to update in case it exists.
     */
    where: friendshipWhereUniqueInput
    /**
     * In case the friendship found by the `where` argument doesn't exist, create a new friendship with this data.
     */
    create: XOR<friendshipCreateInput, friendshipUncheckedCreateInput>
    /**
     * In case the friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<friendshipUpdateInput, friendshipUncheckedUpdateInput>
  }

  /**
   * friendship delete
   */
  export type friendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    /**
     * Filter which friendship to delete.
     */
    where: friendshipWhereUniqueInput
  }

  /**
   * friendship deleteMany
   */
  export type friendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which friendships to delete
     */
    where?: friendshipWhereInput
    /**
     * Limit how many friendships to delete.
     */
    limit?: number
  }

  /**
   * friendship without action
   */
  export type friendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
  }


  /**
   * Model gamesession
   */

  export type AggregateGamesession = {
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  export type GamesessionAvgAggregateOutputType = {
    betAmount: Decimal | null
    winAmount: Decimal | null
    xpEarned: number | null
  }

  export type GamesessionSumAggregateOutputType = {
    betAmount: Decimal | null
    winAmount: Decimal | null
    xpEarned: number | null
  }

  export type GamesessionMinAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
  }

  export type GamesessionMaxAggregateOutputType = {
    id: string | null
    startTime: Date | null
    endTime: Date | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    xpEarned: number | null
    gameId: string | null
    tournamentId: string | null
    active: boolean | null
    profileId: string | null
  }

  export type GamesessionCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    betAmount: number
    winAmount: number
    xpEarned: number
    metadata: number
    gameId: number
    tournamentId: number
    active: number
    profileId: number
    _all: number
  }


  export type GamesessionAvgAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionSumAggregateInputType = {
    betAmount?: true
    winAmount?: true
    xpEarned?: true
  }

  export type GamesessionMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
  }

  export type GamesessionMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
  }

  export type GamesessionCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    betAmount?: true
    winAmount?: true
    xpEarned?: true
    metadata?: true
    gameId?: true
    tournamentId?: true
    active?: true
    profileId?: true
    _all?: true
  }

  export type GamesessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamesession to aggregate.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gamesessions
    **/
    _count?: true | GamesessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamesessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamesessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamesessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamesessionMaxAggregateInputType
  }

  export type GetGamesessionAggregateType<T extends GamesessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGamesession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamesession[P]>
      : GetScalarType<T[P], AggregateGamesession[P]>
  }




  export type gamesessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithAggregationInput | gamesessionOrderByWithAggregationInput[]
    by: GamesessionScalarFieldEnum[] | GamesessionScalarFieldEnum
    having?: gamesessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamesessionCountAggregateInputType | true
    _avg?: GamesessionAvgAggregateInputType
    _sum?: GamesessionSumAggregateInputType
    _min?: GamesessionMinAggregateInputType
    _max?: GamesessionMaxAggregateInputType
  }

  export type GamesessionGroupByOutputType = {
    id: string
    startTime: Date
    endTime: Date | null
    betAmount: Decimal | null
    winAmount: Decimal | null
    xpEarned: number
    metadata: JsonValue | null
    gameId: string
    tournamentId: string | null
    active: boolean
    profileId: string
    _count: GamesessionCountAggregateOutputType | null
    _avg: GamesessionAvgAggregateOutputType | null
    _sum: GamesessionSumAggregateOutputType | null
    _min: GamesessionMinAggregateOutputType | null
    _max: GamesessionMaxAggregateOutputType | null
  }

  type GetGamesessionGroupByPayload<T extends gamesessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamesessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamesessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
            : GetScalarType<T[P], GamesessionGroupByOutputType[P]>
        }
      >
    >


  export type gamesessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    chatroom?: boolean | gamesession$chatroomArgs<ExtArgs>
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
    transaction?: boolean | gamesession$transactionArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }, ExtArgs["result"]["gamesession"]>

  export type gamesessionSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    betAmount?: boolean
    winAmount?: boolean
    xpEarned?: boolean
    metadata?: boolean
    gameId?: boolean
    tournamentId?: boolean
    active?: boolean
    profileId?: boolean
  }

  export type gamesessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "betAmount" | "winAmount" | "xpEarned" | "metadata" | "gameId" | "tournamentId" | "active" | "profileId", ExtArgs["result"]["gamesession"]>
  export type gamesessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | gamesession$chatroomArgs<ExtArgs>
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
    transaction?: boolean | gamesession$transactionArgs<ExtArgs>
    _count?: boolean | GamesessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type gamesessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }
  export type gamesessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | gamesession$tournamentArgs<ExtArgs>
  }

  export type $gamesessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gamesession"
    objects: {
      chatroom: Prisma.$chatroomPayload<ExtArgs>[]
      operatorgame: Prisma.$operatorgamePayload<ExtArgs>
      profile: Prisma.$profilePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs> | null
      transaction: Prisma.$transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startTime: Date
      endTime: Date | null
      betAmount: Prisma.Decimal | null
      winAmount: Prisma.Decimal | null
      xpEarned: number
      metadata: Prisma.JsonValue | null
      gameId: string
      tournamentId: string | null
      active: boolean
      profileId: string
    }, ExtArgs["result"]["gamesession"]>
    composites: {}
  }

  type gamesessionGetPayload<S extends boolean | null | undefined | gamesessionDefaultArgs> = $Result.GetResult<Prisma.$gamesessionPayload, S>

  type gamesessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<gamesessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GamesessionCountAggregateInputType | true
    }

  export interface gamesessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gamesession'], meta: { name: 'gamesession' } }
    /**
     * Find zero or one Gamesession that matches the filter.
     * @param {gamesessionFindUniqueArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamesessionFindUniqueArgs>(args: SelectSubset<T, gamesessionFindUniqueArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Gamesession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {gamesessionFindUniqueOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamesessionFindUniqueOrThrowArgs>(args: SelectSubset<T, gamesessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gamesession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindFirstArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamesessionFindFirstArgs>(args?: SelectSubset<T, gamesessionFindFirstArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Gamesession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindFirstOrThrowArgs} args - Arguments to find a Gamesession
     * @example
     * // Get one Gamesession
     * const gamesession = await prisma.gamesession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamesessionFindFirstOrThrowArgs>(args?: SelectSubset<T, gamesessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Gamesessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamesessions
     * const gamesessions = await prisma.gamesession.findMany()
     * 
     * // Get first 10 Gamesessions
     * const gamesessions = await prisma.gamesession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends gamesessionFindManyArgs>(args?: SelectSubset<T, gamesessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Gamesession.
     * @param {gamesessionCreateArgs} args - Arguments to create a Gamesession.
     * @example
     * // Create one Gamesession
     * const Gamesession = await prisma.gamesession.create({
     *   data: {
     *     // ... data to create a Gamesession
     *   }
     * })
     * 
     */
    create<T extends gamesessionCreateArgs>(args: SelectSubset<T, gamesessionCreateArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Gamesessions.
     * @param {gamesessionCreateManyArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamesessionCreateManyArgs>(args?: SelectSubset<T, gamesessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gamesessions and returns the data saved in the database.
     * @param {gamesessionCreateManyAndReturnArgs} args - Arguments to create many Gamesessions.
     * @example
     * // Create many Gamesessions
     * const gamesession = await prisma.gamesession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gamesessions and only return the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends gamesessionCreateManyAndReturnArgs>(args?: SelectSubset<T, gamesessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Gamesession.
     * @param {gamesessionDeleteArgs} args - Arguments to delete one Gamesession.
     * @example
     * // Delete one Gamesession
     * const Gamesession = await prisma.gamesession.delete({
     *   where: {
     *     // ... filter to delete one Gamesession
     *   }
     * })
     * 
     */
    delete<T extends gamesessionDeleteArgs>(args: SelectSubset<T, gamesessionDeleteArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Gamesession.
     * @param {gamesessionUpdateArgs} args - Arguments to update one Gamesession.
     * @example
     * // Update one Gamesession
     * const gamesession = await prisma.gamesession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamesessionUpdateArgs>(args: SelectSubset<T, gamesessionUpdateArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Gamesessions.
     * @param {gamesessionDeleteManyArgs} args - Arguments to filter Gamesessions to delete.
     * @example
     * // Delete a few Gamesessions
     * const { count } = await prisma.gamesession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamesessionDeleteManyArgs>(args?: SelectSubset<T, gamesessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamesessions
     * const gamesession = await prisma.gamesession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamesessionUpdateManyArgs>(args: SelectSubset<T, gamesessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamesessions and returns the data updated in the database.
     * @param {gamesessionUpdateManyAndReturnArgs} args - Arguments to update many Gamesessions.
     * @example
     * // Update many Gamesessions
     * const gamesession = await prisma.gamesession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Gamesessions and only return the `id`
     * const gamesessionWithIdOnly = await prisma.gamesession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends gamesessionUpdateManyAndReturnArgs>(args: SelectSubset<T, gamesessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Gamesession.
     * @param {gamesessionUpsertArgs} args - Arguments to update or create a Gamesession.
     * @example
     * // Update or create a Gamesession
     * const gamesession = await prisma.gamesession.upsert({
     *   create: {
     *     // ... data to create a Gamesession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamesession we want to update
     *   }
     * })
     */
    upsert<T extends gamesessionUpsertArgs>(args: SelectSubset<T, gamesessionUpsertArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Gamesessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionCountArgs} args - Arguments to filter Gamesessions to count.
     * @example
     * // Count the number of Gamesessions
     * const count = await prisma.gamesession.count({
     *   where: {
     *     // ... the filter for the Gamesessions we want to count
     *   }
     * })
    **/
    count<T extends gamesessionCountArgs>(
      args?: Subset<T, gamesessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamesessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamesessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamesessionAggregateArgs>(args: Subset<T, GamesessionAggregateArgs>): Prisma.PrismaPromise<GetGamesessionAggregateType<T>>

    /**
     * Group by Gamesession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamesessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamesessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamesessionGroupByArgs['orderBy'] }
        : { orderBy?: gamesessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamesessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamesessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gamesession model
   */
  readonly fields: gamesessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gamesession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamesessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends gamesession$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$chatroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operatorgame<T extends operatorgameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorgameDefaultArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends gamesession$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$tournamentArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends gamesession$transactionArgs<ExtArgs> = {}>(args?: Subset<T, gamesession$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gamesession model
   */
  interface gamesessionFieldRefs {
    readonly id: FieldRef<"gamesession", 'String'>
    readonly startTime: FieldRef<"gamesession", 'DateTime'>
    readonly endTime: FieldRef<"gamesession", 'DateTime'>
    readonly betAmount: FieldRef<"gamesession", 'Decimal'>
    readonly winAmount: FieldRef<"gamesession", 'Decimal'>
    readonly xpEarned: FieldRef<"gamesession", 'Int'>
    readonly metadata: FieldRef<"gamesession", 'Json'>
    readonly gameId: FieldRef<"gamesession", 'String'>
    readonly tournamentId: FieldRef<"gamesession", 'String'>
    readonly active: FieldRef<"gamesession", 'Boolean'>
    readonly profileId: FieldRef<"gamesession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gamesession findUnique
   */
  export type gamesessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession findUniqueOrThrow
   */
  export type gamesessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession findFirst
   */
  export type gamesessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession findFirstOrThrow
   */
  export type gamesessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesession to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamesessions.
     */
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession findMany
   */
  export type gamesessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter, which gamesessions to fetch.
     */
    where?: gamesessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamesessions to fetch.
     */
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gamesessions.
     */
    cursor?: gamesessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamesessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamesessions.
     */
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * gamesession create
   */
  export type gamesessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The data needed to create a gamesession.
     */
    data: XOR<gamesessionCreateInput, gamesessionUncheckedCreateInput>
  }

  /**
   * gamesession createMany
   */
  export type gamesessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gamesessions.
     */
    data: gamesessionCreateManyInput | gamesessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gamesession createManyAndReturn
   */
  export type gamesessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * The data used to create many gamesessions.
     */
    data: gamesessionCreateManyInput | gamesessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * gamesession update
   */
  export type gamesessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The data needed to update a gamesession.
     */
    data: XOR<gamesessionUpdateInput, gamesessionUncheckedUpdateInput>
    /**
     * Choose, which gamesession to update.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession updateMany
   */
  export type gamesessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gamesessions.
     */
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyInput>
    /**
     * Filter which gamesessions to update
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to update.
     */
    limit?: number
  }

  /**
   * gamesession updateManyAndReturn
   */
  export type gamesessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * The data used to update gamesessions.
     */
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyInput>
    /**
     * Filter which gamesessions to update
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * gamesession upsert
   */
  export type gamesessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * The filter to search for the gamesession to update in case it exists.
     */
    where: gamesessionWhereUniqueInput
    /**
     * In case the gamesession found by the `where` argument doesn't exist, create a new gamesession with this data.
     */
    create: XOR<gamesessionCreateInput, gamesessionUncheckedCreateInput>
    /**
     * In case the gamesession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamesessionUpdateInput, gamesessionUncheckedUpdateInput>
  }

  /**
   * gamesession delete
   */
  export type gamesessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    /**
     * Filter which gamesession to delete.
     */
    where: gamesessionWhereUniqueInput
  }

  /**
   * gamesession deleteMany
   */
  export type gamesessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamesessions to delete
     */
    where?: gamesessionWhereInput
    /**
     * Limit how many gamesessions to delete.
     */
    limit?: number
  }

  /**
   * gamesession.chatroom
   */
  export type gamesession$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    where?: chatroomWhereInput
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    cursor?: chatroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * gamesession.tournament
   */
  export type gamesession$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    where?: tournamentWhereInput
  }

  /**
   * gamesession.transaction
   */
  export type gamesession$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * gamesession without action
   */
  export type gamesessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    title: number
    message: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type notificationSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "message" | "isRead" | "readAt" | "metadata" | "createdAt" | "userId", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type notificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'String'>
    readonly type: FieldRef<"notification", 'NotificationType'>
    readonly title: FieldRef<"notification", 'String'>
    readonly message: FieldRef<"notification", 'String'>
    readonly isRead: FieldRef<"notification", 'Boolean'>
    readonly readAt: FieldRef<"notification", 'DateTime'>
    readonly metadata: FieldRef<"notification", 'Json'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
    readonly userId: FieldRef<"notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification createManyAndReturn
   */
  export type notificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification updateManyAndReturn
   */
  export type notificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model operator
   */

  export type AggregateOperator = {
    _count: OperatorCountAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  export type OperatorMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type OperatorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ownerId: string | null
  }

  export type OperatorCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    ownerId: number
    _all: number
  }


  export type OperatorMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type OperatorMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
  }

  export type OperatorCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    ownerId?: true
    _all?: true
  }

  export type OperatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operator to aggregate.
     */
    where?: operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorOrderByWithRelationInput | operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operators
    **/
    _count?: true | OperatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorMaxAggregateInputType
  }

  export type GetOperatorAggregateType<T extends OperatorAggregateArgs> = {
        [P in keyof T & keyof AggregateOperator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperator[P]>
      : GetScalarType<T[P], AggregateOperator[P]>
  }




  export type operatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorWhereInput
    orderBy?: operatorOrderByWithAggregationInput | operatorOrderByWithAggregationInput[]
    by: OperatorScalarFieldEnum[] | OperatorScalarFieldEnum
    having?: operatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorCountAggregateInputType | true
    _min?: OperatorMinAggregateInputType
    _max?: OperatorMaxAggregateInputType
  }

  export type OperatorGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    ownerId: string
    _count: OperatorCountAggregateOutputType | null
    _min: OperatorMinAggregateOutputType | null
    _max: OperatorMaxAggregateOutputType | null
  }

  type GetOperatorGroupByPayload<T extends operatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorGroupByOutputType[P]>
        }
      >
    >


  export type operatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    bank?: boolean | operator$bankArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    operatorgame?: boolean | operator$operatorgameArgs<ExtArgs>
    profile?: boolean | operator$profileArgs<ExtArgs>
    tournament?: boolean | operator$tournamentArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type operatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type operatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operator"]>

  export type operatorSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ownerId?: boolean
  }

  export type operatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "description" | "isActive" | "createdAt" | "updatedAt" | "ownerId", ExtArgs["result"]["operator"]>
  export type operatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank?: boolean | operator$bankArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    operatorgame?: boolean | operator$operatorgameArgs<ExtArgs>
    profile?: boolean | operator$profileArgs<ExtArgs>
    tournament?: boolean | operator$tournamentArgs<ExtArgs>
    _count?: boolean | OperatorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type operatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type operatorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $operatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "operator"
    objects: {
      bank: Prisma.$bankPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
      operatorgame: Prisma.$operatorgamePayload<ExtArgs>[]
      profile: Prisma.$profilePayload<ExtArgs>[]
      tournament: Prisma.$tournamentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      ownerId: string
    }, ExtArgs["result"]["operator"]>
    composites: {}
  }

  type operatorGetPayload<S extends boolean | null | undefined | operatorDefaultArgs> = $Result.GetResult<Prisma.$operatorPayload, S>

  type operatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<operatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorCountAggregateInputType | true
    }

  export interface operatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operator'], meta: { name: 'operator' } }
    /**
     * Find zero or one Operator that matches the filter.
     * @param {operatorFindUniqueArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends operatorFindUniqueArgs>(args: SelectSubset<T, operatorFindUniqueArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {operatorFindUniqueOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends operatorFindUniqueOrThrowArgs>(args: SelectSubset<T, operatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorFindFirstArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends operatorFindFirstArgs>(args?: SelectSubset<T, operatorFindFirstArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorFindFirstOrThrowArgs} args - Arguments to find a Operator
     * @example
     * // Get one Operator
     * const operator = await prisma.operator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends operatorFindFirstOrThrowArgs>(args?: SelectSubset<T, operatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operators
     * const operators = await prisma.operator.findMany()
     * 
     * // Get first 10 Operators
     * const operators = await prisma.operator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorWithIdOnly = await prisma.operator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends operatorFindManyArgs>(args?: SelectSubset<T, operatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operator.
     * @param {operatorCreateArgs} args - Arguments to create a Operator.
     * @example
     * // Create one Operator
     * const Operator = await prisma.operator.create({
     *   data: {
     *     // ... data to create a Operator
     *   }
     * })
     * 
     */
    create<T extends operatorCreateArgs>(args: SelectSubset<T, operatorCreateArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operators.
     * @param {operatorCreateManyArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends operatorCreateManyArgs>(args?: SelectSubset<T, operatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operators and returns the data saved in the database.
     * @param {operatorCreateManyAndReturnArgs} args - Arguments to create many Operators.
     * @example
     * // Create many Operators
     * const operator = await prisma.operator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends operatorCreateManyAndReturnArgs>(args?: SelectSubset<T, operatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operator.
     * @param {operatorDeleteArgs} args - Arguments to delete one Operator.
     * @example
     * // Delete one Operator
     * const Operator = await prisma.operator.delete({
     *   where: {
     *     // ... filter to delete one Operator
     *   }
     * })
     * 
     */
    delete<T extends operatorDeleteArgs>(args: SelectSubset<T, operatorDeleteArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operator.
     * @param {operatorUpdateArgs} args - Arguments to update one Operator.
     * @example
     * // Update one Operator
     * const operator = await prisma.operator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends operatorUpdateArgs>(args: SelectSubset<T, operatorUpdateArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operators.
     * @param {operatorDeleteManyArgs} args - Arguments to filter Operators to delete.
     * @example
     * // Delete a few Operators
     * const { count } = await prisma.operator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends operatorDeleteManyArgs>(args?: SelectSubset<T, operatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends operatorUpdateManyArgs>(args: SelectSubset<T, operatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operators and returns the data updated in the database.
     * @param {operatorUpdateManyAndReturnArgs} args - Arguments to update many Operators.
     * @example
     * // Update many Operators
     * const operator = await prisma.operator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operators and only return the `id`
     * const operatorWithIdOnly = await prisma.operator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends operatorUpdateManyAndReturnArgs>(args: SelectSubset<T, operatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operator.
     * @param {operatorUpsertArgs} args - Arguments to update or create a Operator.
     * @example
     * // Update or create a Operator
     * const operator = await prisma.operator.upsert({
     *   create: {
     *     // ... data to create a Operator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operator we want to update
     *   }
     * })
     */
    upsert<T extends operatorUpsertArgs>(args: SelectSubset<T, operatorUpsertArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorCountArgs} args - Arguments to filter Operators to count.
     * @example
     * // Count the number of Operators
     * const count = await prisma.operator.count({
     *   where: {
     *     // ... the filter for the Operators we want to count
     *   }
     * })
    **/
    count<T extends operatorCountArgs>(
      args?: Subset<T, operatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorAggregateArgs>(args: Subset<T, OperatorAggregateArgs>): Prisma.PrismaPromise<GetOperatorAggregateType<T>>

    /**
     * Group by Operator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operatorGroupByArgs['orderBy'] }
        : { orderBy?: operatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operator model
   */
  readonly fields: operatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__operatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bank<T extends operator$bankArgs<ExtArgs> = {}>(args?: Subset<T, operator$bankArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    operatorgame<T extends operator$operatorgameArgs<ExtArgs> = {}>(args?: Subset<T, operator$operatorgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile<T extends operator$profileArgs<ExtArgs> = {}>(args?: Subset<T, operator$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournament<T extends operator$tournamentArgs<ExtArgs> = {}>(args?: Subset<T, operator$tournamentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the operator model
   */
  interface operatorFieldRefs {
    readonly id: FieldRef<"operator", 'String'>
    readonly name: FieldRef<"operator", 'String'>
    readonly slug: FieldRef<"operator", 'String'>
    readonly logo: FieldRef<"operator", 'String'>
    readonly description: FieldRef<"operator", 'String'>
    readonly isActive: FieldRef<"operator", 'Boolean'>
    readonly createdAt: FieldRef<"operator", 'DateTime'>
    readonly updatedAt: FieldRef<"operator", 'DateTime'>
    readonly ownerId: FieldRef<"operator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * operator findUnique
   */
  export type operatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter, which operator to fetch.
     */
    where: operatorWhereUniqueInput
  }

  /**
   * operator findUniqueOrThrow
   */
  export type operatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter, which operator to fetch.
     */
    where: operatorWhereUniqueInput
  }

  /**
   * operator findFirst
   */
  export type operatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter, which operator to fetch.
     */
    where?: operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorOrderByWithRelationInput | operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operators.
     */
    cursor?: operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * operator findFirstOrThrow
   */
  export type operatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter, which operator to fetch.
     */
    where?: operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorOrderByWithRelationInput | operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operators.
     */
    cursor?: operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operators.
     */
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * operator findMany
   */
  export type operatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter, which operators to fetch.
     */
    where?: operatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operators to fetch.
     */
    orderBy?: operatorOrderByWithRelationInput | operatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operators.
     */
    cursor?: operatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operators.
     */
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * operator create
   */
  export type operatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * The data needed to create a operator.
     */
    data: XOR<operatorCreateInput, operatorUncheckedCreateInput>
  }

  /**
   * operator createMany
   */
  export type operatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operators.
     */
    data: operatorCreateManyInput | operatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operator createManyAndReturn
   */
  export type operatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * The data used to create many operators.
     */
    data: operatorCreateManyInput | operatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * operator update
   */
  export type operatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * The data needed to update a operator.
     */
    data: XOR<operatorUpdateInput, operatorUncheckedUpdateInput>
    /**
     * Choose, which operator to update.
     */
    where: operatorWhereUniqueInput
  }

  /**
   * operator updateMany
   */
  export type operatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operators.
     */
    data: XOR<operatorUpdateManyMutationInput, operatorUncheckedUpdateManyInput>
    /**
     * Filter which operators to update
     */
    where?: operatorWhereInput
    /**
     * Limit how many operators to update.
     */
    limit?: number
  }

  /**
   * operator updateManyAndReturn
   */
  export type operatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * The data used to update operators.
     */
    data: XOR<operatorUpdateManyMutationInput, operatorUncheckedUpdateManyInput>
    /**
     * Filter which operators to update
     */
    where?: operatorWhereInput
    /**
     * Limit how many operators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * operator upsert
   */
  export type operatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * The filter to search for the operator to update in case it exists.
     */
    where: operatorWhereUniqueInput
    /**
     * In case the operator found by the `where` argument doesn't exist, create a new operator with this data.
     */
    create: XOR<operatorCreateInput, operatorUncheckedCreateInput>
    /**
     * In case the operator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operatorUpdateInput, operatorUncheckedUpdateInput>
  }

  /**
   * operator delete
   */
  export type operatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    /**
     * Filter which operator to delete.
     */
    where: operatorWhereUniqueInput
  }

  /**
   * operator deleteMany
   */
  export type operatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operators to delete
     */
    where?: operatorWhereInput
    /**
     * Limit how many operators to delete.
     */
    limit?: number
  }

  /**
   * operator.bank
   */
  export type operator$bankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bank
     */
    select?: bankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bank
     */
    omit?: bankOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bankInclude<ExtArgs> | null
    where?: bankWhereInput
    orderBy?: bankOrderByWithRelationInput | bankOrderByWithRelationInput[]
    cursor?: bankWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankScalarFieldEnum | BankScalarFieldEnum[]
  }

  /**
   * operator.operatorgame
   */
  export type operator$operatorgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    where?: operatorgameWhereInput
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    cursor?: operatorgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operator.profile
   */
  export type operator$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * operator.tournament
   */
  export type operator$tournamentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    where?: tournamentWhereInput
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    cursor?: tournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * operator without action
   */
  export type operatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
  }


  /**
   * Model operatorgame
   */

  export type AggregateOperatorgame = {
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  export type OperatorgameAvgAggregateOutputType = {
    minBet: Decimal | null
    maxBet: Decimal | null
    xpMultiplier: number | null
  }

  export type OperatorgameSumAggregateOutputType = {
    minBet: Decimal | null
    maxBet: Decimal | null
    xpMultiplier: number | null
  }

  export type OperatorgameMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: Decimal | null
    maxBet: Decimal | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    thumbnail: string | null
    minBet: Decimal | null
    maxBet: Decimal | null
    xpMultiplier: number | null
    isActive: boolean | null
    isPromoted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type OperatorgameCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    thumbnail: number
    minBet: number
    maxBet: number
    xpMultiplier: number
    isActive: number
    isPromoted: number
    createdAt: number
    updatedAt: number
    operatorId: number
    _all: number
  }


  export type OperatorgameAvgAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameSumAggregateInputType = {
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
  }

  export type OperatorgameMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type OperatorgameCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    thumbnail?: true
    minBet?: true
    maxBet?: true
    xpMultiplier?: true
    isActive?: true
    isPromoted?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    _all?: true
  }

  export type OperatorgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operatorgame to aggregate.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned operatorgames
    **/
    _count?: true | OperatorgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperatorgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperatorgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperatorgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperatorgameMaxAggregateInputType
  }

  export type GetOperatorgameAggregateType<T extends OperatorgameAggregateArgs> = {
        [P in keyof T & keyof AggregateOperatorgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperatorgame[P]>
      : GetScalarType<T[P], AggregateOperatorgame[P]>
  }




  export type operatorgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: operatorgameWhereInput
    orderBy?: operatorgameOrderByWithAggregationInput | operatorgameOrderByWithAggregationInput[]
    by: OperatorgameScalarFieldEnum[] | OperatorgameScalarFieldEnum
    having?: operatorgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperatorgameCountAggregateInputType | true
    _avg?: OperatorgameAvgAggregateInputType
    _sum?: OperatorgameSumAggregateInputType
    _min?: OperatorgameMinAggregateInputType
    _max?: OperatorgameMaxAggregateInputType
  }

  export type OperatorgameGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    thumbnail: string | null
    minBet: Decimal | null
    maxBet: Decimal | null
    xpMultiplier: number
    isActive: boolean
    isPromoted: boolean
    createdAt: Date
    updatedAt: Date
    operatorId: string
    _count: OperatorgameCountAggregateOutputType | null
    _avg: OperatorgameAvgAggregateOutputType | null
    _sum: OperatorgameSumAggregateOutputType | null
    _min: OperatorgameMinAggregateOutputType | null
    _max: OperatorgameMaxAggregateOutputType | null
  }

  type GetOperatorgameGroupByPayload<T extends operatorgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperatorgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperatorgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
            : GetScalarType<T[P], OperatorgameGroupByOutputType[P]>
        }
      >
    >


  export type operatorgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    gamesession?: boolean | operatorgame$gamesessionArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    tournamentgame?: boolean | operatorgame$tournamentgameArgs<ExtArgs>
    _count?: boolean | OperatorgameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operatorgame"]>

  export type operatorgameSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    thumbnail?: boolean
    minBet?: boolean
    maxBet?: boolean
    xpMultiplier?: boolean
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
  }

  export type operatorgameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "thumbnail" | "minBet" | "maxBet" | "xpMultiplier" | "isActive" | "isPromoted" | "createdAt" | "updatedAt" | "operatorId", ExtArgs["result"]["operatorgame"]>
  export type operatorgameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | operatorgame$gamesessionArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    tournamentgame?: boolean | operatorgame$tournamentgameArgs<ExtArgs>
    _count?: boolean | OperatorgameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type operatorgameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }
  export type operatorgameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }

  export type $operatorgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "operatorgame"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      operator: Prisma.$operatorPayload<ExtArgs>
      tournamentgame: Prisma.$tournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      thumbnail: string | null
      minBet: Prisma.Decimal | null
      maxBet: Prisma.Decimal | null
      xpMultiplier: number
      isActive: boolean
      isPromoted: boolean
      createdAt: Date
      updatedAt: Date
      operatorId: string
    }, ExtArgs["result"]["operatorgame"]>
    composites: {}
  }

  type operatorgameGetPayload<S extends boolean | null | undefined | operatorgameDefaultArgs> = $Result.GetResult<Prisma.$operatorgamePayload, S>

  type operatorgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<operatorgameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperatorgameCountAggregateInputType | true
    }

  export interface operatorgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['operatorgame'], meta: { name: 'operatorgame' } }
    /**
     * Find zero or one Operatorgame that matches the filter.
     * @param {operatorgameFindUniqueArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends operatorgameFindUniqueArgs>(args: SelectSubset<T, operatorgameFindUniqueArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Operatorgame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {operatorgameFindUniqueOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends operatorgameFindUniqueOrThrowArgs>(args: SelectSubset<T, operatorgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operatorgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindFirstArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends operatorgameFindFirstArgs>(args?: SelectSubset<T, operatorgameFindFirstArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Operatorgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindFirstOrThrowArgs} args - Arguments to find a Operatorgame
     * @example
     * // Get one Operatorgame
     * const operatorgame = await prisma.operatorgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends operatorgameFindFirstOrThrowArgs>(args?: SelectSubset<T, operatorgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Operatorgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany()
     * 
     * // Get first 10 Operatorgames
     * const operatorgames = await prisma.operatorgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends operatorgameFindManyArgs>(args?: SelectSubset<T, operatorgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Operatorgame.
     * @param {operatorgameCreateArgs} args - Arguments to create a Operatorgame.
     * @example
     * // Create one Operatorgame
     * const Operatorgame = await prisma.operatorgame.create({
     *   data: {
     *     // ... data to create a Operatorgame
     *   }
     * })
     * 
     */
    create<T extends operatorgameCreateArgs>(args: SelectSubset<T, operatorgameCreateArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Operatorgames.
     * @param {operatorgameCreateManyArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends operatorgameCreateManyArgs>(args?: SelectSubset<T, operatorgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Operatorgames and returns the data saved in the database.
     * @param {operatorgameCreateManyAndReturnArgs} args - Arguments to create many Operatorgames.
     * @example
     * // Create many Operatorgames
     * const operatorgame = await prisma.operatorgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Operatorgames and only return the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends operatorgameCreateManyAndReturnArgs>(args?: SelectSubset<T, operatorgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Operatorgame.
     * @param {operatorgameDeleteArgs} args - Arguments to delete one Operatorgame.
     * @example
     * // Delete one Operatorgame
     * const Operatorgame = await prisma.operatorgame.delete({
     *   where: {
     *     // ... filter to delete one Operatorgame
     *   }
     * })
     * 
     */
    delete<T extends operatorgameDeleteArgs>(args: SelectSubset<T, operatorgameDeleteArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Operatorgame.
     * @param {operatorgameUpdateArgs} args - Arguments to update one Operatorgame.
     * @example
     * // Update one Operatorgame
     * const operatorgame = await prisma.operatorgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends operatorgameUpdateArgs>(args: SelectSubset<T, operatorgameUpdateArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Operatorgames.
     * @param {operatorgameDeleteManyArgs} args - Arguments to filter Operatorgames to delete.
     * @example
     * // Delete a few Operatorgames
     * const { count } = await prisma.operatorgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends operatorgameDeleteManyArgs>(args?: SelectSubset<T, operatorgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Operatorgames
     * const operatorgame = await prisma.operatorgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends operatorgameUpdateManyArgs>(args: SelectSubset<T, operatorgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Operatorgames and returns the data updated in the database.
     * @param {operatorgameUpdateManyAndReturnArgs} args - Arguments to update many Operatorgames.
     * @example
     * // Update many Operatorgames
     * const operatorgame = await prisma.operatorgame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Operatorgames and only return the `id`
     * const operatorgameWithIdOnly = await prisma.operatorgame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends operatorgameUpdateManyAndReturnArgs>(args: SelectSubset<T, operatorgameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Operatorgame.
     * @param {operatorgameUpsertArgs} args - Arguments to update or create a Operatorgame.
     * @example
     * // Update or create a Operatorgame
     * const operatorgame = await prisma.operatorgame.upsert({
     *   create: {
     *     // ... data to create a Operatorgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Operatorgame we want to update
     *   }
     * })
     */
    upsert<T extends operatorgameUpsertArgs>(args: SelectSubset<T, operatorgameUpsertArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Operatorgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameCountArgs} args - Arguments to filter Operatorgames to count.
     * @example
     * // Count the number of Operatorgames
     * const count = await prisma.operatorgame.count({
     *   where: {
     *     // ... the filter for the Operatorgames we want to count
     *   }
     * })
    **/
    count<T extends operatorgameCountArgs>(
      args?: Subset<T, operatorgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperatorgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperatorgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperatorgameAggregateArgs>(args: Subset<T, OperatorgameAggregateArgs>): Prisma.PrismaPromise<GetOperatorgameAggregateType<T>>

    /**
     * Group by Operatorgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {operatorgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends operatorgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: operatorgameGroupByArgs['orderBy'] }
        : { orderBy?: operatorgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, operatorgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperatorgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the operatorgame model
   */
  readonly fields: operatorgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for operatorgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__operatorgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends operatorgame$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, operatorgame$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorDefaultArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournamentgame<T extends operatorgame$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, operatorgame$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the operatorgame model
   */
  interface operatorgameFieldRefs {
    readonly id: FieldRef<"operatorgame", 'String'>
    readonly name: FieldRef<"operatorgame", 'String'>
    readonly slug: FieldRef<"operatorgame", 'String'>
    readonly description: FieldRef<"operatorgame", 'String'>
    readonly thumbnail: FieldRef<"operatorgame", 'String'>
    readonly minBet: FieldRef<"operatorgame", 'Decimal'>
    readonly maxBet: FieldRef<"operatorgame", 'Decimal'>
    readonly xpMultiplier: FieldRef<"operatorgame", 'Float'>
    readonly isActive: FieldRef<"operatorgame", 'Boolean'>
    readonly isPromoted: FieldRef<"operatorgame", 'Boolean'>
    readonly createdAt: FieldRef<"operatorgame", 'DateTime'>
    readonly updatedAt: FieldRef<"operatorgame", 'DateTime'>
    readonly operatorId: FieldRef<"operatorgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * operatorgame findUnique
   */
  export type operatorgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame findUniqueOrThrow
   */
  export type operatorgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame findFirst
   */
  export type operatorgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame findFirstOrThrow
   */
  export type operatorgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter, which operatorgame to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of operatorgames.
     */
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame findMany
   */
  export type operatorgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter, which operatorgames to fetch.
     */
    where?: operatorgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of operatorgames to fetch.
     */
    orderBy?: operatorgameOrderByWithRelationInput | operatorgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing operatorgames.
     */
    cursor?: operatorgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` operatorgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` operatorgames.
     */
    skip?: number
    distinct?: OperatorgameScalarFieldEnum | OperatorgameScalarFieldEnum[]
  }

  /**
   * operatorgame create
   */
  export type operatorgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * The data needed to create a operatorgame.
     */
    data: XOR<operatorgameCreateInput, operatorgameUncheckedCreateInput>
  }

  /**
   * operatorgame createMany
   */
  export type operatorgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many operatorgames.
     */
    data: operatorgameCreateManyInput | operatorgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * operatorgame createManyAndReturn
   */
  export type operatorgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data used to create many operatorgames.
     */
    data: operatorgameCreateManyInput | operatorgameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * operatorgame update
   */
  export type operatorgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * The data needed to update a operatorgame.
     */
    data: XOR<operatorgameUpdateInput, operatorgameUncheckedUpdateInput>
    /**
     * Choose, which operatorgame to update.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame updateMany
   */
  export type operatorgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update operatorgames.
     */
    data: XOR<operatorgameUpdateManyMutationInput, operatorgameUncheckedUpdateManyInput>
    /**
     * Filter which operatorgames to update
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to update.
     */
    limit?: number
  }

  /**
   * operatorgame updateManyAndReturn
   */
  export type operatorgameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * The data used to update operatorgames.
     */
    data: XOR<operatorgameUpdateManyMutationInput, operatorgameUncheckedUpdateManyInput>
    /**
     * Filter which operatorgames to update
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * operatorgame upsert
   */
  export type operatorgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * The filter to search for the operatorgame to update in case it exists.
     */
    where: operatorgameWhereUniqueInput
    /**
     * In case the operatorgame found by the `where` argument doesn't exist, create a new operatorgame with this data.
     */
    create: XOR<operatorgameCreateInput, operatorgameUncheckedCreateInput>
    /**
     * In case the operatorgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<operatorgameUpdateInput, operatorgameUncheckedUpdateInput>
  }

  /**
   * operatorgame delete
   */
  export type operatorgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
    /**
     * Filter which operatorgame to delete.
     */
    where: operatorgameWhereUniqueInput
  }

  /**
   * operatorgame deleteMany
   */
  export type operatorgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which operatorgames to delete
     */
    where?: operatorgameWhereInput
    /**
     * Limit how many operatorgames to delete.
     */
    limit?: number
  }

  /**
   * operatorgame.gamesession
   */
  export type operatorgame$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * operatorgame.tournamentgame
   */
  export type operatorgame$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    cursor?: tournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * operatorgame without action
   */
  export type operatorgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operatorgame
     */
    select?: operatorgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operatorgame
     */
    omit?: operatorgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorgameInclude<ExtArgs> | null
  }


  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    balance: number | null
    xpEarned: number | null
    phpId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    profileNumber: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    bankId: string | null
    shopId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    profileNumber: string | null
    balance: number | null
    xpEarned: number | null
    isActive: boolean | null
    lastPlayed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    phpId: number | null
    userId: string | null
    bankId: string | null
    shopId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    profileNumber: number
    balance: number
    xpEarned: number
    isActive: number
    lastPlayed: number
    createdAt: number
    updatedAt: number
    phpId: number
    userId: number
    bankId: number
    shopId: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileSumAggregateInputType = {
    balance?: true
    xpEarned?: true
    phpId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    profileNumber?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    bankId?: true
    shopId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    profileNumber?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    bankId?: true
    shopId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    profileNumber?: true
    balance?: true
    xpEarned?: true
    isActive?: true
    lastPlayed?: true
    createdAt?: true
    updatedAt?: true
    phpId?: true
    userId?: true
    bankId?: true
    shopId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    profileNumber: string
    balance: number
    xpEarned: number
    isActive: boolean
    lastPlayed: Date | null
    createdAt: Date
    updatedAt: Date
    phpId: number | null
    userId: string
    bankId: string
    shopId: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileNumber?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    bankId?: boolean
    shopId?: boolean
    gamesession?: boolean | profile$gamesessionArgs<ExtArgs>
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
    tournamententry?: boolean | profile$tournamententryArgs<ExtArgs>
    transaction?: boolean | profile$transactionArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileNumber?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    bankId?: boolean
    shopId?: boolean
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileNumber?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    bankId?: boolean
    shopId?: boolean
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    id?: boolean
    profileNumber?: boolean
    balance?: boolean
    xpEarned?: boolean
    isActive?: boolean
    lastPlayed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phpId?: boolean
    userId?: boolean
    bankId?: boolean
    shopId?: boolean
  }

  export type profileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileNumber" | "balance" | "xpEarned" | "isActive" | "lastPlayed" | "createdAt" | "updatedAt" | "phpId" | "userId" | "bankId" | "shopId", ExtArgs["result"]["profile"]>
  export type profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | profile$gamesessionArgs<ExtArgs>
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
    tournamententry?: boolean | profile$tournamententryArgs<ExtArgs>
    transaction?: boolean | profile$transactionArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type profileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }
  export type profileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank?: boolean | bankDefaultArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    user_profile_userIdTouser?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      bank: Prisma.$bankPayload<ExtArgs>
      operator: Prisma.$operatorPayload<ExtArgs>
      user_profile_userIdTouser: Prisma.$userPayload<ExtArgs>
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      transaction: Prisma.$transactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileNumber: string
      balance: number
      xpEarned: number
      isActive: boolean
      lastPlayed: Date | null
      createdAt: Date
      updatedAt: Date
      phpId: number | null
      userId: string
      bankId: string
      shopId: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profileFindUniqueArgs>(args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs>(args: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profileFindFirstArgs>(args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs>(args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profileFindManyArgs>(args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends profileCreateArgs>(args: SelectSubset<T, profileCreateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profileCreateManyArgs>(args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {profileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profileCreateManyAndReturnArgs>(args?: SelectSubset<T, profileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends profileDeleteArgs>(args: SelectSubset<T, profileDeleteArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profileUpdateArgs>(args: SelectSubset<T, profileUpdateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profileDeleteManyArgs>(args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profileUpdateManyArgs>(args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {profileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends profileUpdateManyAndReturnArgs>(args: SelectSubset<T, profileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends profileUpsertArgs>(args: SelectSubset<T, profileUpsertArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends profile$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, profile$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bank<T extends bankDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bankDefaultArgs<ExtArgs>>): Prisma__bankClient<$Result.GetResult<Prisma.$bankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    operator<T extends operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorDefaultArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user_profile_userIdTouser<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournamententry<T extends profile$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, profile$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction<T extends profile$transactionArgs<ExtArgs> = {}>(args?: Subset<T, profile$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profile model
   */
  interface profileFieldRefs {
    readonly id: FieldRef<"profile", 'String'>
    readonly profileNumber: FieldRef<"profile", 'String'>
    readonly balance: FieldRef<"profile", 'Int'>
    readonly xpEarned: FieldRef<"profile", 'Int'>
    readonly isActive: FieldRef<"profile", 'Boolean'>
    readonly lastPlayed: FieldRef<"profile", 'DateTime'>
    readonly createdAt: FieldRef<"profile", 'DateTime'>
    readonly updatedAt: FieldRef<"profile", 'DateTime'>
    readonly phpId: FieldRef<"profile", 'Int'>
    readonly userId: FieldRef<"profile", 'String'>
    readonly bankId: FieldRef<"profile", 'String'>
    readonly shopId: FieldRef<"profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }

  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profile createManyAndReturn
   */
  export type profileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
  }

  /**
   * profile updateManyAndReturn
   */
  export type profileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
    /**
     * Limit how many profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }

  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
    /**
     * Limit how many profiles to delete.
     */
    limit?: number
  }

  /**
   * profile.gamesession
   */
  export type profile$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * profile.tournamententry
   */
  export type profile$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * profile.transaction
   */
  export type profile$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    cursor?: transactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    refreshToken: string | null
    active: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    activeGameId: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    refreshToken: number
    active: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    activeGameId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    refreshToken?: true
    active?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    activeGameId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    refreshToken: string
    active: boolean
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    id?: boolean
    userId?: boolean
    activeGameId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    refreshToken?: boolean
    active?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "activeGameId" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt" | "refreshToken" | "active", ExtArgs["result"]["session"]>
  export type sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type sessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type sessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      activeGameId: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      refreshToken: string
      active: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly id: FieldRef<"session", 'String'>
    readonly userId: FieldRef<"session", 'String'>
    readonly activeGameId: FieldRef<"session", 'String'>
    readonly ipAddress: FieldRef<"session", 'String'>
    readonly userAgent: FieldRef<"session", 'String'>
    readonly expiresAt: FieldRef<"session", 'DateTime'>
    readonly createdAt: FieldRef<"session", 'DateTime'>
    readonly refreshToken: FieldRef<"session", 'String'>
    readonly active: FieldRef<"session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session createManyAndReturn
   */
  export type sessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session updateManyAndReturn
   */
  export type sessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
  }


  /**
   * Model tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    entryFee: Decimal | null
    prizePool: Decimal | null
  }

  export type TournamentSumAggregateOutputType = {
    entryFee: Decimal | null
    prizePool: Decimal | null
  }

  export type TournamentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: Decimal | null
    prizePool: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    entryFee: Decimal | null
    prizePool: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    operatorId: string | null
  }

  export type TournamentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startTime: number
    endTime: number
    entryFee: number
    prizePool: number
    isActive: number
    createdAt: number
    updatedAt: number
    operatorId: number
    leaderboard: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentSumAggregateInputType = {
    entryFee?: true
    prizePool?: true
  }

  export type TournamentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
  }

  export type TournamentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    entryFee?: true
    prizePool?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    operatorId?: true
    leaderboard?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournament to aggregate.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type tournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentWhereInput
    orderBy?: tournamentOrderByWithAggregationInput | tournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: tournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startTime: Date
    endTime: Date
    entryFee: Decimal | null
    prizePool: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    operatorId: string
    leaderboard: JsonValue | null
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends tournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type tournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    gamesession?: boolean | tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type tournamentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    entryFee?: boolean
    prizePool?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    operatorId?: boolean
    leaderboard?: boolean
  }

  export type tournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "startTime" | "endTime" | "entryFee" | "prizePool" | "isActive" | "createdAt" | "updatedAt" | "operatorId" | "leaderboard", ExtArgs["result"]["tournament"]>
  export type tournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | tournament$gamesessionArgs<ExtArgs>
    operator?: boolean | operatorDefaultArgs<ExtArgs>
    tournamententry?: boolean | tournament$tournamententryArgs<ExtArgs>
    tournamentgame?: boolean | tournament$tournamentgameArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }
  export type tournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operator?: boolean | operatorDefaultArgs<ExtArgs>
  }

  export type $tournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournament"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs>[]
      operator: Prisma.$operatorPayload<ExtArgs>
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      tournamentgame: Prisma.$tournamentgamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startTime: Date
      endTime: Date
      entryFee: Prisma.Decimal | null
      prizePool: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      operatorId: string
      leaderboard: Prisma.JsonValue | null
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type tournamentGetPayload<S extends boolean | null | undefined | tournamentDefaultArgs> = $Result.GetResult<Prisma.$tournamentPayload, S>

  type tournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface tournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournament'], meta: { name: 'tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {tournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentFindUniqueArgs>(args: SelectSubset<T, tournamentFindUniqueArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentFindFirstArgs>(args?: SelectSubset<T, tournamentFindFirstArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentWithIdOnly = await prisma.tournament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentFindManyArgs>(args?: SelectSubset<T, tournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournament.
     * @param {tournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends tournamentCreateArgs>(args: SelectSubset<T, tournamentCreateArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {tournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentCreateManyArgs>(args?: SelectSubset<T, tournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {tournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournament.
     * @param {tournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends tournamentDeleteArgs>(args: SelectSubset<T, tournamentDeleteArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournament.
     * @param {tournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentUpdateArgs>(args: SelectSubset<T, tournamentUpdateArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {tournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentDeleteManyArgs>(args?: SelectSubset<T, tournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentUpdateManyArgs>(args: SelectSubset<T, tournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {tournamentUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `id`
     * const tournamentWithIdOnly = await prisma.tournament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournament.
     * @param {tournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends tournamentUpsertArgs>(args: SelectSubset<T, tournamentUpsertArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends tournamentCountArgs>(
      args?: Subset<T, tournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentGroupByArgs['orderBy'] }
        : { orderBy?: tournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournament model
   */
  readonly fields: tournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends tournament$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, tournament$gamesessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends operatorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorDefaultArgs<ExtArgs>>): Prisma__operatorClient<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournamententry<T extends tournament$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, tournament$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentgame<T extends tournament$tournamentgameArgs<ExtArgs> = {}>(args?: Subset<T, tournament$tournamentgameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournament model
   */
  interface tournamentFieldRefs {
    readonly id: FieldRef<"tournament", 'String'>
    readonly name: FieldRef<"tournament", 'String'>
    readonly description: FieldRef<"tournament", 'String'>
    readonly startTime: FieldRef<"tournament", 'DateTime'>
    readonly endTime: FieldRef<"tournament", 'DateTime'>
    readonly entryFee: FieldRef<"tournament", 'Decimal'>
    readonly prizePool: FieldRef<"tournament", 'Decimal'>
    readonly isActive: FieldRef<"tournament", 'Boolean'>
    readonly createdAt: FieldRef<"tournament", 'DateTime'>
    readonly updatedAt: FieldRef<"tournament", 'DateTime'>
    readonly operatorId: FieldRef<"tournament", 'String'>
    readonly leaderboard: FieldRef<"tournament", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * tournament findUnique
   */
  export type tournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament findUniqueOrThrow
   */
  export type tournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament findFirst
   */
  export type tournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament findFirstOrThrow
   */
  export type tournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournament to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament findMany
   */
  export type tournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter, which tournaments to fetch.
     */
    where?: tournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournaments to fetch.
     */
    orderBy?: tournamentOrderByWithRelationInput | tournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournaments.
     */
    cursor?: tournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * tournament create
   */
  export type tournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a tournament.
     */
    data: XOR<tournamentCreateInput, tournamentUncheckedCreateInput>
  }

  /**
   * tournament createMany
   */
  export type tournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournaments.
     */
    data: tournamentCreateManyInput | tournamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournament createManyAndReturn
   */
  export type tournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * The data used to create many tournaments.
     */
    data: tournamentCreateManyInput | tournamentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament update
   */
  export type tournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a tournament.
     */
    data: XOR<tournamentUpdateInput, tournamentUncheckedUpdateInput>
    /**
     * Choose, which tournament to update.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament updateMany
   */
  export type tournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
  }

  /**
   * tournament updateManyAndReturn
   */
  export type tournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * The data used to update tournaments.
     */
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyInput>
    /**
     * Filter which tournaments to update
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournament upsert
   */
  export type tournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the tournament to update in case it exists.
     */
    where: tournamentWhereUniqueInput
    /**
     * In case the tournament found by the `where` argument doesn't exist, create a new tournament with this data.
     */
    create: XOR<tournamentCreateInput, tournamentUncheckedCreateInput>
    /**
     * In case the tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentUpdateInput, tournamentUncheckedUpdateInput>
  }

  /**
   * tournament delete
   */
  export type tournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
    /**
     * Filter which tournament to delete.
     */
    where: tournamentWhereUniqueInput
  }

  /**
   * tournament deleteMany
   */
  export type tournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournaments to delete
     */
    where?: tournamentWhereInput
    /**
     * Limit how many tournaments to delete.
     */
    limit?: number
  }

  /**
   * tournament.gamesession
   */
  export type tournament$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
    orderBy?: gamesessionOrderByWithRelationInput | gamesessionOrderByWithRelationInput[]
    cursor?: gamesessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GamesessionScalarFieldEnum | GamesessionScalarFieldEnum[]
  }

  /**
   * tournament.tournamententry
   */
  export type tournament$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournament.tournamentgame
   */
  export type tournament$tournamentgameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    cursor?: tournamentgameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournament without action
   */
  export type tournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournament
     */
    select?: tournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournament
     */
    omit?: tournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentInclude<ExtArgs> | null
  }


  /**
   * Model tournamententry
   */

  export type AggregateTournamententry = {
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  export type TournamententryAvgAggregateOutputType = {
    score: number | null
    wagered: Decimal | null
    won: Decimal | null
  }

  export type TournamententrySumAggregateOutputType = {
    score: number | null
    wagered: Decimal | null
    won: Decimal | null
  }

  export type TournamententryMinAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: Decimal | null
    won: Decimal | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryMaxAggregateOutputType = {
    id: string | null
    score: number | null
    wagered: Decimal | null
    won: Decimal | null
    joinedAt: Date | null
    userId: string | null
    tournamentId: string | null
    profileId: string | null
  }

  export type TournamententryCountAggregateOutputType = {
    id: number
    score: number
    wagered: number
    won: number
    joinedAt: number
    userId: number
    tournamentId: number
    profileId: number
    _all: number
  }


  export type TournamententryAvgAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententrySumAggregateInputType = {
    score?: true
    wagered?: true
    won?: true
  }

  export type TournamententryMinAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryMaxAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
  }

  export type TournamententryCountAggregateInputType = {
    id?: true
    score?: true
    wagered?: true
    won?: true
    joinedAt?: true
    userId?: true
    tournamentId?: true
    profileId?: true
    _all?: true
  }

  export type TournamententryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamententry to aggregate.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournamententries
    **/
    _count?: true | TournamententryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamententryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamententrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamententryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamententryMaxAggregateInputType
  }

  export type GetTournamententryAggregateType<T extends TournamententryAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamententry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamententry[P]>
      : GetScalarType<T[P], AggregateTournamententry[P]>
  }




  export type tournamententryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithAggregationInput | tournamententryOrderByWithAggregationInput[]
    by: TournamententryScalarFieldEnum[] | TournamententryScalarFieldEnum
    having?: tournamententryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamententryCountAggregateInputType | true
    _avg?: TournamententryAvgAggregateInputType
    _sum?: TournamententrySumAggregateInputType
    _min?: TournamententryMinAggregateInputType
    _max?: TournamententryMaxAggregateInputType
  }

  export type TournamententryGroupByOutputType = {
    id: string
    score: number
    wagered: Decimal
    won: Decimal
    joinedAt: Date
    userId: string
    tournamentId: string
    profileId: string
    _count: TournamententryCountAggregateOutputType | null
    _avg: TournamententryAvgAggregateOutputType | null
    _sum: TournamententrySumAggregateOutputType | null
    _min: TournamententryMinAggregateOutputType | null
    _max: TournamententryMaxAggregateOutputType | null
  }

  type GetTournamententryGroupByPayload<T extends tournamententryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamententryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamententryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
            : GetScalarType<T[P], TournamententryGroupByOutputType[P]>
        }
      >
    >


  export type tournamententrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamententry"]>

  export type tournamententrySelectScalar = {
    id?: boolean
    score?: boolean
    wagered?: boolean
    won?: boolean
    joinedAt?: boolean
    userId?: boolean
    tournamentId?: boolean
    profileId?: boolean
  }

  export type tournamententryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "score" | "wagered" | "won" | "joinedAt" | "userId" | "tournamentId" | "profileId", ExtArgs["result"]["tournamententry"]>
  export type tournamententryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type tournamententryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type tournamententryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | profileDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $tournamententryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournamententry"
    objects: {
      profile: Prisma.$profilePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      score: number
      wagered: Prisma.Decimal
      won: Prisma.Decimal
      joinedAt: Date
      userId: string
      tournamentId: string
      profileId: string
    }, ExtArgs["result"]["tournamententry"]>
    composites: {}
  }

  type tournamententryGetPayload<S extends boolean | null | undefined | tournamententryDefaultArgs> = $Result.GetResult<Prisma.$tournamententryPayload, S>

  type tournamententryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamententryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamententryCountAggregateInputType | true
    }

  export interface tournamententryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournamententry'], meta: { name: 'tournamententry' } }
    /**
     * Find zero or one Tournamententry that matches the filter.
     * @param {tournamententryFindUniqueArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamententryFindUniqueArgs>(args: SelectSubset<T, tournamententryFindUniqueArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournamententry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamententryFindUniqueOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamententryFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamententryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamententry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindFirstArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamententryFindFirstArgs>(args?: SelectSubset<T, tournamententryFindFirstArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamententry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindFirstOrThrowArgs} args - Arguments to find a Tournamententry
     * @example
     * // Get one Tournamententry
     * const tournamententry = await prisma.tournamententry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamententryFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamententryFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournamententries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany()
     * 
     * // Get first 10 Tournamententries
     * const tournamententries = await prisma.tournamententry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamententryFindManyArgs>(args?: SelectSubset<T, tournamententryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournamententry.
     * @param {tournamententryCreateArgs} args - Arguments to create a Tournamententry.
     * @example
     * // Create one Tournamententry
     * const Tournamententry = await prisma.tournamententry.create({
     *   data: {
     *     // ... data to create a Tournamententry
     *   }
     * })
     * 
     */
    create<T extends tournamententryCreateArgs>(args: SelectSubset<T, tournamententryCreateArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournamententries.
     * @param {tournamententryCreateManyArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamententryCreateManyArgs>(args?: SelectSubset<T, tournamententryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamententries and returns the data saved in the database.
     * @param {tournamententryCreateManyAndReturnArgs} args - Arguments to create many Tournamententries.
     * @example
     * // Create many Tournamententries
     * const tournamententry = await prisma.tournamententry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamententries and only return the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamententryCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamententryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournamententry.
     * @param {tournamententryDeleteArgs} args - Arguments to delete one Tournamententry.
     * @example
     * // Delete one Tournamententry
     * const Tournamententry = await prisma.tournamententry.delete({
     *   where: {
     *     // ... filter to delete one Tournamententry
     *   }
     * })
     * 
     */
    delete<T extends tournamententryDeleteArgs>(args: SelectSubset<T, tournamententryDeleteArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournamententry.
     * @param {tournamententryUpdateArgs} args - Arguments to update one Tournamententry.
     * @example
     * // Update one Tournamententry
     * const tournamententry = await prisma.tournamententry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamententryUpdateArgs>(args: SelectSubset<T, tournamententryUpdateArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournamententries.
     * @param {tournamententryDeleteManyArgs} args - Arguments to filter Tournamententries to delete.
     * @example
     * // Delete a few Tournamententries
     * const { count } = await prisma.tournamententry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamententryDeleteManyArgs>(args?: SelectSubset<T, tournamententryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamententries
     * const tournamententry = await prisma.tournamententry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamententryUpdateManyArgs>(args: SelectSubset<T, tournamententryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamententries and returns the data updated in the database.
     * @param {tournamententryUpdateManyAndReturnArgs} args - Arguments to update many Tournamententries.
     * @example
     * // Update many Tournamententries
     * const tournamententry = await prisma.tournamententry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournamententries and only return the `id`
     * const tournamententryWithIdOnly = await prisma.tournamententry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamententryUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamententryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournamententry.
     * @param {tournamententryUpsertArgs} args - Arguments to update or create a Tournamententry.
     * @example
     * // Update or create a Tournamententry
     * const tournamententry = await prisma.tournamententry.upsert({
     *   create: {
     *     // ... data to create a Tournamententry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamententry we want to update
     *   }
     * })
     */
    upsert<T extends tournamententryUpsertArgs>(args: SelectSubset<T, tournamententryUpsertArgs<ExtArgs>>): Prisma__tournamententryClient<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournamententries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryCountArgs} args - Arguments to filter Tournamententries to count.
     * @example
     * // Count the number of Tournamententries
     * const count = await prisma.tournamententry.count({
     *   where: {
     *     // ... the filter for the Tournamententries we want to count
     *   }
     * })
    **/
    count<T extends tournamententryCountArgs>(
      args?: Subset<T, tournamententryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamententryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamententryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamententryAggregateArgs>(args: Subset<T, TournamententryAggregateArgs>): Prisma.PrismaPromise<GetTournamententryAggregateType<T>>

    /**
     * Group by Tournamententry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamententryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamententryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamententryGroupByArgs['orderBy'] }
        : { orderBy?: tournamententryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamententryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamententryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournamententry model
   */
  readonly fields: tournamententryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournamententry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamententryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends tournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentDefaultArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournamententry model
   */
  interface tournamententryFieldRefs {
    readonly id: FieldRef<"tournamententry", 'String'>
    readonly score: FieldRef<"tournamententry", 'Int'>
    readonly wagered: FieldRef<"tournamententry", 'Decimal'>
    readonly won: FieldRef<"tournamententry", 'Decimal'>
    readonly joinedAt: FieldRef<"tournamententry", 'DateTime'>
    readonly userId: FieldRef<"tournamententry", 'String'>
    readonly tournamentId: FieldRef<"tournamententry", 'String'>
    readonly profileId: FieldRef<"tournamententry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tournamententry findUnique
   */
  export type tournamententryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry findUniqueOrThrow
   */
  export type tournamententryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry findFirst
   */
  export type tournamententryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry findFirstOrThrow
   */
  export type tournamententryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententry to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamententries.
     */
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry findMany
   */
  export type tournamententryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter, which tournamententries to fetch.
     */
    where?: tournamententryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamententries to fetch.
     */
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournamententries.
     */
    cursor?: tournamententryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamententries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamententries.
     */
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * tournamententry create
   */
  export type tournamententryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The data needed to create a tournamententry.
     */
    data: XOR<tournamententryCreateInput, tournamententryUncheckedCreateInput>
  }

  /**
   * tournamententry createMany
   */
  export type tournamententryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournamententries.
     */
    data: tournamententryCreateManyInput | tournamententryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournamententry createManyAndReturn
   */
  export type tournamententryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * The data used to create many tournamententries.
     */
    data: tournamententryCreateManyInput | tournamententryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamententry update
   */
  export type tournamententryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The data needed to update a tournamententry.
     */
    data: XOR<tournamententryUpdateInput, tournamententryUncheckedUpdateInput>
    /**
     * Choose, which tournamententry to update.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry updateMany
   */
  export type tournamententryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournamententries.
     */
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyInput>
    /**
     * Filter which tournamententries to update
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to update.
     */
    limit?: number
  }

  /**
   * tournamententry updateManyAndReturn
   */
  export type tournamententryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * The data used to update tournamententries.
     */
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyInput>
    /**
     * Filter which tournamententries to update
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamententry upsert
   */
  export type tournamententryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * The filter to search for the tournamententry to update in case it exists.
     */
    where: tournamententryWhereUniqueInput
    /**
     * In case the tournamententry found by the `where` argument doesn't exist, create a new tournamententry with this data.
     */
    create: XOR<tournamententryCreateInput, tournamententryUncheckedCreateInput>
    /**
     * In case the tournamententry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamententryUpdateInput, tournamententryUncheckedUpdateInput>
  }

  /**
   * tournamententry delete
   */
  export type tournamententryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    /**
     * Filter which tournamententry to delete.
     */
    where: tournamententryWhereUniqueInput
  }

  /**
   * tournamententry deleteMany
   */
  export type tournamententryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamententries to delete
     */
    where?: tournamententryWhereInput
    /**
     * Limit how many tournamententries to delete.
     */
    limit?: number
  }

  /**
   * tournamententry without action
   */
  export type tournamententryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
  }


  /**
   * Model tournamentgame
   */

  export type AggregateTournamentgame = {
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  export type TournamentgameAvgAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameSumAggregateOutputType = {
    multiplier: number | null
  }

  export type TournamentgameMinAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameMaxAggregateOutputType = {
    id: string | null
    multiplier: number | null
    tournamentId: string | null
    gameId: string | null
  }

  export type TournamentgameCountAggregateOutputType = {
    id: number
    multiplier: number
    tournamentId: number
    gameId: number
    _all: number
  }


  export type TournamentgameAvgAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameSumAggregateInputType = {
    multiplier?: true
  }

  export type TournamentgameMinAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameMaxAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
  }

  export type TournamentgameCountAggregateInputType = {
    id?: true
    multiplier?: true
    tournamentId?: true
    gameId?: true
    _all?: true
  }

  export type TournamentgameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamentgame to aggregate.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tournamentgames
    **/
    _count?: true | TournamentgameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentgameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentgameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentgameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentgameMaxAggregateInputType
  }

  export type GetTournamentgameAggregateType<T extends TournamentgameAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentgame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentgame[P]>
      : GetScalarType<T[P], AggregateTournamentgame[P]>
  }




  export type tournamentgameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tournamentgameWhereInput
    orderBy?: tournamentgameOrderByWithAggregationInput | tournamentgameOrderByWithAggregationInput[]
    by: TournamentgameScalarFieldEnum[] | TournamentgameScalarFieldEnum
    having?: tournamentgameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentgameCountAggregateInputType | true
    _avg?: TournamentgameAvgAggregateInputType
    _sum?: TournamentgameSumAggregateInputType
    _min?: TournamentgameMinAggregateInputType
    _max?: TournamentgameMaxAggregateInputType
  }

  export type TournamentgameGroupByOutputType = {
    id: string
    multiplier: number
    tournamentId: string
    gameId: string
    _count: TournamentgameCountAggregateOutputType | null
    _avg: TournamentgameAvgAggregateOutputType | null
    _sum: TournamentgameSumAggregateOutputType | null
    _min: TournamentgameMinAggregateOutputType | null
    _max: TournamentgameMaxAggregateOutputType | null
  }

  type GetTournamentgameGroupByPayload<T extends tournamentgameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentgameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentgameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentgameGroupByOutputType[P]>
        }
      >
    >


  export type tournamentgameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentgame"]>

  export type tournamentgameSelectScalar = {
    id?: boolean
    multiplier?: boolean
    tournamentId?: boolean
    gameId?: boolean
  }

  export type tournamentgameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "multiplier" | "tournamentId" | "gameId", ExtArgs["result"]["tournamentgame"]>
  export type tournamentgameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }
  export type tournamentgameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }
  export type tournamentgameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    operatorgame?: boolean | operatorgameDefaultArgs<ExtArgs>
    tournament?: boolean | tournamentDefaultArgs<ExtArgs>
  }

  export type $tournamentgamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tournamentgame"
    objects: {
      operatorgame: Prisma.$operatorgamePayload<ExtArgs>
      tournament: Prisma.$tournamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      multiplier: number
      tournamentId: string
      gameId: string
    }, ExtArgs["result"]["tournamentgame"]>
    composites: {}
  }

  type tournamentgameGetPayload<S extends boolean | null | undefined | tournamentgameDefaultArgs> = $Result.GetResult<Prisma.$tournamentgamePayload, S>

  type tournamentgameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tournamentgameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentgameCountAggregateInputType | true
    }

  export interface tournamentgameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tournamentgame'], meta: { name: 'tournamentgame' } }
    /**
     * Find zero or one Tournamentgame that matches the filter.
     * @param {tournamentgameFindUniqueArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tournamentgameFindUniqueArgs>(args: SelectSubset<T, tournamentgameFindUniqueArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournamentgame that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tournamentgameFindUniqueOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tournamentgameFindUniqueOrThrowArgs>(args: SelectSubset<T, tournamentgameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamentgame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindFirstArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tournamentgameFindFirstArgs>(args?: SelectSubset<T, tournamentgameFindFirstArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournamentgame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindFirstOrThrowArgs} args - Arguments to find a Tournamentgame
     * @example
     * // Get one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tournamentgameFindFirstOrThrowArgs>(args?: SelectSubset<T, tournamentgameFindFirstOrThrowArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournamentgames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany()
     * 
     * // Get first 10 Tournamentgames
     * const tournamentgames = await prisma.tournamentgame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tournamentgameFindManyArgs>(args?: SelectSubset<T, tournamentgameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournamentgame.
     * @param {tournamentgameCreateArgs} args - Arguments to create a Tournamentgame.
     * @example
     * // Create one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.create({
     *   data: {
     *     // ... data to create a Tournamentgame
     *   }
     * })
     * 
     */
    create<T extends tournamentgameCreateArgs>(args: SelectSubset<T, tournamentgameCreateArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournamentgames.
     * @param {tournamentgameCreateManyArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tournamentgameCreateManyArgs>(args?: SelectSubset<T, tournamentgameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournamentgames and returns the data saved in the database.
     * @param {tournamentgameCreateManyAndReturnArgs} args - Arguments to create many Tournamentgames.
     * @example
     * // Create many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournamentgames and only return the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tournamentgameCreateManyAndReturnArgs>(args?: SelectSubset<T, tournamentgameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournamentgame.
     * @param {tournamentgameDeleteArgs} args - Arguments to delete one Tournamentgame.
     * @example
     * // Delete one Tournamentgame
     * const Tournamentgame = await prisma.tournamentgame.delete({
     *   where: {
     *     // ... filter to delete one Tournamentgame
     *   }
     * })
     * 
     */
    delete<T extends tournamentgameDeleteArgs>(args: SelectSubset<T, tournamentgameDeleteArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournamentgame.
     * @param {tournamentgameUpdateArgs} args - Arguments to update one Tournamentgame.
     * @example
     * // Update one Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tournamentgameUpdateArgs>(args: SelectSubset<T, tournamentgameUpdateArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournamentgames.
     * @param {tournamentgameDeleteManyArgs} args - Arguments to filter Tournamentgames to delete.
     * @example
     * // Delete a few Tournamentgames
     * const { count } = await prisma.tournamentgame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tournamentgameDeleteManyArgs>(args?: SelectSubset<T, tournamentgameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tournamentgameUpdateManyArgs>(args: SelectSubset<T, tournamentgameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournamentgames and returns the data updated in the database.
     * @param {tournamentgameUpdateManyAndReturnArgs} args - Arguments to update many Tournamentgames.
     * @example
     * // Update many Tournamentgames
     * const tournamentgame = await prisma.tournamentgame.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournamentgames and only return the `id`
     * const tournamentgameWithIdOnly = await prisma.tournamentgame.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tournamentgameUpdateManyAndReturnArgs>(args: SelectSubset<T, tournamentgameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournamentgame.
     * @param {tournamentgameUpsertArgs} args - Arguments to update or create a Tournamentgame.
     * @example
     * // Update or create a Tournamentgame
     * const tournamentgame = await prisma.tournamentgame.upsert({
     *   create: {
     *     // ... data to create a Tournamentgame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournamentgame we want to update
     *   }
     * })
     */
    upsert<T extends tournamentgameUpsertArgs>(args: SelectSubset<T, tournamentgameUpsertArgs<ExtArgs>>): Prisma__tournamentgameClient<$Result.GetResult<Prisma.$tournamentgamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournamentgames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameCountArgs} args - Arguments to filter Tournamentgames to count.
     * @example
     * // Count the number of Tournamentgames
     * const count = await prisma.tournamentgame.count({
     *   where: {
     *     // ... the filter for the Tournamentgames we want to count
     *   }
     * })
    **/
    count<T extends tournamentgameCountArgs>(
      args?: Subset<T, tournamentgameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentgameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentgameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentgameAggregateArgs>(args: Subset<T, TournamentgameAggregateArgs>): Prisma.PrismaPromise<GetTournamentgameAggregateType<T>>

    /**
     * Group by Tournamentgame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tournamentgameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tournamentgameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tournamentgameGroupByArgs['orderBy'] }
        : { orderBy?: tournamentgameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tournamentgameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentgameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tournamentgame model
   */
  readonly fields: tournamentgameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tournamentgame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tournamentgameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    operatorgame<T extends operatorgameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, operatorgameDefaultArgs<ExtArgs>>): Prisma__operatorgameClient<$Result.GetResult<Prisma.$operatorgamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tournament<T extends tournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tournamentDefaultArgs<ExtArgs>>): Prisma__tournamentClient<$Result.GetResult<Prisma.$tournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tournamentgame model
   */
  interface tournamentgameFieldRefs {
    readonly id: FieldRef<"tournamentgame", 'String'>
    readonly multiplier: FieldRef<"tournamentgame", 'Float'>
    readonly tournamentId: FieldRef<"tournamentgame", 'String'>
    readonly gameId: FieldRef<"tournamentgame", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tournamentgame findUnique
   */
  export type tournamentgameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame findUniqueOrThrow
   */
  export type tournamentgameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame findFirst
   */
  export type tournamentgameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame findFirstOrThrow
   */
  export type tournamentgameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgame to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tournamentgames.
     */
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame findMany
   */
  export type tournamentgameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter, which tournamentgames to fetch.
     */
    where?: tournamentgameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tournamentgames to fetch.
     */
    orderBy?: tournamentgameOrderByWithRelationInput | tournamentgameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tournamentgames.
     */
    cursor?: tournamentgameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tournamentgames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tournamentgames.
     */
    skip?: number
    distinct?: TournamentgameScalarFieldEnum | TournamentgameScalarFieldEnum[]
  }

  /**
   * tournamentgame create
   */
  export type tournamentgameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to create a tournamentgame.
     */
    data: XOR<tournamentgameCreateInput, tournamentgameUncheckedCreateInput>
  }

  /**
   * tournamentgame createMany
   */
  export type tournamentgameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tournamentgames.
     */
    data: tournamentgameCreateManyInput | tournamentgameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tournamentgame createManyAndReturn
   */
  export type tournamentgameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * The data used to create many tournamentgames.
     */
    data: tournamentgameCreateManyInput | tournamentgameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamentgame update
   */
  export type tournamentgameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The data needed to update a tournamentgame.
     */
    data: XOR<tournamentgameUpdateInput, tournamentgameUncheckedUpdateInput>
    /**
     * Choose, which tournamentgame to update.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame updateMany
   */
  export type tournamentgameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tournamentgames.
     */
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyInput>
    /**
     * Filter which tournamentgames to update
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to update.
     */
    limit?: number
  }

  /**
   * tournamentgame updateManyAndReturn
   */
  export type tournamentgameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * The data used to update tournamentgames.
     */
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyInput>
    /**
     * Filter which tournamentgames to update
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tournamentgame upsert
   */
  export type tournamentgameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * The filter to search for the tournamentgame to update in case it exists.
     */
    where: tournamentgameWhereUniqueInput
    /**
     * In case the tournamentgame found by the `where` argument doesn't exist, create a new tournamentgame with this data.
     */
    create: XOR<tournamentgameCreateInput, tournamentgameUncheckedCreateInput>
    /**
     * In case the tournamentgame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tournamentgameUpdateInput, tournamentgameUncheckedUpdateInput>
  }

  /**
   * tournamentgame delete
   */
  export type tournamentgameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
    /**
     * Filter which tournamentgame to delete.
     */
    where: tournamentgameWhereUniqueInput
  }

  /**
   * tournamentgame deleteMany
   */
  export type tournamentgameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tournamentgames to delete
     */
    where?: tournamentgameWhereInput
    /**
     * Limit how many tournamentgames to delete.
     */
    limit?: number
  }

  /**
   * tournamentgame without action
   */
  export type tournamentgameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamentgame
     */
    select?: tournamentgameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamentgame
     */
    omit?: tournamentgameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamentgameInclude<ExtArgs> | null
  }


  /**
   * Model transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: Decimal | null
    reference: string | null
    status: $Enums.TransactionStatus | null
    isRealMoney: boolean | null
    paymentMethod: string | null
    createdAt: Date | null
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    reference: number
    status: number
    metadata: number
    isRealMoney: number
    paymentMethod: number
    paymentDetails: number
    createdAt: number
    processedAt: number
    gameSessionId: number
    profileId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    isRealMoney?: true
    paymentMethod?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    reference?: true
    status?: true
    metadata?: true
    isRealMoney?: true
    paymentMethod?: true
    paymentDetails?: true
    createdAt?: true
    processedAt?: true
    gameSessionId?: true
    profileId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaction to aggregate.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type transactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionWhereInput
    orderBy?: transactionOrderByWithAggregationInput | transactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: transactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal
    reference: string | null
    status: $Enums.TransactionStatus
    metadata: JsonValue | null
    isRealMoney: boolean
    paymentMethod: string | null
    paymentDetails: JsonValue | null
    createdAt: Date
    processedAt: Date | null
    gameSessionId: string | null
    profileId: string
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends transactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type transactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type transactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    metadata?: boolean
    isRealMoney?: boolean
    paymentMethod?: boolean
    paymentDetails?: boolean
    createdAt?: boolean
    processedAt?: boolean
    gameSessionId?: boolean
    profileId?: boolean
  }

  export type transactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "reference" | "status" | "metadata" | "isRealMoney" | "paymentMethod" | "paymentDetails" | "createdAt" | "processedAt" | "gameSessionId" | "profileId", ExtArgs["result"]["transaction"]>
  export type transactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type transactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type transactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamesession?: boolean | transaction$gamesessionArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $transactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaction"
    objects: {
      gamesession: Prisma.$gamesessionPayload<ExtArgs> | null
      profile: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      amount: Prisma.Decimal
      reference: string | null
      status: $Enums.TransactionStatus
      metadata: Prisma.JsonValue | null
      isRealMoney: boolean
      paymentMethod: string | null
      paymentDetails: Prisma.JsonValue | null
      createdAt: Date
      processedAt: Date | null
      gameSessionId: string | null
      profileId: string
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type transactionGetPayload<S extends boolean | null | undefined | transactionDefaultArgs> = $Result.GetResult<Prisma.$transactionPayload, S>

  type transactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface transactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaction'], meta: { name: 'transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {transactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionFindUniqueArgs>(args: SelectSubset<T, transactionFindUniqueArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionFindFirstArgs>(args?: SelectSubset<T, transactionFindFirstArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionFindManyArgs>(args?: SelectSubset<T, transactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {transactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends transactionCreateArgs>(args: SelectSubset<T, transactionCreateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionCreateManyArgs>(args?: SelectSubset<T, transactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {transactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends transactionDeleteArgs>(args: SelectSubset<T, transactionDeleteArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {transactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionUpdateArgs>(args: SelectSubset<T, transactionUpdateArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionDeleteManyArgs>(args?: SelectSubset<T, transactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionUpdateManyArgs>(args: SelectSubset<T, transactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {transactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends transactionUpsertArgs>(args: SelectSubset<T, transactionUpsertArgs<ExtArgs>>): Prisma__transactionClient<$Result.GetResult<Prisma.$transactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionCountArgs>(
      args?: Subset<T, transactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionGroupByArgs['orderBy'] }
        : { orderBy?: transactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaction model
   */
  readonly fields: transactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamesession<T extends transaction$gamesessionArgs<ExtArgs> = {}>(args?: Subset<T, transaction$gamesessionArgs<ExtArgs>>): Prisma__gamesessionClient<$Result.GetResult<Prisma.$gamesessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaction model
   */
  interface transactionFieldRefs {
    readonly id: FieldRef<"transaction", 'String'>
    readonly type: FieldRef<"transaction", 'TransactionType'>
    readonly amount: FieldRef<"transaction", 'Decimal'>
    readonly reference: FieldRef<"transaction", 'String'>
    readonly status: FieldRef<"transaction", 'TransactionStatus'>
    readonly metadata: FieldRef<"transaction", 'Json'>
    readonly isRealMoney: FieldRef<"transaction", 'Boolean'>
    readonly paymentMethod: FieldRef<"transaction", 'String'>
    readonly paymentDetails: FieldRef<"transaction", 'Json'>
    readonly createdAt: FieldRef<"transaction", 'DateTime'>
    readonly processedAt: FieldRef<"transaction", 'DateTime'>
    readonly gameSessionId: FieldRef<"transaction", 'String'>
    readonly profileId: FieldRef<"transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transaction findUnique
   */
  export type transactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findUniqueOrThrow
   */
  export type transactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction findFirst
   */
  export type transactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findFirstOrThrow
   */
  export type transactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transaction to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction findMany
   */
  export type transactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionOrderByWithRelationInput | transactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * transaction create
   */
  export type transactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to create a transaction.
     */
    data: XOR<transactionCreateInput, transactionUncheckedCreateInput>
  }

  /**
   * transaction createMany
   */
  export type transactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaction createManyAndReturn
   */
  export type transactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionCreateManyInput | transactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction update
   */
  export type transactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The data needed to update a transaction.
     */
    data: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
    /**
     * Choose, which transaction to update.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction updateMany
   */
  export type transactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transaction updateManyAndReturn
   */
  export type transactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transaction upsert
   */
  export type transactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * The filter to search for the transaction to update in case it exists.
     */
    where: transactionWhereUniqueInput
    /**
     * In case the transaction found by the `where` argument doesn't exist, create a new transaction with this data.
     */
    create: XOR<transactionCreateInput, transactionUncheckedCreateInput>
    /**
     * In case the transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionUpdateInput, transactionUncheckedUpdateInput>
  }

  /**
   * transaction delete
   */
  export type transactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
    /**
     * Filter which transaction to delete.
     */
    where: transactionWhereUniqueInput
  }

  /**
   * transaction deleteMany
   */
  export type transactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transaction.gamesession
   */
  export type transaction$gamesessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamesession
     */
    select?: gamesessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the gamesession
     */
    omit?: gamesessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: gamesessionInclude<ExtArgs> | null
    where?: gamesessionWhereInput
  }

  /**
   * transaction without action
   */
  export type transactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaction
     */
    select?: transactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transaction
     */
    omit?: transactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalXp: number | null
    balance: Decimal | null
    phpId: number | null
  }

  export type UserSumAggregateOutputType = {
    totalXp: number | null
    balance: Decimal | null
    phpId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    avatar: string | null
    totalXp: number | null
    balance: Decimal | null
    lastLogin: Date | null
    isVerified: boolean | null
    verificationToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    active: boolean | null
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    avatar: string | null
    totalXp: number | null
    balance: Decimal | null
    lastLogin: Date | null
    isVerified: boolean | null
    verificationToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    active: boolean | null
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    avatar: number
    totalXp: number
    balance: number
    lastLogin: number
    isVerified: number
    verificationToken: number
    createdAt: number
    updatedAt: number
    active: number
    activeProfileId: number
    gender: number
    status: number
    cashtag: number
    phpId: number
    accessToken: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserSumAggregateInputType = {
    totalXp?: true
    balance?: true
    phpId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    avatar?: true
    totalXp?: true
    balance?: true
    lastLogin?: true
    isVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    avatar?: true
    totalXp?: true
    balance?: true
    lastLogin?: true
    isVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    avatar?: true
    totalXp?: true
    balance?: true
    lastLogin?: true
    isVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    active?: true
    activeProfileId?: true
    gender?: true
    status?: true
    cashtag?: true
    phpId?: true
    accessToken?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar: string | null
    totalXp: number
    balance: Decimal
    lastLogin: Date | null
    isVerified: boolean
    verificationToken: string | null
    createdAt: Date
    updatedAt: Date
    active: boolean
    activeProfileId: string | null
    gender: $Enums.Gender | null
    status: $Enums.UserStatus | null
    cashtag: string | null
    phpId: number | null
    accessToken: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    avatar?: boolean
    totalXp?: boolean
    balance?: boolean
    lastLogin?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
    RainBet?: boolean | user$RainBetArgs<ExtArgs>
    RainHistory?: boolean | user$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | user$RainTipArgs<ExtArgs>
    RainWinner?: boolean | user$RainWinnerArgs<ExtArgs>
    chatmessage?: boolean | user$chatmessageArgs<ExtArgs>
    friendship_friendship_friendIdTouser?: boolean | user$friendship_friendship_friendIdTouserArgs<ExtArgs>
    friendship_friendship_userIdTouser?: boolean | user$friendship_friendship_userIdTouserArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    operator?: boolean | user$operatorArgs<ExtArgs>
    profile_profile_userIdTouser?: boolean | user$profile_profile_userIdTouserArgs<ExtArgs>
    session?: boolean | user$sessionArgs<ExtArgs>
    tournamententry?: boolean | user$tournamententryArgs<ExtArgs>
    userachievement?: boolean | user$userachievementArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    avatar?: boolean
    totalXp?: boolean
    balance?: boolean
    lastLogin?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    avatar?: boolean
    totalXp?: boolean
    balance?: boolean
    lastLogin?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    avatar?: boolean
    totalXp?: boolean
    balance?: boolean
    lastLogin?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    active?: boolean
    activeProfileId?: boolean
    gender?: boolean
    status?: boolean
    cashtag?: boolean
    phpId?: boolean
    accessToken?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "avatar" | "totalXp" | "balance" | "lastLogin" | "isVerified" | "verificationToken" | "createdAt" | "updatedAt" | "active" | "activeProfileId" | "gender" | "status" | "cashtag" | "phpId" | "accessToken", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | user$RainBetArgs<ExtArgs>
    RainHistory?: boolean | user$RainHistoryArgs<ExtArgs>
    RainTip?: boolean | user$RainTipArgs<ExtArgs>
    RainWinner?: boolean | user$RainWinnerArgs<ExtArgs>
    chatmessage?: boolean | user$chatmessageArgs<ExtArgs>
    friendship_friendship_friendIdTouser?: boolean | user$friendship_friendship_friendIdTouserArgs<ExtArgs>
    friendship_friendship_userIdTouser?: boolean | user$friendship_friendship_userIdTouserArgs<ExtArgs>
    notification?: boolean | user$notificationArgs<ExtArgs>
    operator?: boolean | user$operatorArgs<ExtArgs>
    profile_profile_userIdTouser?: boolean | user$profile_profile_userIdTouserArgs<ExtArgs>
    session?: boolean | user$sessionArgs<ExtArgs>
    tournamententry?: boolean | user$tournamententryArgs<ExtArgs>
    userachievement?: boolean | user$userachievementArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>[]
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      friendship_friendship_friendIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      friendship_friendship_userIdTouser: Prisma.$friendshipPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      operator: Prisma.$operatorPayload<ExtArgs>[]
      profile_profile_userIdTouser: Prisma.$profilePayload<ExtArgs>[]
      session: Prisma.$sessionPayload<ExtArgs>[]
      tournamententry: Prisma.$tournamententryPayload<ExtArgs>[]
      userachievement: Prisma.$userachievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      passwordHash: string
      avatar: string | null
      totalXp: number
      balance: Prisma.Decimal
      lastLogin: Date | null
      isVerified: boolean
      verificationToken: string | null
      createdAt: Date
      updatedAt: Date
      active: boolean
      activeProfileId: string | null
      gender: $Enums.Gender | null
      status: $Enums.UserStatus | null
      cashtag: string | null
      phpId: number | null
      accessToken: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainBet<T extends user$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, user$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainHistory<T extends user$RainHistoryArgs<ExtArgs> = {}>(args?: Subset<T, user$RainHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainTip<T extends user$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, user$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainWinner<T extends user$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, user$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatmessage<T extends user$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, user$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendship_friendship_friendIdTouser<T extends user$friendship_friendship_friendIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$friendship_friendship_friendIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendship_friendship_userIdTouser<T extends user$friendship_friendship_userIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$friendship_friendship_userIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$friendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends user$notificationArgs<ExtArgs> = {}>(args?: Subset<T, user$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operator<T extends user$operatorArgs<ExtArgs> = {}>(args?: Subset<T, user$operatorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$operatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profile_profile_userIdTouser<T extends user$profile_profile_userIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$profile_profile_userIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    session<T extends user$sessionArgs<ExtArgs> = {}>(args?: Subset<T, user$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamententry<T extends user$tournamententryArgs<ExtArgs> = {}>(args?: Subset<T, user$tournamententryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tournamententryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userachievement<T extends user$userachievementArgs<ExtArgs> = {}>(args?: Subset<T, user$userachievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly passwordHash: FieldRef<"user", 'String'>
    readonly avatar: FieldRef<"user", 'String'>
    readonly totalXp: FieldRef<"user", 'Int'>
    readonly balance: FieldRef<"user", 'Decimal'>
    readonly lastLogin: FieldRef<"user", 'DateTime'>
    readonly isVerified: FieldRef<"user", 'Boolean'>
    readonly verificationToken: FieldRef<"user", 'String'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
    readonly active: FieldRef<"user", 'Boolean'>
    readonly activeProfileId: FieldRef<"user", 'String'>
    readonly gender: FieldRef<"user", 'Gender'>
    readonly status: FieldRef<"user", 'UserStatus'>
    readonly cashtag: FieldRef<"user", 'String'>
    readonly phpId: FieldRef<"user", 'Int'>
    readonly accessToken: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.RainBet
   */
  export type user$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * user.RainHistory
   */
  export type user$RainHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    cursor?: RainHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * user.RainTip
   */
  export type user$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * user.RainWinner
   */
  export type user$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * user.chatmessage
   */
  export type user$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * user.friendship_friendship_friendIdTouser
   */
  export type user$friendship_friendship_friendIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * user.friendship_friendship_userIdTouser
   */
  export type user$friendship_friendship_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the friendship
     */
    select?: friendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the friendship
     */
    omit?: friendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: friendshipInclude<ExtArgs> | null
    where?: friendshipWhereInput
    orderBy?: friendshipOrderByWithRelationInput | friendshipOrderByWithRelationInput[]
    cursor?: friendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * user.notification
   */
  export type user$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * user.operator
   */
  export type user$operatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the operator
     */
    select?: operatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the operator
     */
    omit?: operatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: operatorInclude<ExtArgs> | null
    where?: operatorWhereInput
    orderBy?: operatorOrderByWithRelationInput | operatorOrderByWithRelationInput[]
    cursor?: operatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperatorScalarFieldEnum | OperatorScalarFieldEnum[]
  }

  /**
   * user.profile_profile_userIdTouser
   */
  export type user$profile_profile_userIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profile
     */
    omit?: profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * user.session
   */
  export type user$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * user.tournamententry
   */
  export type user$tournamententryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tournamententry
     */
    select?: tournamententrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tournamententry
     */
    omit?: tournamententryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tournamententryInclude<ExtArgs> | null
    where?: tournamententryWhereInput
    orderBy?: tournamententryOrderByWithRelationInput | tournamententryOrderByWithRelationInput[]
    cursor?: tournamententryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamententryScalarFieldEnum | TournamententryScalarFieldEnum[]
  }

  /**
   * user.userachievement
   */
  export type user$userachievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    cursor?: userachievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model userachievement
   */

  export type AggregateUserachievement = {
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  export type UserachievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserachievementMinAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementMaxAggregateOutputType = {
    id: string | null
    progress: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    achievementId: string | null
  }

  export type UserachievementCountAggregateOutputType = {
    id: number
    progress: number
    isUnlocked: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    userId: number
    achievementId: number
    _all: number
  }


  export type UserachievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserachievementSumAggregateInputType = {
    progress?: true
  }

  export type UserachievementMinAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementMaxAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
  }

  export type UserachievementCountAggregateInputType = {
    id?: true
    progress?: true
    isUnlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    achievementId?: true
    _all?: true
  }

  export type UserachievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userachievement to aggregate.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userachievements
    **/
    _count?: true | UserachievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserachievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserachievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserachievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserachievementMaxAggregateInputType
  }

  export type GetUserachievementAggregateType<T extends UserachievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserachievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserachievement[P]>
      : GetScalarType<T[P], AggregateUserachievement[P]>
  }




  export type userachievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userachievementWhereInput
    orderBy?: userachievementOrderByWithAggregationInput | userachievementOrderByWithAggregationInput[]
    by: UserachievementScalarFieldEnum[] | UserachievementScalarFieldEnum
    having?: userachievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserachievementCountAggregateInputType | true
    _avg?: UserachievementAvgAggregateInputType
    _sum?: UserachievementSumAggregateInputType
    _min?: UserachievementMinAggregateInputType
    _max?: UserachievementMaxAggregateInputType
  }

  export type UserachievementGroupByOutputType = {
    id: string
    progress: number
    isUnlocked: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    userId: string
    achievementId: string
    _count: UserachievementCountAggregateOutputType | null
    _avg: UserachievementAvgAggregateOutputType | null
    _sum: UserachievementSumAggregateOutputType | null
    _min: UserachievementMinAggregateOutputType | null
    _max: UserachievementMaxAggregateOutputType | null
  }

  type GetUserachievementGroupByPayload<T extends userachievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserachievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserachievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserachievementGroupByOutputType[P]>
        }
      >
    >


  export type userachievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userachievement"]>

  export type userachievementSelectScalar = {
    id?: boolean
    progress?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    achievementId?: boolean
  }

  export type userachievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "progress" | "isUnlocked" | "unlockedAt" | "createdAt" | "updatedAt" | "userId" | "achievementId", ExtArgs["result"]["userachievement"]>
  export type userachievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userachievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type userachievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievement?: boolean | achievementDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userachievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userachievement"
    objects: {
      achievement: Prisma.$achievementPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      progress: number
      isUnlocked: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date
      userId: string
      achievementId: string
    }, ExtArgs["result"]["userachievement"]>
    composites: {}
  }

  type userachievementGetPayload<S extends boolean | null | undefined | userachievementDefaultArgs> = $Result.GetResult<Prisma.$userachievementPayload, S>

  type userachievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userachievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserachievementCountAggregateInputType | true
    }

  export interface userachievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userachievement'], meta: { name: 'userachievement' } }
    /**
     * Find zero or one Userachievement that matches the filter.
     * @param {userachievementFindUniqueArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userachievementFindUniqueArgs>(args: SelectSubset<T, userachievementFindUniqueArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userachievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userachievementFindUniqueOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userachievementFindUniqueOrThrowArgs>(args: SelectSubset<T, userachievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userachievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindFirstArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userachievementFindFirstArgs>(args?: SelectSubset<T, userachievementFindFirstArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userachievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindFirstOrThrowArgs} args - Arguments to find a Userachievement
     * @example
     * // Get one Userachievement
     * const userachievement = await prisma.userachievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userachievementFindFirstOrThrowArgs>(args?: SelectSubset<T, userachievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userachievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userachievements
     * const userachievements = await prisma.userachievement.findMany()
     * 
     * // Get first 10 Userachievements
     * const userachievements = await prisma.userachievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userachievementFindManyArgs>(args?: SelectSubset<T, userachievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userachievement.
     * @param {userachievementCreateArgs} args - Arguments to create a Userachievement.
     * @example
     * // Create one Userachievement
     * const Userachievement = await prisma.userachievement.create({
     *   data: {
     *     // ... data to create a Userachievement
     *   }
     * })
     * 
     */
    create<T extends userachievementCreateArgs>(args: SelectSubset<T, userachievementCreateArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userachievements.
     * @param {userachievementCreateManyArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userachievementCreateManyArgs>(args?: SelectSubset<T, userachievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userachievements and returns the data saved in the database.
     * @param {userachievementCreateManyAndReturnArgs} args - Arguments to create many Userachievements.
     * @example
     * // Create many Userachievements
     * const userachievement = await prisma.userachievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userachievements and only return the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userachievementCreateManyAndReturnArgs>(args?: SelectSubset<T, userachievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userachievement.
     * @param {userachievementDeleteArgs} args - Arguments to delete one Userachievement.
     * @example
     * // Delete one Userachievement
     * const Userachievement = await prisma.userachievement.delete({
     *   where: {
     *     // ... filter to delete one Userachievement
     *   }
     * })
     * 
     */
    delete<T extends userachievementDeleteArgs>(args: SelectSubset<T, userachievementDeleteArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userachievement.
     * @param {userachievementUpdateArgs} args - Arguments to update one Userachievement.
     * @example
     * // Update one Userachievement
     * const userachievement = await prisma.userachievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userachievementUpdateArgs>(args: SelectSubset<T, userachievementUpdateArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userachievements.
     * @param {userachievementDeleteManyArgs} args - Arguments to filter Userachievements to delete.
     * @example
     * // Delete a few Userachievements
     * const { count } = await prisma.userachievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userachievementDeleteManyArgs>(args?: SelectSubset<T, userachievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userachievements
     * const userachievement = await prisma.userachievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userachievementUpdateManyArgs>(args: SelectSubset<T, userachievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userachievements and returns the data updated in the database.
     * @param {userachievementUpdateManyAndReturnArgs} args - Arguments to update many Userachievements.
     * @example
     * // Update many Userachievements
     * const userachievement = await prisma.userachievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userachievements and only return the `id`
     * const userachievementWithIdOnly = await prisma.userachievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userachievementUpdateManyAndReturnArgs>(args: SelectSubset<T, userachievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userachievement.
     * @param {userachievementUpsertArgs} args - Arguments to update or create a Userachievement.
     * @example
     * // Update or create a Userachievement
     * const userachievement = await prisma.userachievement.upsert({
     *   create: {
     *     // ... data to create a Userachievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userachievement we want to update
     *   }
     * })
     */
    upsert<T extends userachievementUpsertArgs>(args: SelectSubset<T, userachievementUpsertArgs<ExtArgs>>): Prisma__userachievementClient<$Result.GetResult<Prisma.$userachievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userachievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementCountArgs} args - Arguments to filter Userachievements to count.
     * @example
     * // Count the number of Userachievements
     * const count = await prisma.userachievement.count({
     *   where: {
     *     // ... the filter for the Userachievements we want to count
     *   }
     * })
    **/
    count<T extends userachievementCountArgs>(
      args?: Subset<T, userachievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserachievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserachievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserachievementAggregateArgs>(args: Subset<T, UserachievementAggregateArgs>): Prisma.PrismaPromise<GetUserachievementAggregateType<T>>

    /**
     * Group by Userachievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userachievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userachievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userachievementGroupByArgs['orderBy'] }
        : { orderBy?: userachievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userachievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserachievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userachievement model
   */
  readonly fields: userachievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userachievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userachievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievement<T extends achievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, achievementDefaultArgs<ExtArgs>>): Prisma__achievementClient<$Result.GetResult<Prisma.$achievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userachievement model
   */
  interface userachievementFieldRefs {
    readonly id: FieldRef<"userachievement", 'String'>
    readonly progress: FieldRef<"userachievement", 'Int'>
    readonly isUnlocked: FieldRef<"userachievement", 'Boolean'>
    readonly unlockedAt: FieldRef<"userachievement", 'DateTime'>
    readonly createdAt: FieldRef<"userachievement", 'DateTime'>
    readonly updatedAt: FieldRef<"userachievement", 'DateTime'>
    readonly userId: FieldRef<"userachievement", 'String'>
    readonly achievementId: FieldRef<"userachievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * userachievement findUnique
   */
  export type userachievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement findUniqueOrThrow
   */
  export type userachievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement findFirst
   */
  export type userachievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement findFirstOrThrow
   */
  export type userachievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievement to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userachievements.
     */
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement findMany
   */
  export type userachievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter, which userachievements to fetch.
     */
    where?: userachievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userachievements to fetch.
     */
    orderBy?: userachievementOrderByWithRelationInput | userachievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userachievements.
     */
    cursor?: userachievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userachievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userachievements.
     */
    skip?: number
    distinct?: UserachievementScalarFieldEnum | UserachievementScalarFieldEnum[]
  }

  /**
   * userachievement create
   */
  export type userachievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The data needed to create a userachievement.
     */
    data: XOR<userachievementCreateInput, userachievementUncheckedCreateInput>
  }

  /**
   * userachievement createMany
   */
  export type userachievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userachievements.
     */
    data: userachievementCreateManyInput | userachievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userachievement createManyAndReturn
   */
  export type userachievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * The data used to create many userachievements.
     */
    data: userachievementCreateManyInput | userachievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userachievement update
   */
  export type userachievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The data needed to update a userachievement.
     */
    data: XOR<userachievementUpdateInput, userachievementUncheckedUpdateInput>
    /**
     * Choose, which userachievement to update.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement updateMany
   */
  export type userachievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userachievements.
     */
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyInput>
    /**
     * Filter which userachievements to update
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to update.
     */
    limit?: number
  }

  /**
   * userachievement updateManyAndReturn
   */
  export type userachievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * The data used to update userachievements.
     */
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyInput>
    /**
     * Filter which userachievements to update
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userachievement upsert
   */
  export type userachievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * The filter to search for the userachievement to update in case it exists.
     */
    where: userachievementWhereUniqueInput
    /**
     * In case the userachievement found by the `where` argument doesn't exist, create a new userachievement with this data.
     */
    create: XOR<userachievementCreateInput, userachievementUncheckedCreateInput>
    /**
     * In case the userachievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userachievementUpdateInput, userachievementUncheckedUpdateInput>
  }

  /**
   * userachievement delete
   */
  export type userachievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
    /**
     * Filter which userachievement to delete.
     */
    where: userachievementWhereUniqueInput
  }

  /**
   * userachievement deleteMany
   */
  export type userachievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userachievements to delete
     */
    where?: userachievementWhereInput
    /**
     * Limit how many userachievements to delete.
     */
    limit?: number
  }

  /**
   * userachievement without action
   */
  export type userachievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userachievement
     */
    select?: userachievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userachievement
     */
    omit?: userachievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userachievementInclude<ExtArgs> | null
  }


  /**
   * Model RainBet
   */

  export type AggregateRainBet = {
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  export type RainBetAvgAggregateOutputType = {
    betAmount: Decimal | null
    odds: Decimal | null
  }

  export type RainBetSumAggregateOutputType = {
    betAmount: Decimal | null
    odds: Decimal | null
  }

  export type RainBetMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: Decimal | null
    odds: Decimal | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    betAmount: Decimal | null
    odds: Decimal | null
    outcome: string | null
    settledAt: Date | null
  }

  export type RainBetCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    betAmount: number
    odds: number
    outcome: number
    settledAt: number
    _all: number
  }


  export type RainBetAvgAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetSumAggregateInputType = {
    betAmount?: true
    odds?: true
  }

  export type RainBetMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
  }

  export type RainBetCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    betAmount?: true
    odds?: true
    outcome?: true
    settledAt?: true
    _all?: true
  }

  export type RainBetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBet to aggregate.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainBets
    **/
    _count?: true | RainBetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainBetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainBetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainBetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainBetMaxAggregateInputType
  }

  export type GetRainBetAggregateType<T extends RainBetAggregateArgs> = {
        [P in keyof T & keyof AggregateRainBet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainBet[P]>
      : GetScalarType<T[P], AggregateRainBet[P]>
  }




  export type RainBetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithAggregationInput | RainBetOrderByWithAggregationInput[]
    by: RainBetScalarFieldEnum[] | RainBetScalarFieldEnum
    having?: RainBetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainBetCountAggregateInputType | true
    _avg?: RainBetAvgAggregateInputType
    _sum?: RainBetSumAggregateInputType
    _min?: RainBetMinAggregateInputType
    _max?: RainBetMaxAggregateInputType
  }

  export type RainBetGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    betAmount: Decimal
    odds: Decimal
    outcome: string | null
    settledAt: Date | null
    _count: RainBetCountAggregateOutputType | null
    _avg: RainBetAvgAggregateOutputType | null
    _sum: RainBetSumAggregateOutputType | null
    _min: RainBetMinAggregateOutputType | null
    _max: RainBetMaxAggregateOutputType | null
  }

  type GetRainBetGroupByPayload<T extends RainBetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainBetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainBetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainBetGroupByOutputType[P]>
            : GetScalarType<T[P], RainBetGroupByOutputType[P]>
        }
      >
    >


  export type RainBetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainBet"]>

  export type RainBetSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    betAmount?: boolean
    odds?: boolean
    outcome?: boolean
    settledAt?: boolean
  }

  export type RainBetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "betAmount" | "odds" | "outcome" | "settledAt", ExtArgs["result"]["rainBet"]>
  export type RainBetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainBetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainBetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $RainBetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainBet"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      betAmount: Prisma.Decimal
      odds: Prisma.Decimal
      outcome: string | null
      settledAt: Date | null
    }, ExtArgs["result"]["rainBet"]>
    composites: {}
  }

  type RainBetGetPayload<S extends boolean | null | undefined | RainBetDefaultArgs> = $Result.GetResult<Prisma.$RainBetPayload, S>

  type RainBetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainBetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainBetCountAggregateInputType | true
    }

  export interface RainBetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainBet'], meta: { name: 'RainBet' } }
    /**
     * Find zero or one RainBet that matches the filter.
     * @param {RainBetFindUniqueArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainBetFindUniqueArgs>(args: SelectSubset<T, RainBetFindUniqueArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainBet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainBetFindUniqueOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainBetFindUniqueOrThrowArgs>(args: SelectSubset<T, RainBetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainBet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainBetFindFirstArgs>(args?: SelectSubset<T, RainBetFindFirstArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainBet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindFirstOrThrowArgs} args - Arguments to find a RainBet
     * @example
     * // Get one RainBet
     * const rainBet = await prisma.rainBet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainBetFindFirstOrThrowArgs>(args?: SelectSubset<T, RainBetFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainBets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainBets
     * const rainBets = await prisma.rainBet.findMany()
     * 
     * // Get first 10 RainBets
     * const rainBets = await prisma.rainBet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainBetFindManyArgs>(args?: SelectSubset<T, RainBetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainBet.
     * @param {RainBetCreateArgs} args - Arguments to create a RainBet.
     * @example
     * // Create one RainBet
     * const RainBet = await prisma.rainBet.create({
     *   data: {
     *     // ... data to create a RainBet
     *   }
     * })
     * 
     */
    create<T extends RainBetCreateArgs>(args: SelectSubset<T, RainBetCreateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainBets.
     * @param {RainBetCreateManyArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainBetCreateManyArgs>(args?: SelectSubset<T, RainBetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainBets and returns the data saved in the database.
     * @param {RainBetCreateManyAndReturnArgs} args - Arguments to create many RainBets.
     * @example
     * // Create many RainBets
     * const rainBet = await prisma.rainBet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainBets and only return the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainBetCreateManyAndReturnArgs>(args?: SelectSubset<T, RainBetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainBet.
     * @param {RainBetDeleteArgs} args - Arguments to delete one RainBet.
     * @example
     * // Delete one RainBet
     * const RainBet = await prisma.rainBet.delete({
     *   where: {
     *     // ... filter to delete one RainBet
     *   }
     * })
     * 
     */
    delete<T extends RainBetDeleteArgs>(args: SelectSubset<T, RainBetDeleteArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainBet.
     * @param {RainBetUpdateArgs} args - Arguments to update one RainBet.
     * @example
     * // Update one RainBet
     * const rainBet = await prisma.rainBet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainBetUpdateArgs>(args: SelectSubset<T, RainBetUpdateArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainBets.
     * @param {RainBetDeleteManyArgs} args - Arguments to filter RainBets to delete.
     * @example
     * // Delete a few RainBets
     * const { count } = await prisma.rainBet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainBetDeleteManyArgs>(args?: SelectSubset<T, RainBetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainBets
     * const rainBet = await prisma.rainBet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainBetUpdateManyArgs>(args: SelectSubset<T, RainBetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainBets and returns the data updated in the database.
     * @param {RainBetUpdateManyAndReturnArgs} args - Arguments to update many RainBets.
     * @example
     * // Update many RainBets
     * const rainBet = await prisma.rainBet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainBets and only return the `id`
     * const rainBetWithIdOnly = await prisma.rainBet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainBetUpdateManyAndReturnArgs>(args: SelectSubset<T, RainBetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainBet.
     * @param {RainBetUpsertArgs} args - Arguments to update or create a RainBet.
     * @example
     * // Update or create a RainBet
     * const rainBet = await prisma.rainBet.upsert({
     *   create: {
     *     // ... data to create a RainBet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainBet we want to update
     *   }
     * })
     */
    upsert<T extends RainBetUpsertArgs>(args: SelectSubset<T, RainBetUpsertArgs<ExtArgs>>): Prisma__RainBetClient<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainBets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetCountArgs} args - Arguments to filter RainBets to count.
     * @example
     * // Count the number of RainBets
     * const count = await prisma.rainBet.count({
     *   where: {
     *     // ... the filter for the RainBets we want to count
     *   }
     * })
    **/
    count<T extends RainBetCountArgs>(
      args?: Subset<T, RainBetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainBetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainBetAggregateArgs>(args: Subset<T, RainBetAggregateArgs>): Prisma.PrismaPromise<GetRainBetAggregateType<T>>

    /**
     * Group by RainBet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainBetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainBetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainBetGroupByArgs['orderBy'] }
        : { orderBy?: RainBetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainBetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainBetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainBet model
   */
  readonly fields: RainBetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainBet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainBetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainBet model
   */
  interface RainBetFieldRefs {
    readonly id: FieldRef<"RainBet", 'String'>
    readonly rainHistoryId: FieldRef<"RainBet", 'String'>
    readonly userId: FieldRef<"RainBet", 'String'>
    readonly betAmount: FieldRef<"RainBet", 'Decimal'>
    readonly odds: FieldRef<"RainBet", 'Decimal'>
    readonly outcome: FieldRef<"RainBet", 'String'>
    readonly settledAt: FieldRef<"RainBet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainBet findUnique
   */
  export type RainBetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findUniqueOrThrow
   */
  export type RainBetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet findFirst
   */
  export type RainBetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findFirstOrThrow
   */
  export type RainBetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBet to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainBets.
     */
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet findMany
   */
  export type RainBetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter, which RainBets to fetch.
     */
    where?: RainBetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainBets to fetch.
     */
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainBets.
     */
    cursor?: RainBetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainBets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainBets.
     */
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainBet create
   */
  export type RainBetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to create a RainBet.
     */
    data: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
  }

  /**
   * RainBet createMany
   */
  export type RainBetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainBet createManyAndReturn
   */
  export type RainBetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * The data used to create many RainBets.
     */
    data: RainBetCreateManyInput | RainBetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainBet update
   */
  export type RainBetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The data needed to update a RainBet.
     */
    data: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
    /**
     * Choose, which RainBet to update.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet updateMany
   */
  export type RainBetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainBets.
     */
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyInput>
    /**
     * Filter which RainBets to update
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to update.
     */
    limit?: number
  }

  /**
   * RainBet updateManyAndReturn
   */
  export type RainBetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * The data used to update RainBets.
     */
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyInput>
    /**
     * Filter which RainBets to update
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainBet upsert
   */
  export type RainBetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * The filter to search for the RainBet to update in case it exists.
     */
    where: RainBetWhereUniqueInput
    /**
     * In case the RainBet found by the `where` argument doesn't exist, create a new RainBet with this data.
     */
    create: XOR<RainBetCreateInput, RainBetUncheckedCreateInput>
    /**
     * In case the RainBet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainBetUpdateInput, RainBetUncheckedUpdateInput>
  }

  /**
   * RainBet delete
   */
  export type RainBetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    /**
     * Filter which RainBet to delete.
     */
    where: RainBetWhereUniqueInput
  }

  /**
   * RainBet deleteMany
   */
  export type RainBetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainBets to delete
     */
    where?: RainBetWhereInput
    /**
     * Limit how many RainBets to delete.
     */
    limit?: number
  }

  /**
   * RainBet without action
   */
  export type RainBetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
  }


  /**
   * Model RainHistory
   */

  export type AggregateRainHistory = {
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  export type RainHistoryAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type RainHistorySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type RainHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    rainType: string | null
    createdAt: Date | null
  }

  export type RainHistoryCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    rainType: number
    createdAt: number
    _all: number
  }


  export type RainHistoryAvgAggregateInputType = {
    amount?: true
  }

  export type RainHistorySumAggregateInputType = {
    amount?: true
  }

  export type RainHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
  }

  export type RainHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    rainType?: true
    createdAt?: true
    _all?: true
  }

  export type RainHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistory to aggregate.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainHistories
    **/
    _count?: true | RainHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainHistoryMaxAggregateInputType
  }

  export type GetRainHistoryAggregateType<T extends RainHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRainHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainHistory[P]>
      : GetScalarType<T[P], AggregateRainHistory[P]>
  }




  export type RainHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainHistoryWhereInput
    orderBy?: RainHistoryOrderByWithAggregationInput | RainHistoryOrderByWithAggregationInput[]
    by: RainHistoryScalarFieldEnum[] | RainHistoryScalarFieldEnum
    having?: RainHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainHistoryCountAggregateInputType | true
    _avg?: RainHistoryAvgAggregateInputType
    _sum?: RainHistorySumAggregateInputType
    _min?: RainHistoryMinAggregateInputType
    _max?: RainHistoryMaxAggregateInputType
  }

  export type RainHistoryGroupByOutputType = {
    id: string
    userId: string
    amount: Decimal
    rainType: string
    createdAt: Date
    _count: RainHistoryCountAggregateOutputType | null
    _avg: RainHistoryAvgAggregateOutputType | null
    _sum: RainHistorySumAggregateOutputType | null
    _min: RainHistoryMinAggregateOutputType | null
    _max: RainHistoryMaxAggregateOutputType | null
  }

  type GetRainHistoryGroupByPayload<T extends RainHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], RainHistoryGroupByOutputType[P]>
        }
      >
    >


  export type RainHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainHistory"]>

  export type RainHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    rainType?: boolean
    createdAt?: boolean
  }

  export type RainHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "rainType" | "createdAt", ExtArgs["result"]["rainHistory"]>
  export type RainHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainBet?: boolean | RainHistory$RainBetArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    RainTip?: boolean | RainHistory$RainTipArgs<ExtArgs>
    RainWinner?: boolean | RainHistory$RainWinnerArgs<ExtArgs>
    _count?: boolean | RainHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RainHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $RainHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainHistory"
    objects: {
      RainBet: Prisma.$RainBetPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
      RainTip: Prisma.$RainTipPayload<ExtArgs>[]
      RainWinner: Prisma.$RainWinnerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: Prisma.Decimal
      rainType: string
      createdAt: Date
    }, ExtArgs["result"]["rainHistory"]>
    composites: {}
  }

  type RainHistoryGetPayload<S extends boolean | null | undefined | RainHistoryDefaultArgs> = $Result.GetResult<Prisma.$RainHistoryPayload, S>

  type RainHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainHistoryCountAggregateInputType | true
    }

  export interface RainHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainHistory'], meta: { name: 'RainHistory' } }
    /**
     * Find zero or one RainHistory that matches the filter.
     * @param {RainHistoryFindUniqueArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainHistoryFindUniqueArgs>(args: SelectSubset<T, RainHistoryFindUniqueArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainHistoryFindUniqueOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RainHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainHistoryFindFirstArgs>(args?: SelectSubset<T, RainHistoryFindFirstArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindFirstOrThrowArgs} args - Arguments to find a RainHistory
     * @example
     * // Get one RainHistory
     * const rainHistory = await prisma.rainHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RainHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainHistories
     * const rainHistories = await prisma.rainHistory.findMany()
     * 
     * // Get first 10 RainHistories
     * const rainHistories = await prisma.rainHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainHistoryFindManyArgs>(args?: SelectSubset<T, RainHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainHistory.
     * @param {RainHistoryCreateArgs} args - Arguments to create a RainHistory.
     * @example
     * // Create one RainHistory
     * const RainHistory = await prisma.rainHistory.create({
     *   data: {
     *     // ... data to create a RainHistory
     *   }
     * })
     * 
     */
    create<T extends RainHistoryCreateArgs>(args: SelectSubset<T, RainHistoryCreateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainHistories.
     * @param {RainHistoryCreateManyArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainHistoryCreateManyArgs>(args?: SelectSubset<T, RainHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainHistories and returns the data saved in the database.
     * @param {RainHistoryCreateManyAndReturnArgs} args - Arguments to create many RainHistories.
     * @example
     * // Create many RainHistories
     * const rainHistory = await prisma.rainHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainHistories and only return the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RainHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainHistory.
     * @param {RainHistoryDeleteArgs} args - Arguments to delete one RainHistory.
     * @example
     * // Delete one RainHistory
     * const RainHistory = await prisma.rainHistory.delete({
     *   where: {
     *     // ... filter to delete one RainHistory
     *   }
     * })
     * 
     */
    delete<T extends RainHistoryDeleteArgs>(args: SelectSubset<T, RainHistoryDeleteArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainHistory.
     * @param {RainHistoryUpdateArgs} args - Arguments to update one RainHistory.
     * @example
     * // Update one RainHistory
     * const rainHistory = await prisma.rainHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainHistoryUpdateArgs>(args: SelectSubset<T, RainHistoryUpdateArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainHistories.
     * @param {RainHistoryDeleteManyArgs} args - Arguments to filter RainHistories to delete.
     * @example
     * // Delete a few RainHistories
     * const { count } = await prisma.rainHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainHistoryDeleteManyArgs>(args?: SelectSubset<T, RainHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainHistories
     * const rainHistory = await prisma.rainHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainHistoryUpdateManyArgs>(args: SelectSubset<T, RainHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainHistories and returns the data updated in the database.
     * @param {RainHistoryUpdateManyAndReturnArgs} args - Arguments to update many RainHistories.
     * @example
     * // Update many RainHistories
     * const rainHistory = await prisma.rainHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainHistories and only return the `id`
     * const rainHistoryWithIdOnly = await prisma.rainHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RainHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainHistory.
     * @param {RainHistoryUpsertArgs} args - Arguments to update or create a RainHistory.
     * @example
     * // Update or create a RainHistory
     * const rainHistory = await prisma.rainHistory.upsert({
     *   create: {
     *     // ... data to create a RainHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainHistory we want to update
     *   }
     * })
     */
    upsert<T extends RainHistoryUpsertArgs>(args: SelectSubset<T, RainHistoryUpsertArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryCountArgs} args - Arguments to filter RainHistories to count.
     * @example
     * // Count the number of RainHistories
     * const count = await prisma.rainHistory.count({
     *   where: {
     *     // ... the filter for the RainHistories we want to count
     *   }
     * })
    **/
    count<T extends RainHistoryCountArgs>(
      args?: Subset<T, RainHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainHistoryAggregateArgs>(args: Subset<T, RainHistoryAggregateArgs>): Prisma.PrismaPromise<GetRainHistoryAggregateType<T>>

    /**
     * Group by RainHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainHistoryGroupByArgs['orderBy'] }
        : { orderBy?: RainHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainHistory model
   */
  readonly fields: RainHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainBet<T extends RainHistory$RainBetArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainBetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainBetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RainTip<T extends RainHistory$RainTipArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainTipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RainWinner<T extends RainHistory$RainWinnerArgs<ExtArgs> = {}>(args?: Subset<T, RainHistory$RainWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainHistory model
   */
  interface RainHistoryFieldRefs {
    readonly id: FieldRef<"RainHistory", 'String'>
    readonly userId: FieldRef<"RainHistory", 'String'>
    readonly amount: FieldRef<"RainHistory", 'Decimal'>
    readonly rainType: FieldRef<"RainHistory", 'String'>
    readonly createdAt: FieldRef<"RainHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainHistory findUnique
   */
  export type RainHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findUniqueOrThrow
   */
  export type RainHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory findFirst
   */
  export type RainHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findFirstOrThrow
   */
  export type RainHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistory to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainHistories.
     */
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory findMany
   */
  export type RainHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter, which RainHistories to fetch.
     */
    where?: RainHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainHistories to fetch.
     */
    orderBy?: RainHistoryOrderByWithRelationInput | RainHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainHistories.
     */
    cursor?: RainHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainHistories.
     */
    skip?: number
    distinct?: RainHistoryScalarFieldEnum | RainHistoryScalarFieldEnum[]
  }

  /**
   * RainHistory create
   */
  export type RainHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RainHistory.
     */
    data: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
  }

  /**
   * RainHistory createMany
   */
  export type RainHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainHistory createManyAndReturn
   */
  export type RainHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many RainHistories.
     */
    data: RainHistoryCreateManyInput | RainHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainHistory update
   */
  export type RainHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RainHistory.
     */
    data: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
    /**
     * Choose, which RainHistory to update.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory updateMany
   */
  export type RainHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainHistories.
     */
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RainHistories to update
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to update.
     */
    limit?: number
  }

  /**
   * RainHistory updateManyAndReturn
   */
  export type RainHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * The data used to update RainHistories.
     */
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyInput>
    /**
     * Filter which RainHistories to update
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainHistory upsert
   */
  export type RainHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RainHistory to update in case it exists.
     */
    where: RainHistoryWhereUniqueInput
    /**
     * In case the RainHistory found by the `where` argument doesn't exist, create a new RainHistory with this data.
     */
    create: XOR<RainHistoryCreateInput, RainHistoryUncheckedCreateInput>
    /**
     * In case the RainHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainHistoryUpdateInput, RainHistoryUncheckedUpdateInput>
  }

  /**
   * RainHistory delete
   */
  export type RainHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
    /**
     * Filter which RainHistory to delete.
     */
    where: RainHistoryWhereUniqueInput
  }

  /**
   * RainHistory deleteMany
   */
  export type RainHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainHistories to delete
     */
    where?: RainHistoryWhereInput
    /**
     * Limit how many RainHistories to delete.
     */
    limit?: number
  }

  /**
   * RainHistory.RainBet
   */
  export type RainHistory$RainBetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainBet
     */
    select?: RainBetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainBet
     */
    omit?: RainBetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainBetInclude<ExtArgs> | null
    where?: RainBetWhereInput
    orderBy?: RainBetOrderByWithRelationInput | RainBetOrderByWithRelationInput[]
    cursor?: RainBetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainBetScalarFieldEnum | RainBetScalarFieldEnum[]
  }

  /**
   * RainHistory.RainTip
   */
  export type RainHistory$RainTipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    cursor?: RainTipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainHistory.RainWinner
   */
  export type RainHistory$RainWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    cursor?: RainWinnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainHistory without action
   */
  export type RainHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainHistory
     */
    select?: RainHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainHistory
     */
    omit?: RainHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainHistoryInclude<ExtArgs> | null
  }


  /**
   * Model RainTip
   */

  export type AggregateRainTip = {
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  export type RainTipAvgAggregateOutputType = {
    tipAmount: Decimal | null
  }

  export type RainTipSumAggregateOutputType = {
    tipAmount: Decimal | null
  }

  export type RainTipMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: Decimal | null
    tippedAt: Date | null
  }

  export type RainTipMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    tipAmount: Decimal | null
    tippedAt: Date | null
  }

  export type RainTipCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    tipAmount: number
    tippedAt: number
    _all: number
  }


  export type RainTipAvgAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipSumAggregateInputType = {
    tipAmount?: true
  }

  export type RainTipMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
  }

  export type RainTipCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    tipAmount?: true
    tippedAt?: true
    _all?: true
  }

  export type RainTipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTip to aggregate.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainTips
    **/
    _count?: true | RainTipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainTipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainTipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainTipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainTipMaxAggregateInputType
  }

  export type GetRainTipAggregateType<T extends RainTipAggregateArgs> = {
        [P in keyof T & keyof AggregateRainTip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainTip[P]>
      : GetScalarType<T[P], AggregateRainTip[P]>
  }




  export type RainTipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainTipWhereInput
    orderBy?: RainTipOrderByWithAggregationInput | RainTipOrderByWithAggregationInput[]
    by: RainTipScalarFieldEnum[] | RainTipScalarFieldEnum
    having?: RainTipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainTipCountAggregateInputType | true
    _avg?: RainTipAvgAggregateInputType
    _sum?: RainTipSumAggregateInputType
    _min?: RainTipMinAggregateInputType
    _max?: RainTipMaxAggregateInputType
  }

  export type RainTipGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    tipAmount: Decimal
    tippedAt: Date
    _count: RainTipCountAggregateOutputType | null
    _avg: RainTipAvgAggregateOutputType | null
    _sum: RainTipSumAggregateOutputType | null
    _min: RainTipMinAggregateOutputType | null
    _max: RainTipMaxAggregateOutputType | null
  }

  type GetRainTipGroupByPayload<T extends RainTipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainTipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainTipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainTipGroupByOutputType[P]>
            : GetScalarType<T[P], RainTipGroupByOutputType[P]>
        }
      >
    >


  export type RainTipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainTip"]>

  export type RainTipSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    tipAmount?: boolean
    tippedAt?: boolean
  }

  export type RainTipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "tipAmount" | "tippedAt", ExtArgs["result"]["rainTip"]>
  export type RainTipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainTipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainTipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $RainTipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainTip"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      tipAmount: Prisma.Decimal
      tippedAt: Date
    }, ExtArgs["result"]["rainTip"]>
    composites: {}
  }

  type RainTipGetPayload<S extends boolean | null | undefined | RainTipDefaultArgs> = $Result.GetResult<Prisma.$RainTipPayload, S>

  type RainTipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainTipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainTipCountAggregateInputType | true
    }

  export interface RainTipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainTip'], meta: { name: 'RainTip' } }
    /**
     * Find zero or one RainTip that matches the filter.
     * @param {RainTipFindUniqueArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainTipFindUniqueArgs>(args: SelectSubset<T, RainTipFindUniqueArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainTip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainTipFindUniqueOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainTipFindUniqueOrThrowArgs>(args: SelectSubset<T, RainTipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainTip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainTipFindFirstArgs>(args?: SelectSubset<T, RainTipFindFirstArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainTip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindFirstOrThrowArgs} args - Arguments to find a RainTip
     * @example
     * // Get one RainTip
     * const rainTip = await prisma.rainTip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainTipFindFirstOrThrowArgs>(args?: SelectSubset<T, RainTipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainTips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainTips
     * const rainTips = await prisma.rainTip.findMany()
     * 
     * // Get first 10 RainTips
     * const rainTips = await prisma.rainTip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainTipFindManyArgs>(args?: SelectSubset<T, RainTipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainTip.
     * @param {RainTipCreateArgs} args - Arguments to create a RainTip.
     * @example
     * // Create one RainTip
     * const RainTip = await prisma.rainTip.create({
     *   data: {
     *     // ... data to create a RainTip
     *   }
     * })
     * 
     */
    create<T extends RainTipCreateArgs>(args: SelectSubset<T, RainTipCreateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainTips.
     * @param {RainTipCreateManyArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainTipCreateManyArgs>(args?: SelectSubset<T, RainTipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainTips and returns the data saved in the database.
     * @param {RainTipCreateManyAndReturnArgs} args - Arguments to create many RainTips.
     * @example
     * // Create many RainTips
     * const rainTip = await prisma.rainTip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainTips and only return the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainTipCreateManyAndReturnArgs>(args?: SelectSubset<T, RainTipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainTip.
     * @param {RainTipDeleteArgs} args - Arguments to delete one RainTip.
     * @example
     * // Delete one RainTip
     * const RainTip = await prisma.rainTip.delete({
     *   where: {
     *     // ... filter to delete one RainTip
     *   }
     * })
     * 
     */
    delete<T extends RainTipDeleteArgs>(args: SelectSubset<T, RainTipDeleteArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainTip.
     * @param {RainTipUpdateArgs} args - Arguments to update one RainTip.
     * @example
     * // Update one RainTip
     * const rainTip = await prisma.rainTip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainTipUpdateArgs>(args: SelectSubset<T, RainTipUpdateArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainTips.
     * @param {RainTipDeleteManyArgs} args - Arguments to filter RainTips to delete.
     * @example
     * // Delete a few RainTips
     * const { count } = await prisma.rainTip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainTipDeleteManyArgs>(args?: SelectSubset<T, RainTipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainTips
     * const rainTip = await prisma.rainTip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainTipUpdateManyArgs>(args: SelectSubset<T, RainTipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainTips and returns the data updated in the database.
     * @param {RainTipUpdateManyAndReturnArgs} args - Arguments to update many RainTips.
     * @example
     * // Update many RainTips
     * const rainTip = await prisma.rainTip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainTips and only return the `id`
     * const rainTipWithIdOnly = await prisma.rainTip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainTipUpdateManyAndReturnArgs>(args: SelectSubset<T, RainTipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainTip.
     * @param {RainTipUpsertArgs} args - Arguments to update or create a RainTip.
     * @example
     * // Update or create a RainTip
     * const rainTip = await prisma.rainTip.upsert({
     *   create: {
     *     // ... data to create a RainTip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainTip we want to update
     *   }
     * })
     */
    upsert<T extends RainTipUpsertArgs>(args: SelectSubset<T, RainTipUpsertArgs<ExtArgs>>): Prisma__RainTipClient<$Result.GetResult<Prisma.$RainTipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipCountArgs} args - Arguments to filter RainTips to count.
     * @example
     * // Count the number of RainTips
     * const count = await prisma.rainTip.count({
     *   where: {
     *     // ... the filter for the RainTips we want to count
     *   }
     * })
    **/
    count<T extends RainTipCountArgs>(
      args?: Subset<T, RainTipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainTipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainTipAggregateArgs>(args: Subset<T, RainTipAggregateArgs>): Prisma.PrismaPromise<GetRainTipAggregateType<T>>

    /**
     * Group by RainTip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainTipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainTipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainTipGroupByArgs['orderBy'] }
        : { orderBy?: RainTipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainTipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainTipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainTip model
   */
  readonly fields: RainTipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainTip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainTipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainTip model
   */
  interface RainTipFieldRefs {
    readonly id: FieldRef<"RainTip", 'String'>
    readonly rainHistoryId: FieldRef<"RainTip", 'String'>
    readonly userId: FieldRef<"RainTip", 'String'>
    readonly tipAmount: FieldRef<"RainTip", 'Decimal'>
    readonly tippedAt: FieldRef<"RainTip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainTip findUnique
   */
  export type RainTipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findUniqueOrThrow
   */
  export type RainTipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip findFirst
   */
  export type RainTipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findFirstOrThrow
   */
  export type RainTipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTip to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainTips.
     */
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip findMany
   */
  export type RainTipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter, which RainTips to fetch.
     */
    where?: RainTipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainTips to fetch.
     */
    orderBy?: RainTipOrderByWithRelationInput | RainTipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainTips.
     */
    cursor?: RainTipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainTips.
     */
    skip?: number
    distinct?: RainTipScalarFieldEnum | RainTipScalarFieldEnum[]
  }

  /**
   * RainTip create
   */
  export type RainTipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to create a RainTip.
     */
    data: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
  }

  /**
   * RainTip createMany
   */
  export type RainTipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainTip createManyAndReturn
   */
  export type RainTipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * The data used to create many RainTips.
     */
    data: RainTipCreateManyInput | RainTipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainTip update
   */
  export type RainTipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The data needed to update a RainTip.
     */
    data: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
    /**
     * Choose, which RainTip to update.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip updateMany
   */
  export type RainTipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainTips.
     */
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyInput>
    /**
     * Filter which RainTips to update
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to update.
     */
    limit?: number
  }

  /**
   * RainTip updateManyAndReturn
   */
  export type RainTipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * The data used to update RainTips.
     */
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyInput>
    /**
     * Filter which RainTips to update
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainTip upsert
   */
  export type RainTipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * The filter to search for the RainTip to update in case it exists.
     */
    where: RainTipWhereUniqueInput
    /**
     * In case the RainTip found by the `where` argument doesn't exist, create a new RainTip with this data.
     */
    create: XOR<RainTipCreateInput, RainTipUncheckedCreateInput>
    /**
     * In case the RainTip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainTipUpdateInput, RainTipUncheckedUpdateInput>
  }

  /**
   * RainTip delete
   */
  export type RainTipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
    /**
     * Filter which RainTip to delete.
     */
    where: RainTipWhereUniqueInput
  }

  /**
   * RainTip deleteMany
   */
  export type RainTipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainTips to delete
     */
    where?: RainTipWhereInput
    /**
     * Limit how many RainTips to delete.
     */
    limit?: number
  }

  /**
   * RainTip without action
   */
  export type RainTipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainTip
     */
    select?: RainTipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainTip
     */
    omit?: RainTipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainTipInclude<ExtArgs> | null
  }


  /**
   * Model RainWinner
   */

  export type AggregateRainWinner = {
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  export type RainWinnerAvgAggregateOutputType = {
    wonAmount: Decimal | null
  }

  export type RainWinnerSumAggregateOutputType = {
    wonAmount: Decimal | null
  }

  export type RainWinnerMinAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: Decimal | null
    wonAt: Date | null
  }

  export type RainWinnerMaxAggregateOutputType = {
    id: string | null
    rainHistoryId: string | null
    userId: string | null
    wonAmount: Decimal | null
    wonAt: Date | null
  }

  export type RainWinnerCountAggregateOutputType = {
    id: number
    rainHistoryId: number
    userId: number
    wonAmount: number
    wonAt: number
    _all: number
  }


  export type RainWinnerAvgAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerSumAggregateInputType = {
    wonAmount?: true
  }

  export type RainWinnerMinAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerMaxAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
  }

  export type RainWinnerCountAggregateInputType = {
    id?: true
    rainHistoryId?: true
    userId?: true
    wonAmount?: true
    wonAt?: true
    _all?: true
  }

  export type RainWinnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinner to aggregate.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RainWinners
    **/
    _count?: true | RainWinnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RainWinnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RainWinnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RainWinnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RainWinnerMaxAggregateInputType
  }

  export type GetRainWinnerAggregateType<T extends RainWinnerAggregateArgs> = {
        [P in keyof T & keyof AggregateRainWinner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRainWinner[P]>
      : GetScalarType<T[P], AggregateRainWinner[P]>
  }




  export type RainWinnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RainWinnerWhereInput
    orderBy?: RainWinnerOrderByWithAggregationInput | RainWinnerOrderByWithAggregationInput[]
    by: RainWinnerScalarFieldEnum[] | RainWinnerScalarFieldEnum
    having?: RainWinnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RainWinnerCountAggregateInputType | true
    _avg?: RainWinnerAvgAggregateInputType
    _sum?: RainWinnerSumAggregateInputType
    _min?: RainWinnerMinAggregateInputType
    _max?: RainWinnerMaxAggregateInputType
  }

  export type RainWinnerGroupByOutputType = {
    id: string
    rainHistoryId: string
    userId: string
    wonAmount: Decimal
    wonAt: Date
    _count: RainWinnerCountAggregateOutputType | null
    _avg: RainWinnerAvgAggregateOutputType | null
    _sum: RainWinnerSumAggregateOutputType | null
    _min: RainWinnerMinAggregateOutputType | null
    _max: RainWinnerMaxAggregateOutputType | null
  }

  type GetRainWinnerGroupByPayload<T extends RainWinnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RainWinnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RainWinnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
            : GetScalarType<T[P], RainWinnerGroupByOutputType[P]>
        }
      >
    >


  export type RainWinnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rainWinner"]>

  export type RainWinnerSelectScalar = {
    id?: boolean
    rainHistoryId?: boolean
    userId?: boolean
    wonAmount?: boolean
    wonAt?: boolean
  }

  export type RainWinnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rainHistoryId" | "userId" | "wonAmount" | "wonAt", ExtArgs["result"]["rainWinner"]>
  export type RainWinnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainWinnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type RainWinnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RainHistory?: boolean | RainHistoryDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $RainWinnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RainWinner"
    objects: {
      RainHistory: Prisma.$RainHistoryPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rainHistoryId: string
      userId: string
      wonAmount: Prisma.Decimal
      wonAt: Date
    }, ExtArgs["result"]["rainWinner"]>
    composites: {}
  }

  type RainWinnerGetPayload<S extends boolean | null | undefined | RainWinnerDefaultArgs> = $Result.GetResult<Prisma.$RainWinnerPayload, S>

  type RainWinnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RainWinnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RainWinnerCountAggregateInputType | true
    }

  export interface RainWinnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RainWinner'], meta: { name: 'RainWinner' } }
    /**
     * Find zero or one RainWinner that matches the filter.
     * @param {RainWinnerFindUniqueArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RainWinnerFindUniqueArgs>(args: SelectSubset<T, RainWinnerFindUniqueArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RainWinner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RainWinnerFindUniqueOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RainWinnerFindUniqueOrThrowArgs>(args: SelectSubset<T, RainWinnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainWinner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RainWinnerFindFirstArgs>(args?: SelectSubset<T, RainWinnerFindFirstArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RainWinner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindFirstOrThrowArgs} args - Arguments to find a RainWinner
     * @example
     * // Get one RainWinner
     * const rainWinner = await prisma.rainWinner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RainWinnerFindFirstOrThrowArgs>(args?: SelectSubset<T, RainWinnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RainWinners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RainWinners
     * const rainWinners = await prisma.rainWinner.findMany()
     * 
     * // Get first 10 RainWinners
     * const rainWinners = await prisma.rainWinner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RainWinnerFindManyArgs>(args?: SelectSubset<T, RainWinnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RainWinner.
     * @param {RainWinnerCreateArgs} args - Arguments to create a RainWinner.
     * @example
     * // Create one RainWinner
     * const RainWinner = await prisma.rainWinner.create({
     *   data: {
     *     // ... data to create a RainWinner
     *   }
     * })
     * 
     */
    create<T extends RainWinnerCreateArgs>(args: SelectSubset<T, RainWinnerCreateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RainWinners.
     * @param {RainWinnerCreateManyArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RainWinnerCreateManyArgs>(args?: SelectSubset<T, RainWinnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RainWinners and returns the data saved in the database.
     * @param {RainWinnerCreateManyAndReturnArgs} args - Arguments to create many RainWinners.
     * @example
     * // Create many RainWinners
     * const rainWinner = await prisma.rainWinner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RainWinners and only return the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RainWinnerCreateManyAndReturnArgs>(args?: SelectSubset<T, RainWinnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RainWinner.
     * @param {RainWinnerDeleteArgs} args - Arguments to delete one RainWinner.
     * @example
     * // Delete one RainWinner
     * const RainWinner = await prisma.rainWinner.delete({
     *   where: {
     *     // ... filter to delete one RainWinner
     *   }
     * })
     * 
     */
    delete<T extends RainWinnerDeleteArgs>(args: SelectSubset<T, RainWinnerDeleteArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RainWinner.
     * @param {RainWinnerUpdateArgs} args - Arguments to update one RainWinner.
     * @example
     * // Update one RainWinner
     * const rainWinner = await prisma.rainWinner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RainWinnerUpdateArgs>(args: SelectSubset<T, RainWinnerUpdateArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RainWinners.
     * @param {RainWinnerDeleteManyArgs} args - Arguments to filter RainWinners to delete.
     * @example
     * // Delete a few RainWinners
     * const { count } = await prisma.rainWinner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RainWinnerDeleteManyArgs>(args?: SelectSubset<T, RainWinnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RainWinners
     * const rainWinner = await prisma.rainWinner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RainWinnerUpdateManyArgs>(args: SelectSubset<T, RainWinnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RainWinners and returns the data updated in the database.
     * @param {RainWinnerUpdateManyAndReturnArgs} args - Arguments to update many RainWinners.
     * @example
     * // Update many RainWinners
     * const rainWinner = await prisma.rainWinner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RainWinners and only return the `id`
     * const rainWinnerWithIdOnly = await prisma.rainWinner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RainWinnerUpdateManyAndReturnArgs>(args: SelectSubset<T, RainWinnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RainWinner.
     * @param {RainWinnerUpsertArgs} args - Arguments to update or create a RainWinner.
     * @example
     * // Update or create a RainWinner
     * const rainWinner = await prisma.rainWinner.upsert({
     *   create: {
     *     // ... data to create a RainWinner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RainWinner we want to update
     *   }
     * })
     */
    upsert<T extends RainWinnerUpsertArgs>(args: SelectSubset<T, RainWinnerUpsertArgs<ExtArgs>>): Prisma__RainWinnerClient<$Result.GetResult<Prisma.$RainWinnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RainWinners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerCountArgs} args - Arguments to filter RainWinners to count.
     * @example
     * // Count the number of RainWinners
     * const count = await prisma.rainWinner.count({
     *   where: {
     *     // ... the filter for the RainWinners we want to count
     *   }
     * })
    **/
    count<T extends RainWinnerCountArgs>(
      args?: Subset<T, RainWinnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RainWinnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RainWinnerAggregateArgs>(args: Subset<T, RainWinnerAggregateArgs>): Prisma.PrismaPromise<GetRainWinnerAggregateType<T>>

    /**
     * Group by RainWinner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RainWinnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RainWinnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RainWinnerGroupByArgs['orderBy'] }
        : { orderBy?: RainWinnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RainWinnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRainWinnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RainWinner model
   */
  readonly fields: RainWinnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RainWinner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RainWinnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RainHistory<T extends RainHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RainHistoryDefaultArgs<ExtArgs>>): Prisma__RainHistoryClient<$Result.GetResult<Prisma.$RainHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RainWinner model
   */
  interface RainWinnerFieldRefs {
    readonly id: FieldRef<"RainWinner", 'String'>
    readonly rainHistoryId: FieldRef<"RainWinner", 'String'>
    readonly userId: FieldRef<"RainWinner", 'String'>
    readonly wonAmount: FieldRef<"RainWinner", 'Decimal'>
    readonly wonAt: FieldRef<"RainWinner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RainWinner findUnique
   */
  export type RainWinnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findUniqueOrThrow
   */
  export type RainWinnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner findFirst
   */
  export type RainWinnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findFirstOrThrow
   */
  export type RainWinnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinner to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RainWinners.
     */
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner findMany
   */
  export type RainWinnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter, which RainWinners to fetch.
     */
    where?: RainWinnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RainWinners to fetch.
     */
    orderBy?: RainWinnerOrderByWithRelationInput | RainWinnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RainWinners.
     */
    cursor?: RainWinnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RainWinners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RainWinners.
     */
    skip?: number
    distinct?: RainWinnerScalarFieldEnum | RainWinnerScalarFieldEnum[]
  }

  /**
   * RainWinner create
   */
  export type RainWinnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to create a RainWinner.
     */
    data: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
  }

  /**
   * RainWinner createMany
   */
  export type RainWinnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RainWinner createManyAndReturn
   */
  export type RainWinnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * The data used to create many RainWinners.
     */
    data: RainWinnerCreateManyInput | RainWinnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainWinner update
   */
  export type RainWinnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The data needed to update a RainWinner.
     */
    data: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
    /**
     * Choose, which RainWinner to update.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner updateMany
   */
  export type RainWinnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RainWinners.
     */
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyInput>
    /**
     * Filter which RainWinners to update
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to update.
     */
    limit?: number
  }

  /**
   * RainWinner updateManyAndReturn
   */
  export type RainWinnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * The data used to update RainWinners.
     */
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyInput>
    /**
     * Filter which RainWinners to update
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RainWinner upsert
   */
  export type RainWinnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * The filter to search for the RainWinner to update in case it exists.
     */
    where: RainWinnerWhereUniqueInput
    /**
     * In case the RainWinner found by the `where` argument doesn't exist, create a new RainWinner with this data.
     */
    create: XOR<RainWinnerCreateInput, RainWinnerUncheckedCreateInput>
    /**
     * In case the RainWinner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RainWinnerUpdateInput, RainWinnerUncheckedUpdateInput>
  }

  /**
   * RainWinner delete
   */
  export type RainWinnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
    /**
     * Filter which RainWinner to delete.
     */
    where: RainWinnerWhereUniqueInput
  }

  /**
   * RainWinner deleteMany
   */
  export type RainWinnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RainWinners to delete
     */
    where?: RainWinnerWhereInput
    /**
     * Limit how many RainWinners to delete.
     */
    limit?: number
  }

  /**
   * RainWinner without action
   */
  export type RainWinnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RainWinner
     */
    select?: RainWinnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RainWinner
     */
    omit?: RainWinnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RainWinnerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    targetXp: 'targetXp',
    reward: 'reward',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    name: 'name',
    currency: 'currency',
    isActive: 'isActive',
    createdAt: 'createdAt',
    operatorId: 'operatorId'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const ChatmessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    channel: 'channel',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId',
    roomId: 'roomId'
  };

  export type ChatmessageScalarFieldEnum = (typeof ChatmessageScalarFieldEnum)[keyof typeof ChatmessageScalarFieldEnum]


  export const ChatroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isGameRoom: 'isGameRoom',
    createdAt: 'createdAt',
    gameSessionId: 'gameSessionId'
  };

  export type ChatroomScalarFieldEnum = (typeof ChatroomScalarFieldEnum)[keyof typeof ChatroomScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    friendId: 'friendId'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const GamesessionScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    betAmount: 'betAmount',
    winAmount: 'winAmount',
    xpEarned: 'xpEarned',
    metadata: 'metadata',
    gameId: 'gameId',
    tournamentId: 'tournamentId',
    active: 'active',
    profileId: 'profileId'
  };

  export type GamesessionScalarFieldEnum = (typeof GamesessionScalarFieldEnum)[keyof typeof GamesessionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OperatorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ownerId: 'ownerId'
  };

  export type OperatorScalarFieldEnum = (typeof OperatorScalarFieldEnum)[keyof typeof OperatorScalarFieldEnum]


  export const OperatorgameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    thumbnail: 'thumbnail',
    minBet: 'minBet',
    maxBet: 'maxBet',
    xpMultiplier: 'xpMultiplier',
    isActive: 'isActive',
    isPromoted: 'isPromoted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId'
  };

  export type OperatorgameScalarFieldEnum = (typeof OperatorgameScalarFieldEnum)[keyof typeof OperatorgameScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    profileNumber: 'profileNumber',
    balance: 'balance',
    xpEarned: 'xpEarned',
    isActive: 'isActive',
    lastPlayed: 'lastPlayed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    phpId: 'phpId',
    userId: 'userId',
    bankId: 'bankId',
    shopId: 'shopId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    activeGameId: 'activeGameId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    refreshToken: 'refreshToken',
    active: 'active'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    entryFee: 'entryFee',
    prizePool: 'prizePool',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    operatorId: 'operatorId',
    leaderboard: 'leaderboard'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamententryScalarFieldEnum: {
    id: 'id',
    score: 'score',
    wagered: 'wagered',
    won: 'won',
    joinedAt: 'joinedAt',
    userId: 'userId',
    tournamentId: 'tournamentId',
    profileId: 'profileId'
  };

  export type TournamententryScalarFieldEnum = (typeof TournamententryScalarFieldEnum)[keyof typeof TournamententryScalarFieldEnum]


  export const TournamentgameScalarFieldEnum: {
    id: 'id',
    multiplier: 'multiplier',
    tournamentId: 'tournamentId',
    gameId: 'gameId'
  };

  export type TournamentgameScalarFieldEnum = (typeof TournamentgameScalarFieldEnum)[keyof typeof TournamentgameScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    reference: 'reference',
    status: 'status',
    metadata: 'metadata',
    isRealMoney: 'isRealMoney',
    paymentMethod: 'paymentMethod',
    paymentDetails: 'paymentDetails',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    gameSessionId: 'gameSessionId',
    profileId: 'profileId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    avatar: 'avatar',
    totalXp: 'totalXp',
    balance: 'balance',
    lastLogin: 'lastLogin',
    isVerified: 'isVerified',
    verificationToken: 'verificationToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    active: 'active',
    activeProfileId: 'activeProfileId',
    gender: 'gender',
    status: 'status',
    cashtag: 'cashtag',
    phpId: 'phpId',
    accessToken: 'accessToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserachievementScalarFieldEnum: {
    id: 'id',
    progress: 'progress',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    achievementId: 'achievementId'
  };

  export type UserachievementScalarFieldEnum = (typeof UserachievementScalarFieldEnum)[keyof typeof UserachievementScalarFieldEnum]


  export const RainBetScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    betAmount: 'betAmount',
    odds: 'odds',
    outcome: 'outcome',
    settledAt: 'settledAt'
  };

  export type RainBetScalarFieldEnum = (typeof RainBetScalarFieldEnum)[keyof typeof RainBetScalarFieldEnum]


  export const RainHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    rainType: 'rainType',
    createdAt: 'createdAt'
  };

  export type RainHistoryScalarFieldEnum = (typeof RainHistoryScalarFieldEnum)[keyof typeof RainHistoryScalarFieldEnum]


  export const RainTipScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    tipAmount: 'tipAmount',
    tippedAt: 'tippedAt'
  };

  export type RainTipScalarFieldEnum = (typeof RainTipScalarFieldEnum)[keyof typeof RainTipScalarFieldEnum]


  export const RainWinnerScalarFieldEnum: {
    id: 'id',
    rainHistoryId: 'rainHistoryId',
    userId: 'userId',
    wonAmount: 'wonAmount',
    wonAt: 'wonAt'
  };

  export type RainWinnerScalarFieldEnum = (typeof RainWinnerScalarFieldEnum)[keyof typeof RainWinnerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ChatChannel'
   */
  export type EnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel'>
    


  /**
   * Reference to a field of type 'ChatChannel[]'
   */
  export type ListEnumChatChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatChannel[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FriendshipStatus'
   */
  export type EnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus'>
    


  /**
   * Reference to a field of type 'FriendshipStatus[]'
   */
  export type ListEnumFriendshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendshipStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type achievementWhereInput = {
    AND?: achievementWhereInput | achievementWhereInput[]
    OR?: achievementWhereInput[]
    NOT?: achievementWhereInput | achievementWhereInput[]
    id?: StringFilter<"achievement"> | string
    name?: StringFilter<"achievement"> | string
    description?: StringFilter<"achievement"> | string
    targetXp?: IntFilter<"achievement"> | number
    reward?: DecimalNullableFilter<"achievement"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"achievement"> | boolean
    createdAt?: DateTimeFilter<"achievement"> | Date | string
    updatedAt?: DateTimeFilter<"achievement"> | Date | string
    userachievement?: UserachievementListRelationFilter
  }

  export type achievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userachievement?: userachievementOrderByRelationAggregateInput
  }

  export type achievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: achievementWhereInput | achievementWhereInput[]
    OR?: achievementWhereInput[]
    NOT?: achievementWhereInput | achievementWhereInput[]
    name?: StringFilter<"achievement"> | string
    description?: StringFilter<"achievement"> | string
    targetXp?: IntFilter<"achievement"> | number
    reward?: DecimalNullableFilter<"achievement"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"achievement"> | boolean
    createdAt?: DateTimeFilter<"achievement"> | Date | string
    updatedAt?: DateTimeFilter<"achievement"> | Date | string
    userachievement?: UserachievementListRelationFilter
  }, "id">

  export type achievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: achievementCountOrderByAggregateInput
    _avg?: achievementAvgOrderByAggregateInput
    _max?: achievementMaxOrderByAggregateInput
    _min?: achievementMinOrderByAggregateInput
    _sum?: achievementSumOrderByAggregateInput
  }

  export type achievementScalarWhereWithAggregatesInput = {
    AND?: achievementScalarWhereWithAggregatesInput | achievementScalarWhereWithAggregatesInput[]
    OR?: achievementScalarWhereWithAggregatesInput[]
    NOT?: achievementScalarWhereWithAggregatesInput | achievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"achievement"> | string
    name?: StringWithAggregatesFilter<"achievement"> | string
    description?: StringWithAggregatesFilter<"achievement"> | string
    targetXp?: IntWithAggregatesFilter<"achievement"> | number
    reward?: DecimalNullableWithAggregatesFilter<"achievement"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"achievement"> | Date | string
  }

  export type bankWhereInput = {
    AND?: bankWhereInput | bankWhereInput[]
    OR?: bankWhereInput[]
    NOT?: bankWhereInput | bankWhereInput[]
    id?: StringFilter<"bank"> | string
    name?: StringFilter<"bank"> | string
    currency?: StringFilter<"bank"> | string
    isActive?: BoolFilter<"bank"> | boolean
    createdAt?: DateTimeFilter<"bank"> | Date | string
    operatorId?: StringFilter<"bank"> | string
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    profile?: ProfileListRelationFilter
  }

  export type bankOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    operatorId?: SortOrder
    operator?: operatorOrderByWithRelationInput
    profile?: profileOrderByRelationAggregateInput
  }

  export type bankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    operatorId_name?: bankOperatorIdNameCompoundUniqueInput
    AND?: bankWhereInput | bankWhereInput[]
    OR?: bankWhereInput[]
    NOT?: bankWhereInput | bankWhereInput[]
    name?: StringFilter<"bank"> | string
    currency?: StringFilter<"bank"> | string
    isActive?: BoolFilter<"bank"> | boolean
    createdAt?: DateTimeFilter<"bank"> | Date | string
    operatorId?: StringFilter<"bank"> | string
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    profile?: ProfileListRelationFilter
  }, "id" | "operatorId_name">

  export type bankOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    operatorId?: SortOrder
    _count?: bankCountOrderByAggregateInput
    _max?: bankMaxOrderByAggregateInput
    _min?: bankMinOrderByAggregateInput
  }

  export type bankScalarWhereWithAggregatesInput = {
    AND?: bankScalarWhereWithAggregatesInput | bankScalarWhereWithAggregatesInput[]
    OR?: bankScalarWhereWithAggregatesInput[]
    NOT?: bankScalarWhereWithAggregatesInput | bankScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"bank"> | string
    name?: StringWithAggregatesFilter<"bank"> | string
    currency?: StringWithAggregatesFilter<"bank"> | string
    isActive?: BoolWithAggregatesFilter<"bank"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"bank"> | Date | string
    operatorId?: StringWithAggregatesFilter<"bank"> | string
  }

  export type chatmessageWhereInput = {
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    id?: StringFilter<"chatmessage"> | string
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type chatmessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    chatroom?: chatroomOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type chatmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type chatmessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    _count?: chatmessageCountOrderByAggregateInput
    _max?: chatmessageMaxOrderByAggregateInput
    _min?: chatmessageMinOrderByAggregateInput
  }

  export type chatmessageScalarWhereWithAggregatesInput = {
    AND?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    OR?: chatmessageScalarWhereWithAggregatesInput[]
    NOT?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chatmessage"> | string
    content?: StringWithAggregatesFilter<"chatmessage"> | string
    channel?: EnumChatChannelWithAggregatesFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableWithAggregatesFilter<"chatmessage">
    createdAt?: DateTimeWithAggregatesFilter<"chatmessage"> | Date | string
    userId?: StringWithAggregatesFilter<"chatmessage"> | string
    roomId?: StringNullableWithAggregatesFilter<"chatmessage"> | string | null
  }

  export type chatroomWhereInput = {
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    id?: StringFilter<"chatroom"> | string
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
  }

  export type chatroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    chatmessage?: chatmessageOrderByRelationAggregateInput
    gamesession?: gamesessionOrderByWithRelationInput
  }

  export type chatroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
  }, "id">

  export type chatroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    _count?: chatroomCountOrderByAggregateInput
    _max?: chatroomMaxOrderByAggregateInput
    _min?: chatroomMinOrderByAggregateInput
  }

  export type chatroomScalarWhereWithAggregatesInput = {
    AND?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    OR?: chatroomScalarWhereWithAggregatesInput[]
    NOT?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chatroom"> | string
    name?: StringWithAggregatesFilter<"chatroom"> | string
    isGameRoom?: BoolWithAggregatesFilter<"chatroom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableWithAggregatesFilter<"chatroom"> | string | null
  }

  export type friendshipWhereInput = {
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    id?: StringFilter<"friendship"> | string
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
    user_friendship_friendIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    user_friendship_userIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type friendshipOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    user_friendship_friendIdTouser?: userOrderByWithRelationInput
    user_friendship_userIdTouser?: userOrderByWithRelationInput
  }

  export type friendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_friendId?: friendshipUserIdFriendIdCompoundUniqueInput
    AND?: friendshipWhereInput | friendshipWhereInput[]
    OR?: friendshipWhereInput[]
    NOT?: friendshipWhereInput | friendshipWhereInput[]
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
    user_friendship_friendIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    user_friendship_userIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId_friendId">

  export type friendshipOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
    _count?: friendshipCountOrderByAggregateInput
    _max?: friendshipMaxOrderByAggregateInput
    _min?: friendshipMinOrderByAggregateInput
  }

  export type friendshipScalarWhereWithAggregatesInput = {
    AND?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    OR?: friendshipScalarWhereWithAggregatesInput[]
    NOT?: friendshipScalarWhereWithAggregatesInput | friendshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"friendship"> | string
    status?: EnumFriendshipStatusWithAggregatesFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"friendship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"friendship"> | Date | string
    userId?: StringWithAggregatesFilter<"friendship"> | string
    friendId?: StringWithAggregatesFilter<"friendship"> | string
  }

  export type gamesessionWhereInput = {
    AND?: gamesessionWhereInput | gamesessionWhereInput[]
    OR?: gamesessionWhereInput[]
    NOT?: gamesessionWhereInput | gamesessionWhereInput[]
    id?: StringFilter<"gamesession"> | string
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    winAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
    chatroom?: ChatroomListRelationFilter
    operatorgame?: XOR<OperatorgameScalarRelationFilter, operatorgameWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, tournamentWhereInput> | null
    transaction?: TransactionListRelationFilter
  }

  export type gamesessionOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    chatroom?: chatroomOrderByRelationAggregateInput
    operatorgame?: operatorgameOrderByWithRelationInput
    profile?: profileOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
    transaction?: transactionOrderByRelationAggregateInput
  }

  export type gamesessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: gamesessionWhereInput | gamesessionWhereInput[]
    OR?: gamesessionWhereInput[]
    NOT?: gamesessionWhereInput | gamesessionWhereInput[]
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    winAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
    chatroom?: ChatroomListRelationFilter
    operatorgame?: XOR<OperatorgameScalarRelationFilter, operatorgameWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tournament?: XOR<TournamentNullableScalarRelationFilter, tournamentWhereInput> | null
    transaction?: TransactionListRelationFilter
  }, "id">

  export type gamesessionOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    betAmount?: SortOrderInput | SortOrder
    winAmount?: SortOrderInput | SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrderInput | SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrderInput | SortOrder
    active?: SortOrder
    profileId?: SortOrder
    _count?: gamesessionCountOrderByAggregateInput
    _avg?: gamesessionAvgOrderByAggregateInput
    _max?: gamesessionMaxOrderByAggregateInput
    _min?: gamesessionMinOrderByAggregateInput
    _sum?: gamesessionSumOrderByAggregateInput
  }

  export type gamesessionScalarWhereWithAggregatesInput = {
    AND?: gamesessionScalarWhereWithAggregatesInput | gamesessionScalarWhereWithAggregatesInput[]
    OR?: gamesessionScalarWhereWithAggregatesInput[]
    NOT?: gamesessionScalarWhereWithAggregatesInput | gamesessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"gamesession"> | string
    startTime?: DateTimeWithAggregatesFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"gamesession"> | Date | string | null
    betAmount?: DecimalNullableWithAggregatesFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    winAmount?: DecimalNullableWithAggregatesFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntWithAggregatesFilter<"gamesession"> | number
    metadata?: JsonNullableWithAggregatesFilter<"gamesession">
    gameId?: StringWithAggregatesFilter<"gamesession"> | string
    tournamentId?: StringNullableWithAggregatesFilter<"gamesession"> | string | null
    active?: BoolWithAggregatesFilter<"gamesession"> | boolean
    profileId?: StringWithAggregatesFilter<"gamesession"> | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: StringFilter<"notification"> | string
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"notification"> | string
    message?: StringWithAggregatesFilter<"notification"> | string
    isRead?: BoolWithAggregatesFilter<"notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"notification">
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    userId?: StringWithAggregatesFilter<"notification"> | string
  }

  export type operatorWhereInput = {
    AND?: operatorWhereInput | operatorWhereInput[]
    OR?: operatorWhereInput[]
    NOT?: operatorWhereInput | operatorWhereInput[]
    id?: StringFilter<"operator"> | string
    name?: StringFilter<"operator"> | string
    slug?: StringFilter<"operator"> | string
    logo?: StringNullableFilter<"operator"> | string | null
    description?: StringNullableFilter<"operator"> | string | null
    isActive?: BoolFilter<"operator"> | boolean
    createdAt?: DateTimeFilter<"operator"> | Date | string
    updatedAt?: DateTimeFilter<"operator"> | Date | string
    ownerId?: StringFilter<"operator"> | string
    bank?: BankListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    operatorgame?: OperatorgameListRelationFilter
    profile?: ProfileListRelationFilter
    tournament?: TournamentListRelationFilter
  }

  export type operatorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    bank?: bankOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    operatorgame?: operatorgameOrderByRelationAggregateInput
    profile?: profileOrderByRelationAggregateInput
    tournament?: tournamentOrderByRelationAggregateInput
  }

  export type operatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: operatorWhereInput | operatorWhereInput[]
    OR?: operatorWhereInput[]
    NOT?: operatorWhereInput | operatorWhereInput[]
    name?: StringFilter<"operator"> | string
    logo?: StringNullableFilter<"operator"> | string | null
    description?: StringNullableFilter<"operator"> | string | null
    isActive?: BoolFilter<"operator"> | boolean
    createdAt?: DateTimeFilter<"operator"> | Date | string
    updatedAt?: DateTimeFilter<"operator"> | Date | string
    ownerId?: StringFilter<"operator"> | string
    bank?: BankListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    operatorgame?: OperatorgameListRelationFilter
    profile?: ProfileListRelationFilter
    tournament?: TournamentListRelationFilter
  }, "id" | "slug">

  export type operatorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
    _count?: operatorCountOrderByAggregateInput
    _max?: operatorMaxOrderByAggregateInput
    _min?: operatorMinOrderByAggregateInput
  }

  export type operatorScalarWhereWithAggregatesInput = {
    AND?: operatorScalarWhereWithAggregatesInput | operatorScalarWhereWithAggregatesInput[]
    OR?: operatorScalarWhereWithAggregatesInput[]
    NOT?: operatorScalarWhereWithAggregatesInput | operatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"operator"> | string
    name?: StringWithAggregatesFilter<"operator"> | string
    slug?: StringWithAggregatesFilter<"operator"> | string
    logo?: StringNullableWithAggregatesFilter<"operator"> | string | null
    description?: StringNullableWithAggregatesFilter<"operator"> | string | null
    isActive?: BoolWithAggregatesFilter<"operator"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"operator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"operator"> | Date | string
    ownerId?: StringWithAggregatesFilter<"operator"> | string
  }

  export type operatorgameWhereInput = {
    AND?: operatorgameWhereInput | operatorgameWhereInput[]
    OR?: operatorgameWhereInput[]
    NOT?: operatorgameWhereInput | operatorgameWhereInput[]
    id?: StringFilter<"operatorgame"> | string
    name?: StringFilter<"operatorgame"> | string
    slug?: StringFilter<"operatorgame"> | string
    description?: StringNullableFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"operatorgame"> | string | null
    minBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    maxBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFilter<"operatorgame"> | number
    isActive?: BoolFilter<"operatorgame"> | boolean
    isPromoted?: BoolFilter<"operatorgame"> | boolean
    createdAt?: DateTimeFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeFilter<"operatorgame"> | Date | string
    operatorId?: StringFilter<"operatorgame"> | string
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type operatorgameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    gamesession?: gamesessionOrderByRelationAggregateInput
    operator?: operatorOrderByWithRelationInput
    tournamentgame?: tournamentgameOrderByRelationAggregateInput
  }

  export type operatorgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: operatorgameWhereInput | operatorgameWhereInput[]
    OR?: operatorgameWhereInput[]
    NOT?: operatorgameWhereInput | operatorgameWhereInput[]
    name?: StringFilter<"operatorgame"> | string
    description?: StringNullableFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"operatorgame"> | string | null
    minBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    maxBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFilter<"operatorgame"> | number
    isActive?: BoolFilter<"operatorgame"> | boolean
    isPromoted?: BoolFilter<"operatorgame"> | boolean
    createdAt?: DateTimeFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeFilter<"operatorgame"> | Date | string
    operatorId?: StringFilter<"operatorgame"> | string
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    tournamentgame?: TournamentgameListRelationFilter
  }, "id" | "slug">

  export type operatorgameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    minBet?: SortOrderInput | SortOrder
    maxBet?: SortOrderInput | SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    _count?: operatorgameCountOrderByAggregateInput
    _avg?: operatorgameAvgOrderByAggregateInput
    _max?: operatorgameMaxOrderByAggregateInput
    _min?: operatorgameMinOrderByAggregateInput
    _sum?: operatorgameSumOrderByAggregateInput
  }

  export type operatorgameScalarWhereWithAggregatesInput = {
    AND?: operatorgameScalarWhereWithAggregatesInput | operatorgameScalarWhereWithAggregatesInput[]
    OR?: operatorgameScalarWhereWithAggregatesInput[]
    NOT?: operatorgameScalarWhereWithAggregatesInput | operatorgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"operatorgame"> | string
    name?: StringWithAggregatesFilter<"operatorgame"> | string
    slug?: StringWithAggregatesFilter<"operatorgame"> | string
    description?: StringNullableWithAggregatesFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"operatorgame"> | string | null
    minBet?: DecimalNullableWithAggregatesFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    maxBet?: DecimalNullableWithAggregatesFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatWithAggregatesFilter<"operatorgame"> | number
    isActive?: BoolWithAggregatesFilter<"operatorgame"> | boolean
    isPromoted?: BoolWithAggregatesFilter<"operatorgame"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"operatorgame"> | Date | string
    operatorId?: StringWithAggregatesFilter<"operatorgame"> | string
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    id?: StringFilter<"profile"> | string
    profileNumber?: StringFilter<"profile"> | string
    balance?: IntFilter<"profile"> | number
    xpEarned?: IntFilter<"profile"> | number
    isActive?: BoolFilter<"profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"profile"> | Date | string | null
    createdAt?: DateTimeFilter<"profile"> | Date | string
    updatedAt?: DateTimeFilter<"profile"> | Date | string
    phpId?: IntNullableFilter<"profile"> | number | null
    userId?: StringFilter<"profile"> | string
    bankId?: StringFilter<"profile"> | string
    shopId?: StringFilter<"profile"> | string
    gamesession?: GamesessionListRelationFilter
    bank?: XOR<BankScalarRelationFilter, bankWhereInput>
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    user_profile_userIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    tournamententry?: TournamententryListRelationFilter
    transaction?: TransactionListRelationFilter
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    profileNumber?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    bankId?: SortOrder
    shopId?: SortOrder
    gamesession?: gamesessionOrderByRelationAggregateInput
    bank?: bankOrderByWithRelationInput
    operator?: operatorOrderByWithRelationInput
    user_profile_userIdTouser?: userOrderByWithRelationInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    transaction?: transactionOrderByRelationAggregateInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileNumber?: string
    phpId?: number
    userId_shopId?: profileUserIdShopIdCompoundUniqueInput
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    balance?: IntFilter<"profile"> | number
    xpEarned?: IntFilter<"profile"> | number
    isActive?: BoolFilter<"profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"profile"> | Date | string | null
    createdAt?: DateTimeFilter<"profile"> | Date | string
    updatedAt?: DateTimeFilter<"profile"> | Date | string
    userId?: StringFilter<"profile"> | string
    bankId?: StringFilter<"profile"> | string
    shopId?: StringFilter<"profile"> | string
    gamesession?: GamesessionListRelationFilter
    bank?: XOR<BankScalarRelationFilter, bankWhereInput>
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    user_profile_userIdTouser?: XOR<UserScalarRelationFilter, userWhereInput>
    tournamententry?: TournamententryListRelationFilter
    transaction?: TransactionListRelationFilter
  }, "id" | "profileNumber" | "phpId" | "userId_shopId">

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    profileNumber?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrderInput | SortOrder
    userId?: SortOrder
    bankId?: SortOrder
    shopId?: SortOrder
    _count?: profileCountOrderByAggregateInput
    _avg?: profileAvgOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
    _sum?: profileSumOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profile"> | string
    profileNumber?: StringWithAggregatesFilter<"profile"> | string
    balance?: IntWithAggregatesFilter<"profile"> | number
    xpEarned?: IntWithAggregatesFilter<"profile"> | number
    isActive?: BoolWithAggregatesFilter<"profile"> | boolean
    lastPlayed?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"profile"> | Date | string
    phpId?: IntNullableWithAggregatesFilter<"profile"> | number | null
    userId?: StringWithAggregatesFilter<"profile"> | string
    bankId?: StringWithAggregatesFilter<"profile"> | string
    shopId?: StringWithAggregatesFilter<"profile"> | string
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    id?: StringFilter<"session"> | string
    userId?: StringFilter<"session"> | string
    activeGameId?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    refreshToken?: StringFilter<"session"> | string
    active?: BoolFilter<"session"> | boolean
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type sessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refreshToken?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    userId?: StringFilter<"session"> | string
    activeGameId?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    active?: BoolFilter<"session"> | boolean
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "refreshToken">

  export type sessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"session"> | string
    userId?: StringWithAggregatesFilter<"session"> | string
    activeGameId?: StringNullableWithAggregatesFilter<"session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string
    refreshToken?: StringWithAggregatesFilter<"session"> | string
    active?: BoolWithAggregatesFilter<"session"> | boolean
  }

  export type tournamentWhereInput = {
    AND?: tournamentWhereInput | tournamentWhereInput[]
    OR?: tournamentWhereInput[]
    NOT?: tournamentWhereInput | tournamentWhereInput[]
    id?: StringFilter<"tournament"> | string
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: DecimalNullableFilter<"tournament"> | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFilter<"tournament"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeFilter<"tournament"> | Date | string
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }

  export type tournamentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    gamesession?: gamesessionOrderByRelationAggregateInput
    operator?: operatorOrderByWithRelationInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    tournamentgame?: tournamentgameOrderByRelationAggregateInput
  }

  export type tournamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tournamentWhereInput | tournamentWhereInput[]
    OR?: tournamentWhereInput[]
    NOT?: tournamentWhereInput | tournamentWhereInput[]
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: DecimalNullableFilter<"tournament"> | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFilter<"tournament"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeFilter<"tournament"> | Date | string
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
    gamesession?: GamesessionListRelationFilter
    operator?: XOR<OperatorScalarRelationFilter, operatorWhereInput>
    tournamententry?: TournamententryListRelationFilter
    tournamentgame?: TournamentgameListRelationFilter
  }, "id">

  export type tournamentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrderInput | SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrderInput | SortOrder
    _count?: tournamentCountOrderByAggregateInput
    _avg?: tournamentAvgOrderByAggregateInput
    _max?: tournamentMaxOrderByAggregateInput
    _min?: tournamentMinOrderByAggregateInput
    _sum?: tournamentSumOrderByAggregateInput
  }

  export type tournamentScalarWhereWithAggregatesInput = {
    AND?: tournamentScalarWhereWithAggregatesInput | tournamentScalarWhereWithAggregatesInput[]
    OR?: tournamentScalarWhereWithAggregatesInput[]
    NOT?: tournamentScalarWhereWithAggregatesInput | tournamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournament"> | string
    name?: StringWithAggregatesFilter<"tournament"> | string
    description?: StringNullableWithAggregatesFilter<"tournament"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    entryFee?: DecimalNullableWithAggregatesFilter<"tournament"> | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalWithAggregatesFilter<"tournament"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"tournament"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tournament"> | Date | string
    operatorId?: StringWithAggregatesFilter<"tournament"> | string
    leaderboard?: JsonNullableWithAggregatesFilter<"tournament">
  }

  export type tournamententryWhereInput = {
    AND?: tournamententryWhereInput | tournamententryWhereInput[]
    OR?: tournamententryWhereInput[]
    NOT?: tournamententryWhereInput | tournamententryWhereInput[]
    id?: StringFilter<"tournamententry"> | string
    score?: IntFilter<"tournamententry"> | number
    wagered?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    won?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type tournamententryOrderByWithRelationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    profile?: profileOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type tournamententryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tournamentId?: tournamententryUserIdTournamentIdCompoundUniqueInput
    AND?: tournamententryWhereInput | tournamententryWhereInput[]
    OR?: tournamententryWhereInput[]
    NOT?: tournamententryWhereInput | tournamententryWhereInput[]
    score?: IntFilter<"tournamententry"> | number
    wagered?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    won?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId_tournamentId">

  export type tournamententryOrderByWithAggregationInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
    _count?: tournamententryCountOrderByAggregateInput
    _avg?: tournamententryAvgOrderByAggregateInput
    _max?: tournamententryMaxOrderByAggregateInput
    _min?: tournamententryMinOrderByAggregateInput
    _sum?: tournamententrySumOrderByAggregateInput
  }

  export type tournamententryScalarWhereWithAggregatesInput = {
    AND?: tournamententryScalarWhereWithAggregatesInput | tournamententryScalarWhereWithAggregatesInput[]
    OR?: tournamententryScalarWhereWithAggregatesInput[]
    NOT?: tournamententryScalarWhereWithAggregatesInput | tournamententryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournamententry"> | string
    score?: IntWithAggregatesFilter<"tournamententry"> | number
    wagered?: DecimalWithAggregatesFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    won?: DecimalWithAggregatesFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeWithAggregatesFilter<"tournamententry"> | Date | string
    userId?: StringWithAggregatesFilter<"tournamententry"> | string
    tournamentId?: StringWithAggregatesFilter<"tournamententry"> | string
    profileId?: StringWithAggregatesFilter<"tournamententry"> | string
  }

  export type tournamentgameWhereInput = {
    AND?: tournamentgameWhereInput | tournamentgameWhereInput[]
    OR?: tournamentgameWhereInput[]
    NOT?: tournamentgameWhereInput | tournamentgameWhereInput[]
    id?: StringFilter<"tournamentgame"> | string
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
    operatorgame?: XOR<OperatorgameScalarRelationFilter, operatorgameWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
  }

  export type tournamentgameOrderByWithRelationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    operatorgame?: operatorgameOrderByWithRelationInput
    tournament?: tournamentOrderByWithRelationInput
  }

  export type tournamentgameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tournamentId_gameId?: tournamentgameTournamentIdGameIdCompoundUniqueInput
    AND?: tournamentgameWhereInput | tournamentgameWhereInput[]
    OR?: tournamentgameWhereInput[]
    NOT?: tournamentgameWhereInput | tournamentgameWhereInput[]
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
    operatorgame?: XOR<OperatorgameScalarRelationFilter, operatorgameWhereInput>
    tournament?: XOR<TournamentScalarRelationFilter, tournamentWhereInput>
  }, "id" | "tournamentId_gameId">

  export type tournamentgameOrderByWithAggregationInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
    _count?: tournamentgameCountOrderByAggregateInput
    _avg?: tournamentgameAvgOrderByAggregateInput
    _max?: tournamentgameMaxOrderByAggregateInput
    _min?: tournamentgameMinOrderByAggregateInput
    _sum?: tournamentgameSumOrderByAggregateInput
  }

  export type tournamentgameScalarWhereWithAggregatesInput = {
    AND?: tournamentgameScalarWhereWithAggregatesInput | tournamentgameScalarWhereWithAggregatesInput[]
    OR?: tournamentgameScalarWhereWithAggregatesInput[]
    NOT?: tournamentgameScalarWhereWithAggregatesInput | tournamentgameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"tournamentgame"> | string
    multiplier?: FloatWithAggregatesFilter<"tournamentgame"> | number
    tournamentId?: StringWithAggregatesFilter<"tournamentgame"> | string
    gameId?: StringWithAggregatesFilter<"tournamentgame"> | string
  }

  export type transactionWhereInput = {
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    id?: StringFilter<"transaction"> | string
    type?: EnumTransactionTypeFilter<"transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"transaction"> | string | null
    status?: EnumTransactionStatusFilter<"transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"transaction">
    isRealMoney?: BoolFilter<"transaction"> | boolean
    paymentMethod?: StringNullableFilter<"transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"transaction">
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"transaction"> | string | null
    profileId?: StringFilter<"transaction"> | string
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }

  export type transactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrder
    gamesession?: gamesessionOrderByWithRelationInput
    profile?: profileOrderByWithRelationInput
  }

  export type transactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionWhereInput | transactionWhereInput[]
    OR?: transactionWhereInput[]
    NOT?: transactionWhereInput | transactionWhereInput[]
    type?: EnumTransactionTypeFilter<"transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"transaction"> | string | null
    status?: EnumTransactionStatusFilter<"transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"transaction">
    isRealMoney?: BoolFilter<"transaction"> | boolean
    paymentMethod?: StringNullableFilter<"transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"transaction">
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"transaction"> | string | null
    profileId?: StringFilter<"transaction"> | string
    gamesession?: XOR<GamesessionNullableScalarRelationFilter, gamesessionWhereInput> | null
    profile?: XOR<ProfileScalarRelationFilter, profileWhereInput>
  }, "id">

  export type transactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    gameSessionId?: SortOrderInput | SortOrder
    profileId?: SortOrder
    _count?: transactionCountOrderByAggregateInput
    _avg?: transactionAvgOrderByAggregateInput
    _max?: transactionMaxOrderByAggregateInput
    _min?: transactionMinOrderByAggregateInput
    _sum?: transactionSumOrderByAggregateInput
  }

  export type transactionScalarWhereWithAggregatesInput = {
    AND?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    OR?: transactionScalarWhereWithAggregatesInput[]
    NOT?: transactionScalarWhereWithAggregatesInput | transactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"transaction"> | $Enums.TransactionType
    amount?: DecimalWithAggregatesFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableWithAggregatesFilter<"transaction">
    isRealMoney?: BoolWithAggregatesFilter<"transaction"> | boolean
    paymentMethod?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    paymentDetails?: JsonNullableWithAggregatesFilter<"transaction">
    createdAt?: DateTimeWithAggregatesFilter<"transaction"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"transaction"> | Date | string | null
    gameSessionId?: StringNullableWithAggregatesFilter<"transaction"> | string | null
    profileId?: StringWithAggregatesFilter<"transaction"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    passwordHash?: StringFilter<"user"> | string
    avatar?: StringNullableFilter<"user"> | string | null
    totalXp?: IntFilter<"user"> | number
    balance?: DecimalFilter<"user"> | Decimal | DecimalJsLike | number | string
    lastLogin?: DateTimeNullableFilter<"user"> | Date | string | null
    isVerified?: BoolFilter<"user"> | boolean
    verificationToken?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    active?: BoolFilter<"user"> | boolean
    activeProfileId?: StringNullableFilter<"user"> | string | null
    gender?: EnumGenderNullableFilter<"user"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"user"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"user"> | string | null
    phpId?: IntNullableFilter<"user"> | number | null
    accessToken?: StringNullableFilter<"user"> | string | null
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendship_friendship_friendIdTouser?: FriendshipListRelationFilter
    friendship_friendship_userIdTouser?: FriendshipListRelationFilter
    notification?: NotificationListRelationFilter
    operator?: OperatorListRelationFilter
    profile_profile_userIdTouser?: ProfileListRelationFilter
    session?: SessionListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    userachievement?: UserachievementListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    RainBet?: RainBetOrderByRelationAggregateInput
    RainHistory?: RainHistoryOrderByRelationAggregateInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
    chatmessage?: chatmessageOrderByRelationAggregateInput
    friendship_friendship_friendIdTouser?: friendshipOrderByRelationAggregateInput
    friendship_friendship_userIdTouser?: friendshipOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    operator?: operatorOrderByRelationAggregateInput
    profile_profile_userIdTouser?: profileOrderByRelationAggregateInput
    session?: sessionOrderByRelationAggregateInput
    tournamententry?: tournamententryOrderByRelationAggregateInput
    userachievement?: userachievementOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    activeProfileId?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    passwordHash?: StringFilter<"user"> | string
    avatar?: StringNullableFilter<"user"> | string | null
    totalXp?: IntFilter<"user"> | number
    balance?: DecimalFilter<"user"> | Decimal | DecimalJsLike | number | string
    lastLogin?: DateTimeNullableFilter<"user"> | Date | string | null
    isVerified?: BoolFilter<"user"> | boolean
    verificationToken?: StringNullableFilter<"user"> | string | null
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    active?: BoolFilter<"user"> | boolean
    gender?: EnumGenderNullableFilter<"user"> | $Enums.Gender | null
    status?: EnumUserStatusNullableFilter<"user"> | $Enums.UserStatus | null
    cashtag?: StringNullableFilter<"user"> | string | null
    phpId?: IntNullableFilter<"user"> | number | null
    accessToken?: StringNullableFilter<"user"> | string | null
    RainBet?: RainBetListRelationFilter
    RainHistory?: RainHistoryListRelationFilter
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    friendship_friendship_friendIdTouser?: FriendshipListRelationFilter
    friendship_friendship_userIdTouser?: FriendshipListRelationFilter
    notification?: NotificationListRelationFilter
    operator?: OperatorListRelationFilter
    profile_profile_userIdTouser?: ProfileListRelationFilter
    session?: SessionListRelationFilter
    tournamententry?: TournamententryListRelationFilter
    userachievement?: UserachievementListRelationFilter
  }, "id" | "username" | "email" | "activeProfileId">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrderInput | SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    activeProfileId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    cashtag?: SortOrderInput | SortOrder
    phpId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    username?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    passwordHash?: StringWithAggregatesFilter<"user"> | string
    avatar?: StringNullableWithAggregatesFilter<"user"> | string | null
    totalXp?: IntWithAggregatesFilter<"user"> | number
    balance?: DecimalWithAggregatesFilter<"user"> | Decimal | DecimalJsLike | number | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"user"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"user"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    active?: BoolWithAggregatesFilter<"user"> | boolean
    activeProfileId?: StringNullableWithAggregatesFilter<"user"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"user"> | $Enums.Gender | null
    status?: EnumUserStatusNullableWithAggregatesFilter<"user"> | $Enums.UserStatus | null
    cashtag?: StringNullableWithAggregatesFilter<"user"> | string | null
    phpId?: IntNullableWithAggregatesFilter<"user"> | number | null
    accessToken?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type userachievementWhereInput = {
    AND?: userachievementWhereInput | userachievementWhereInput[]
    OR?: userachievementWhereInput[]
    NOT?: userachievementWhereInput | userachievementWhereInput[]
    id?: StringFilter<"userachievement"> | string
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeFilter<"userachievement"> | Date | string
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
    achievement?: XOR<AchievementScalarRelationFilter, achievementWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userachievementOrderByWithRelationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievement?: achievementOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userachievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: userachievementUserIdAchievementIdCompoundUniqueInput
    AND?: userachievementWhereInput | userachievementWhereInput[]
    OR?: userachievementWhereInput[]
    NOT?: userachievementWhereInput | userachievementWhereInput[]
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeFilter<"userachievement"> | Date | string
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
    achievement?: XOR<AchievementScalarRelationFilter, achievementWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id" | "userId_achievementId">

  export type userachievementOrderByWithAggregationInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    _count?: userachievementCountOrderByAggregateInput
    _avg?: userachievementAvgOrderByAggregateInput
    _max?: userachievementMaxOrderByAggregateInput
    _min?: userachievementMinOrderByAggregateInput
    _sum?: userachievementSumOrderByAggregateInput
  }

  export type userachievementScalarWhereWithAggregatesInput = {
    AND?: userachievementScalarWhereWithAggregatesInput | userachievementScalarWhereWithAggregatesInput[]
    OR?: userachievementScalarWhereWithAggregatesInput[]
    NOT?: userachievementScalarWhereWithAggregatesInput | userachievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"userachievement"> | string
    progress?: IntWithAggregatesFilter<"userachievement"> | number
    isUnlocked?: BoolWithAggregatesFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"userachievement"> | Date | string
    userId?: StringWithAggregatesFilter<"userachievement"> | string
    achievementId?: StringWithAggregatesFilter<"userachievement"> | string
  }

  export type RainBetWhereInput = {
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    odds?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type RainBetOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type RainBetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainBetWhereInput | RainBetWhereInput[]
    OR?: RainBetWhereInput[]
    NOT?: RainBetWhereInput | RainBetWhereInput[]
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    odds?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type RainBetOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrderInput | SortOrder
    settledAt?: SortOrderInput | SortOrder
    _count?: RainBetCountOrderByAggregateInput
    _avg?: RainBetAvgOrderByAggregateInput
    _max?: RainBetMaxOrderByAggregateInput
    _min?: RainBetMinOrderByAggregateInput
    _sum?: RainBetSumOrderByAggregateInput
  }

  export type RainBetScalarWhereWithAggregatesInput = {
    AND?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    OR?: RainBetScalarWhereWithAggregatesInput[]
    NOT?: RainBetScalarWhereWithAggregatesInput | RainBetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainBet"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainBet"> | string
    userId?: StringWithAggregatesFilter<"RainBet"> | string
    betAmount?: DecimalWithAggregatesFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    odds?: DecimalWithAggregatesFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    outcome?: StringNullableWithAggregatesFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableWithAggregatesFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryWhereInput = {
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: DecimalFilter<"RainHistory"> | Decimal | DecimalJsLike | number | string
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }

  export type RainHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    RainBet?: RainBetOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    RainTip?: RainTipOrderByRelationAggregateInput
    RainWinner?: RainWinnerOrderByRelationAggregateInput
  }

  export type RainHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainHistoryWhereInput | RainHistoryWhereInput[]
    OR?: RainHistoryWhereInput[]
    NOT?: RainHistoryWhereInput | RainHistoryWhereInput[]
    userId?: StringFilter<"RainHistory"> | string
    amount?: DecimalFilter<"RainHistory"> | Decimal | DecimalJsLike | number | string
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
    RainBet?: RainBetListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    RainTip?: RainTipListRelationFilter
    RainWinner?: RainWinnerListRelationFilter
  }, "id">

  export type RainHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
    _count?: RainHistoryCountOrderByAggregateInput
    _avg?: RainHistoryAvgOrderByAggregateInput
    _max?: RainHistoryMaxOrderByAggregateInput
    _min?: RainHistoryMinOrderByAggregateInput
    _sum?: RainHistorySumOrderByAggregateInput
  }

  export type RainHistoryScalarWhereWithAggregatesInput = {
    AND?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    OR?: RainHistoryScalarWhereWithAggregatesInput[]
    NOT?: RainHistoryScalarWhereWithAggregatesInput | RainHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainHistory"> | string
    userId?: StringWithAggregatesFilter<"RainHistory"> | string
    amount?: DecimalWithAggregatesFilter<"RainHistory"> | Decimal | DecimalJsLike | number | string
    rainType?: StringWithAggregatesFilter<"RainHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RainHistory"> | Date | string
  }

  export type RainTipWhereInput = {
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: DecimalFilter<"RainTip"> | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type RainTipOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type RainTipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainTipWhereInput | RainTipWhereInput[]
    OR?: RainTipWhereInput[]
    NOT?: RainTipWhereInput | RainTipWhereInput[]
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: DecimalFilter<"RainTip"> | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type RainTipOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
    _count?: RainTipCountOrderByAggregateInput
    _avg?: RainTipAvgOrderByAggregateInput
    _max?: RainTipMaxOrderByAggregateInput
    _min?: RainTipMinOrderByAggregateInput
    _sum?: RainTipSumOrderByAggregateInput
  }

  export type RainTipScalarWhereWithAggregatesInput = {
    AND?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    OR?: RainTipScalarWhereWithAggregatesInput[]
    NOT?: RainTipScalarWhereWithAggregatesInput | RainTipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainTip"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainTip"> | string
    userId?: StringWithAggregatesFilter<"RainTip"> | string
    tipAmount?: DecimalWithAggregatesFilter<"RainTip"> | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeWithAggregatesFilter<"RainTip"> | Date | string
  }

  export type RainWinnerWhereInput = {
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: DecimalFilter<"RainWinner"> | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type RainWinnerOrderByWithRelationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    RainHistory?: RainHistoryOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type RainWinnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RainWinnerWhereInput | RainWinnerWhereInput[]
    OR?: RainWinnerWhereInput[]
    NOT?: RainWinnerWhereInput | RainWinnerWhereInput[]
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: DecimalFilter<"RainWinner"> | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
    RainHistory?: XOR<RainHistoryScalarRelationFilter, RainHistoryWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type RainWinnerOrderByWithAggregationInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
    _count?: RainWinnerCountOrderByAggregateInput
    _avg?: RainWinnerAvgOrderByAggregateInput
    _max?: RainWinnerMaxOrderByAggregateInput
    _min?: RainWinnerMinOrderByAggregateInput
    _sum?: RainWinnerSumOrderByAggregateInput
  }

  export type RainWinnerScalarWhereWithAggregatesInput = {
    AND?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    OR?: RainWinnerScalarWhereWithAggregatesInput[]
    NOT?: RainWinnerScalarWhereWithAggregatesInput | RainWinnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RainWinner"> | string
    rainHistoryId?: StringWithAggregatesFilter<"RainWinner"> | string
    userId?: StringWithAggregatesFilter<"RainWinner"> | string
    wonAmount?: DecimalWithAggregatesFilter<"RainWinner"> | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeWithAggregatesFilter<"RainWinner"> | Date | string
  }

  export type achievementCreateInput = {
    id: string
    name: string
    description: string
    targetXp: number
    reward?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    userachievement?: userachievementCreateNestedManyWithoutAchievementInput
  }

  export type achievementUncheckedCreateInput = {
    id: string
    name: string
    description: string
    targetXp: number
    reward?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    userachievement?: userachievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type achievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userachievement?: userachievementUpdateManyWithoutAchievementNestedInput
  }

  export type achievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userachievement?: userachievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type achievementCreateManyInput = {
    id: string
    name: string
    description: string
    targetXp: number
    reward?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type achievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type achievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bankCreateInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    operator: operatorCreateNestedOneWithoutBankInput
    profile?: profileCreateNestedManyWithoutBankInput
  }

  export type bankUncheckedCreateInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    operatorId: string
    profile?: profileUncheckedCreateNestedManyWithoutBankInput
  }

  export type bankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: operatorUpdateOneRequiredWithoutBankNestedInput
    profile?: profileUpdateManyWithoutBankNestedInput
  }

  export type bankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    profile?: profileUncheckedUpdateManyWithoutBankNestedInput
  }

  export type bankCreateManyInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    operatorId: string
  }

  export type bankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageCreateInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: chatroomCreateNestedOneWithoutChatmessageInput
    user: userCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type chatmessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: chatroomUpdateOneWithoutChatmessageNestedInput
    user?: userUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatmessageCreateManyInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
    roomId?: string | null
  }

  export type chatmessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatroomCreateInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageCreateNestedManyWithoutChatroomInput
    gamesession?: gamesessionCreateNestedOneWithoutChatroomInput
  }

  export type chatroomUncheckedCreateInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUpdateManyWithoutChatroomNestedInput
    gamesession?: gamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomCreateManyInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type chatroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendshipCreateInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    user_friendship_friendIdTouser: userCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput
    user_friendship_userIdTouser: userCreateNestedOneWithoutFriendship_friendship_userIdTouserInput
  }

  export type friendshipUncheckedCreateInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    friendId: string
  }

  export type friendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_friendIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput
    user_friendship_userIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipCreateManyInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    friendId: string
  }

  export type friendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type friendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type gamesessionCreateInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    operatorgame: operatorgameCreateNestedOneWithoutGamesessionInput
    profile: profileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    transaction?: transactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    transaction?: transactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    operatorgame?: operatorgameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: profileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    transaction?: transactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionCreateManyInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
  }

  export type gamesessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type gamesessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: userCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateManyInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorCreateInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankCreateNestedManyWithoutOperatorInput
    user: userCreateNestedOneWithoutOperatorInput
    operatorgame?: operatorgameCreateNestedManyWithoutOperatorInput
    profile?: profileCreateNestedManyWithoutOperatorInput
    tournament?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
    bank?: bankUncheckedCreateNestedManyWithoutOperatorInput
    operatorgame?: operatorgameUncheckedCreateNestedManyWithoutOperatorInput
    profile?: profileUncheckedCreateNestedManyWithoutOperatorInput
    tournament?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUpdateManyWithoutOperatorNestedInput
    user?: userUpdateOneRequiredWithoutOperatorNestedInput
    operatorgame?: operatorgameUpdateManyWithoutOperatorNestedInput
    profile?: profileUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    bank?: bankUncheckedUpdateManyWithoutOperatorNestedInput
    operatorgame?: operatorgameUncheckedUpdateManyWithoutOperatorNestedInput
    profile?: profileUncheckedUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type operatorCreateManyInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
  }

  export type operatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorgameCreateInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    gamesession?: gamesessionCreateNestedManyWithoutOperatorgameInput
    operator: operatorCreateNestedOneWithoutOperatorgameInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameUncheckedCreateInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutOperatorgameInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUpdateManyWithoutOperatorgameNestedInput
    operator?: operatorUpdateOneRequiredWithoutOperatorgameNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutOperatorgameNestedInput
  }

  export type operatorgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutOperatorgameNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutOperatorgameNestedInput
  }

  export type operatorgameCreateManyInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
  }

  export type operatorgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operatorgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type profileCreateInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    bank: bankCreateNestedOneWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileCreateManyInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    shopId: string
  }

  export type profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionCreateInput = {
    id: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
    user: userCreateNestedOneWithoutSessionInput
  }

  export type sessionUncheckedCreateInput = {
    id: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
  }

  export type sessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionCreateManyInput = {
    id: string
    userId: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
  }

  export type sessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tournamentCreateInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: operatorCreateNestedOneWithoutTournamentInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: operatorUpdateOneRequiredWithoutTournamentNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentCreateManyInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tournamententryCreateInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    profile: profileCreateNestedOneWithoutTournamententryInput
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
    user: userCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type tournamententryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: userUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryCreateManyInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    tournamentId: string
    profileId: string
  }

  export type tournamententryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tournamententryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameCreateInput = {
    id: string
    multiplier?: number
    operatorgame: operatorgameCreateNestedOneWithoutTournamentgameInput
    tournament: tournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateInput = {
    id: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type tournamentgameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    operatorgame?: operatorgameUpdateOneRequiredWithoutTournamentgameNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameCreateManyInput = {
    id: string
    multiplier?: number
    tournamentId: string
    gameId: string
  }

  export type tournamentgameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
  }

  export type tournamentgameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type transactionCreateInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gamesession?: gamesessionCreateNestedOneWithoutTransactionInput
    profile: profileCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId: string
  }

  export type transactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesession?: gamesessionUpdateOneWithoutTransactionNestedInput
    profile?: profileUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type transactionCreateManyInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
    profileId: string
  }

  export type transactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userachievementCreateInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    achievement: achievementCreateNestedOneWithoutUserachievementInput
    user: userCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    achievementId: string
  }

  export type userachievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: achievementUpdateOneRequiredWithoutUserachievementNestedInput
    user?: userUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementCreateManyInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
    achievementId: string
  }

  export type userachievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userachievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateInput = {
    id: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
    user: userCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateInput = {
    id: string
    rainHistoryId: string
    userId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
    user?: userUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetCreateManyInput = {
    id: string
    rainHistoryId: string
    userId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryCreateInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: userCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateInput = {
    id: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: userUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryCreateManyInput = {
    id: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
  }

  export type RainHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateInput = {
    id: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
    user: userCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateInput = {
    id: string
    rainHistoryId: string
    userId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainTipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
    user?: userUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipCreateManyInput = {
    id: string
    rainHistoryId: string
    userId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainTipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateInput = {
    id: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
    user: userCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateInput = {
    id: string
    rainHistoryId: string
    userId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type RainWinnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
    user?: userUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerCreateManyInput = {
    id: string
    rainHistoryId: string
    userId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type RainWinnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserachievementListRelationFilter = {
    every?: userachievementWhereInput
    some?: userachievementWhereInput
    none?: userachievementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type userachievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type achievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementAvgOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type achievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetXp?: SortOrder
    reward?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type achievementSumOrderByAggregateInput = {
    targetXp?: SortOrder
    reward?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OperatorScalarRelationFilter = {
    is?: operatorWhereInput
    isNot?: operatorWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: profileWhereInput
    some?: profileWhereInput
    none?: profileWhereInput
  }

  export type profileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bankOperatorIdNameCompoundUniqueInput = {
    operatorId: string
    name: string
  }

  export type bankCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    operatorId?: SortOrder
  }

  export type bankMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    operatorId?: SortOrder
  }

  export type bankMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    operatorId?: SortOrder
  }

  export type EnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ChatroomNullableScalarRelationFilter = {
    is?: chatroomWhereInput | null
    isNot?: chatroomWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type chatmessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type chatmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type chatmessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    channel?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ChatmessageListRelationFilter = {
    every?: chatmessageWhereInput
    some?: chatmessageWhereInput
    none?: chatmessageWhereInput
  }

  export type GamesessionNullableScalarRelationFilter = {
    is?: gamesessionWhereInput | null
    isNot?: gamesessionWhereInput | null
  }

  export type chatmessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type chatroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type chatroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isGameRoom?: SortOrder
    createdAt?: SortOrder
    gameSessionId?: SortOrder
  }

  export type EnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type friendshipUserIdFriendIdCompoundUniqueInput = {
    userId: string
    friendId: string
  }

  export type friendshipCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type friendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type friendshipMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    friendId?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChatroomListRelationFilter = {
    every?: chatroomWhereInput
    some?: chatroomWhereInput
    none?: chatroomWhereInput
  }

  export type OperatorgameScalarRelationFilter = {
    is?: operatorgameWhereInput
    isNot?: operatorgameWhereInput
  }

  export type ProfileScalarRelationFilter = {
    is?: profileWhereInput
    isNot?: profileWhereInput
  }

  export type TournamentNullableScalarRelationFilter = {
    is?: tournamentWhereInput | null
    isNot?: tournamentWhereInput | null
  }

  export type TransactionListRelationFilter = {
    every?: transactionWhereInput
    some?: transactionWhereInput
    none?: transactionWhereInput
  }

  export type chatroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type gamesessionCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    metadata?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type gamesessionMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
    gameId?: SortOrder
    tournamentId?: SortOrder
    active?: SortOrder
    profileId?: SortOrder
  }

  export type gamesessionSumOrderByAggregateInput = {
    betAmount?: SortOrder
    winAmount?: SortOrder
    xpEarned?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type BankListRelationFilter = {
    every?: bankWhereInput
    some?: bankWhereInput
    none?: bankWhereInput
  }

  export type OperatorgameListRelationFilter = {
    every?: operatorgameWhereInput
    some?: operatorgameWhereInput
    none?: operatorgameWhereInput
  }

  export type TournamentListRelationFilter = {
    every?: tournamentWhereInput
    some?: tournamentWhereInput
    none?: tournamentWhereInput
  }

  export type bankOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorgameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type operatorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type operatorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ownerId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GamesessionListRelationFilter = {
    every?: gamesessionWhereInput
    some?: gamesessionWhereInput
    none?: gamesessionWhereInput
  }

  export type TournamentgameListRelationFilter = {
    every?: tournamentgameWhereInput
    some?: tournamentgameWhereInput
    none?: tournamentgameWhereInput
  }

  export type gamesessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tournamentgameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorgameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameAvgOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type operatorgameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
    isActive?: SortOrder
    isPromoted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type operatorgameSumOrderByAggregateInput = {
    minBet?: SortOrder
    maxBet?: SortOrder
    xpMultiplier?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BankScalarRelationFilter = {
    is?: bankWhereInput
    isNot?: bankWhereInput
  }

  export type TournamententryListRelationFilter = {
    every?: tournamententryWhereInput
    some?: tournamententryWhereInput
    none?: tournamententryWhereInput
  }

  export type tournamententryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profileUserIdShopIdCompoundUniqueInput = {
    userId: string
    shopId: string
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    profileNumber?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    bankId?: SortOrder
    shopId?: SortOrder
  }

  export type profileAvgOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    profileNumber?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    bankId?: SortOrder
    shopId?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    profileNumber?: SortOrder
    balance?: SortOrder
    xpEarned?: SortOrder
    isActive?: SortOrder
    lastPlayed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phpId?: SortOrder
    userId?: SortOrder
    bankId?: SortOrder
    shopId?: SortOrder
  }

  export type profileSumOrderByAggregateInput = {
    balance?: SortOrder
    xpEarned?: SortOrder
    phpId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type sessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    activeGameId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    refreshToken?: SortOrder
    active?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type tournamentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
    leaderboard?: SortOrder
  }

  export type tournamentAvgOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type tournamentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type tournamentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    entryFee?: SortOrder
    prizePool?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    operatorId?: SortOrder
  }

  export type tournamentSumOrderByAggregateInput = {
    entryFee?: SortOrder
    prizePool?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type TournamentScalarRelationFilter = {
    is?: tournamentWhereInput
    isNot?: tournamentWhereInput
  }

  export type tournamententryUserIdTournamentIdCompoundUniqueInput = {
    userId: string
    tournamentId: string
  }

  export type tournamententryCountOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententryAvgOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type tournamententryMaxOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententryMinOrderByAggregateInput = {
    id?: SortOrder
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
    joinedAt?: SortOrder
    userId?: SortOrder
    tournamentId?: SortOrder
    profileId?: SortOrder
  }

  export type tournamententrySumOrderByAggregateInput = {
    score?: SortOrder
    wagered?: SortOrder
    won?: SortOrder
  }

  export type tournamentgameTournamentIdGameIdCompoundUniqueInput = {
    tournamentId: string
    gameId: string
  }

  export type tournamentgameCountOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameAvgOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type tournamentgameMaxOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameMinOrderByAggregateInput = {
    id?: SortOrder
    multiplier?: SortOrder
    tournamentId?: SortOrder
    gameId?: SortOrder
  }

  export type tournamentgameSumOrderByAggregateInput = {
    multiplier?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type transactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    paymentDetails?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type transactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type transactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type transactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    isRealMoney?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    gameSessionId?: SortOrder
    profileId?: SortOrder
  }

  export type transactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type RainBetListRelationFilter = {
    every?: RainBetWhereInput
    some?: RainBetWhereInput
    none?: RainBetWhereInput
  }

  export type RainHistoryListRelationFilter = {
    every?: RainHistoryWhereInput
    some?: RainHistoryWhereInput
    none?: RainHistoryWhereInput
  }

  export type RainTipListRelationFilter = {
    every?: RainTipWhereInput
    some?: RainTipWhereInput
    none?: RainTipWhereInput
  }

  export type RainWinnerListRelationFilter = {
    every?: RainWinnerWhereInput
    some?: RainWinnerWhereInput
    none?: RainWinnerWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: friendshipWhereInput
    some?: friendshipWhereInput
    none?: friendshipWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type OperatorListRelationFilter = {
    every?: operatorWhereInput
    some?: operatorWhereInput
    none?: operatorWhereInput
  }

  export type SessionListRelationFilter = {
    every?: sessionWhereInput
    some?: sessionWhereInput
    none?: sessionWhereInput
  }

  export type RainBetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainTipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RainWinnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type friendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type operatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    lastLogin?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    lastLogin?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    avatar?: SortOrder
    totalXp?: SortOrder
    balance?: SortOrder
    lastLogin?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    active?: SortOrder
    activeProfileId?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    cashtag?: SortOrder
    phpId?: SortOrder
    accessToken?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    totalXp?: SortOrder
    balance?: SortOrder
    phpId?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type AchievementScalarRelationFilter = {
    is?: achievementWhereInput
    isNot?: achievementWhereInput
  }

  export type userachievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type userachievementCountOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type userachievementMaxOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementMinOrderByAggregateInput = {
    id?: SortOrder
    progress?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
  }

  export type userachievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type RainHistoryScalarRelationFilter = {
    is?: RainHistoryWhereInput
    isNot?: RainHistoryWhereInput
  }

  export type RainBetCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetAvgOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainBetMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    betAmount?: SortOrder
    odds?: SortOrder
    outcome?: SortOrder
    settledAt?: SortOrder
  }

  export type RainBetSumOrderByAggregateInput = {
    betAmount?: SortOrder
    odds?: SortOrder
  }

  export type RainHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    rainType?: SortOrder
    createdAt?: SortOrder
  }

  export type RainHistorySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RainTipCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipAvgOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainTipMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    tipAmount?: SortOrder
    tippedAt?: SortOrder
  }

  export type RainTipSumOrderByAggregateInput = {
    tipAmount?: SortOrder
  }

  export type RainWinnerCountOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerAvgOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type RainWinnerMaxOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerMinOrderByAggregateInput = {
    id?: SortOrder
    rainHistoryId?: SortOrder
    userId?: SortOrder
    wonAmount?: SortOrder
    wonAt?: SortOrder
  }

  export type RainWinnerSumOrderByAggregateInput = {
    wonAmount?: SortOrder
  }

  export type userachievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type userachievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userachievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutAchievementInput | userachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutAchievementInput | userachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutAchievementInput | userachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type userachievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput> | userachievementCreateWithoutAchievementInput[] | userachievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutAchievementInput | userachievementCreateOrConnectWithoutAchievementInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutAchievementInput | userachievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: userachievementCreateManyAchievementInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutAchievementInput | userachievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutAchievementInput | userachievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type operatorCreateNestedOneWithoutBankInput = {
    create?: XOR<operatorCreateWithoutBankInput, operatorUncheckedCreateWithoutBankInput>
    connectOrCreate?: operatorCreateOrConnectWithoutBankInput
    connect?: operatorWhereUniqueInput
  }

  export type profileCreateNestedManyWithoutBankInput = {
    create?: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput> | profileCreateWithoutBankInput[] | profileUncheckedCreateWithoutBankInput[]
    connectOrCreate?: profileCreateOrConnectWithoutBankInput | profileCreateOrConnectWithoutBankInput[]
    createMany?: profileCreateManyBankInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutBankInput = {
    create?: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput> | profileCreateWithoutBankInput[] | profileUncheckedCreateWithoutBankInput[]
    connectOrCreate?: profileCreateOrConnectWithoutBankInput | profileCreateOrConnectWithoutBankInput[]
    createMany?: profileCreateManyBankInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type operatorUpdateOneRequiredWithoutBankNestedInput = {
    create?: XOR<operatorCreateWithoutBankInput, operatorUncheckedCreateWithoutBankInput>
    connectOrCreate?: operatorCreateOrConnectWithoutBankInput
    upsert?: operatorUpsertWithoutBankInput
    connect?: operatorWhereUniqueInput
    update?: XOR<XOR<operatorUpdateToOneWithWhereWithoutBankInput, operatorUpdateWithoutBankInput>, operatorUncheckedUpdateWithoutBankInput>
  }

  export type profileUpdateManyWithoutBankNestedInput = {
    create?: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput> | profileCreateWithoutBankInput[] | profileUncheckedCreateWithoutBankInput[]
    connectOrCreate?: profileCreateOrConnectWithoutBankInput | profileCreateOrConnectWithoutBankInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutBankInput | profileUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: profileCreateManyBankInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutBankInput | profileUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: profileUpdateManyWithWhereWithoutBankInput | profileUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutBankNestedInput = {
    create?: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput> | profileCreateWithoutBankInput[] | profileUncheckedCreateWithoutBankInput[]
    connectOrCreate?: profileCreateOrConnectWithoutBankInput | profileCreateOrConnectWithoutBankInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutBankInput | profileUpsertWithWhereUniqueWithoutBankInput[]
    createMany?: profileCreateManyBankInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutBankInput | profileUpdateWithWhereUniqueWithoutBankInput[]
    updateMany?: profileUpdateManyWithWhereWithoutBankInput | profileUpdateManyWithWhereWithoutBankInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type chatroomCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatmessageInput
    connect?: chatroomWhereUniqueInput
  }

  export type userCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<userCreateWithoutChatmessageInput, userUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: userCreateOrConnectWithoutChatmessageInput
    connect?: userWhereUniqueInput
  }

  export type EnumChatChannelFieldUpdateOperationsInput = {
    set?: $Enums.ChatChannel
  }

  export type chatroomUpdateOneWithoutChatmessageNestedInput = {
    create?: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatmessageInput
    upsert?: chatroomUpsertWithoutChatmessageInput
    disconnect?: chatroomWhereInput | boolean
    delete?: chatroomWhereInput | boolean
    connect?: chatroomWhereUniqueInput
    update?: XOR<XOR<chatroomUpdateToOneWithWhereWithoutChatmessageInput, chatroomUpdateWithoutChatmessageInput>, chatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type userUpdateOneRequiredWithoutChatmessageNestedInput = {
    create?: XOR<userCreateWithoutChatmessageInput, userUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: userCreateOrConnectWithoutChatmessageInput
    upsert?: userUpsertWithoutChatmessageInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutChatmessageInput, userUpdateWithoutChatmessageInput>, userUncheckedUpdateWithoutChatmessageInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type chatmessageCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type gamesessionCreateNestedOneWithoutChatroomInput = {
    create?: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutChatroomInput
    connect?: gamesessionWhereUniqueInput
  }

  export type chatmessageUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type chatmessageUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutChatroomInput | chatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutChatroomInput | chatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutChatroomInput | chatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type gamesessionUpdateOneWithoutChatroomNestedInput = {
    create?: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutChatroomInput
    upsert?: gamesessionUpsertWithoutChatroomInput
    disconnect?: gamesessionWhereInput | boolean
    delete?: gamesessionWhereInput | boolean
    connect?: gamesessionWhereUniqueInput
    update?: XOR<XOR<gamesessionUpdateToOneWithWhereWithoutChatroomInput, gamesessionUpdateWithoutChatroomInput>, gamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type chatmessageUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput> | chatmessageCreateWithoutChatroomInput[] | chatmessageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutChatroomInput | chatmessageCreateOrConnectWithoutChatroomInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutChatroomInput | chatmessageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatmessageCreateManyChatroomInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutChatroomInput | chatmessageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutChatroomInput | chatmessageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFriendship_friendship_userIdTouserInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_userIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_userIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendshipStatus
  }

  export type userUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput
    upsert?: userUpsertWithoutFriendship_friendship_friendIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFriendship_friendship_friendIdTouserInput, userUpdateWithoutFriendship_friendship_friendIdTouserInput>, userUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type userUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFriendship_friendship_userIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFriendship_friendship_userIdTouserInput
    upsert?: userUpsertWithoutFriendship_friendship_userIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFriendship_friendship_userIdTouserInput, userUpdateWithoutFriendship_friendship_userIdTouserInput>, userUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type chatroomCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
  }

  export type operatorgameCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<operatorgameCreateWithoutGamesessionInput, operatorgameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: operatorgameCreateOrConnectWithoutGamesessionInput
    connect?: operatorgameWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<profileCreateWithoutGamesessionInput, profileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: profileCreateOrConnectWithoutGamesessionInput
    connect?: profileWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutGamesessionInput = {
    create?: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutGamesessionInput
    connect?: tournamentWhereUniqueInput
  }

  export type transactionCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput> | transactionCreateWithoutGamesessionInput[] | transactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutGamesessionInput | transactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: transactionCreateManyGamesessionInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type chatroomUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutGamesessionInput = {
    create?: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput> | transactionCreateWithoutGamesessionInput[] | transactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutGamesessionInput | transactionCreateOrConnectWithoutGamesessionInput[]
    createMany?: transactionCreateManyGamesessionInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type chatroomUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: chatroomUpsertWithWhereUniqueWithoutGamesessionInput | chatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    set?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    disconnect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    delete?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    update?: chatroomUpdateWithWhereUniqueWithoutGamesessionInput | chatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: chatroomUpdateManyWithWhereWithoutGamesessionInput | chatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
  }

  export type operatorgameUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<operatorgameCreateWithoutGamesessionInput, operatorgameUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: operatorgameCreateOrConnectWithoutGamesessionInput
    upsert?: operatorgameUpsertWithoutGamesessionInput
    connect?: operatorgameWhereUniqueInput
    update?: XOR<XOR<operatorgameUpdateToOneWithWhereWithoutGamesessionInput, operatorgameUpdateWithoutGamesessionInput>, operatorgameUncheckedUpdateWithoutGamesessionInput>
  }

  export type profileUpdateOneRequiredWithoutGamesessionNestedInput = {
    create?: XOR<profileCreateWithoutGamesessionInput, profileUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: profileCreateOrConnectWithoutGamesessionInput
    upsert?: profileUpsertWithoutGamesessionInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutGamesessionInput, profileUpdateWithoutGamesessionInput>, profileUncheckedUpdateWithoutGamesessionInput>
  }

  export type tournamentUpdateOneWithoutGamesessionNestedInput = {
    create?: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutGamesessionInput
    upsert?: tournamentUpsertWithoutGamesessionInput
    disconnect?: tournamentWhereInput | boolean
    delete?: tournamentWhereInput | boolean
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutGamesessionInput, tournamentUpdateWithoutGamesessionInput>, tournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type transactionUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput> | transactionCreateWithoutGamesessionInput[] | transactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutGamesessionInput | transactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutGamesessionInput | transactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: transactionCreateManyGamesessionInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutGamesessionInput | transactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutGamesessionInput | transactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type chatroomUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput> | chatroomCreateWithoutGamesessionInput[] | chatroomUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: chatroomCreateOrConnectWithoutGamesessionInput | chatroomCreateOrConnectWithoutGamesessionInput[]
    upsert?: chatroomUpsertWithWhereUniqueWithoutGamesessionInput | chatroomUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: chatroomCreateManyGamesessionInputEnvelope
    set?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    disconnect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    delete?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    connect?: chatroomWhereUniqueInput | chatroomWhereUniqueInput[]
    update?: chatroomUpdateWithWhereUniqueWithoutGamesessionInput | chatroomUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: chatroomUpdateManyWithWhereWithoutGamesessionInput | chatroomUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutGamesessionNestedInput = {
    create?: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput> | transactionCreateWithoutGamesessionInput[] | transactionUncheckedCreateWithoutGamesessionInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutGamesessionInput | transactionCreateOrConnectWithoutGamesessionInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutGamesessionInput | transactionUpsertWithWhereUniqueWithoutGamesessionInput[]
    createMany?: transactionCreateManyGamesessionInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutGamesessionInput | transactionUpdateWithWhereUniqueWithoutGamesessionInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutGamesessionInput | transactionUpdateManyWithWhereWithoutGamesessionInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutNotificationInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    connect?: userWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type userUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationInput
    upsert?: userUpsertWithoutNotificationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutNotificationInput, userUpdateWithoutNotificationInput>, userUncheckedUpdateWithoutNotificationInput>
  }

  export type bankCreateNestedManyWithoutOperatorInput = {
    create?: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput> | bankCreateWithoutOperatorInput[] | bankUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: bankCreateOrConnectWithoutOperatorInput | bankCreateOrConnectWithoutOperatorInput[]
    createMany?: bankCreateManyOperatorInputEnvelope
    connect?: bankWhereUniqueInput | bankWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutOperatorInput = {
    create?: XOR<userCreateWithoutOperatorInput, userUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: userCreateOrConnectWithoutOperatorInput
    connect?: userWhereUniqueInput
  }

  export type operatorgameCreateNestedManyWithoutOperatorInput = {
    create?: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput> | operatorgameCreateWithoutOperatorInput[] | operatorgameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: operatorgameCreateOrConnectWithoutOperatorInput | operatorgameCreateOrConnectWithoutOperatorInput[]
    createMany?: operatorgameCreateManyOperatorInputEnvelope
    connect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
  }

  export type profileCreateNestedManyWithoutOperatorInput = {
    create?: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput> | profileCreateWithoutOperatorInput[] | profileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: profileCreateOrConnectWithoutOperatorInput | profileCreateOrConnectWithoutOperatorInput[]
    createMany?: profileCreateManyOperatorInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type tournamentCreateNestedManyWithoutOperatorInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
  }

  export type bankUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput> | bankCreateWithoutOperatorInput[] | bankUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: bankCreateOrConnectWithoutOperatorInput | bankCreateOrConnectWithoutOperatorInput[]
    createMany?: bankCreateManyOperatorInputEnvelope
    connect?: bankWhereUniqueInput | bankWhereUniqueInput[]
  }

  export type operatorgameUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput> | operatorgameCreateWithoutOperatorInput[] | operatorgameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: operatorgameCreateOrConnectWithoutOperatorInput | operatorgameCreateOrConnectWithoutOperatorInput[]
    createMany?: operatorgameCreateManyOperatorInputEnvelope
    connect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput> | profileCreateWithoutOperatorInput[] | profileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: profileCreateOrConnectWithoutOperatorInput | profileCreateOrConnectWithoutOperatorInput[]
    createMany?: profileCreateManyOperatorInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type tournamentUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
  }

  export type bankUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput> | bankCreateWithoutOperatorInput[] | bankUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: bankCreateOrConnectWithoutOperatorInput | bankCreateOrConnectWithoutOperatorInput[]
    upsert?: bankUpsertWithWhereUniqueWithoutOperatorInput | bankUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: bankCreateManyOperatorInputEnvelope
    set?: bankWhereUniqueInput | bankWhereUniqueInput[]
    disconnect?: bankWhereUniqueInput | bankWhereUniqueInput[]
    delete?: bankWhereUniqueInput | bankWhereUniqueInput[]
    connect?: bankWhereUniqueInput | bankWhereUniqueInput[]
    update?: bankUpdateWithWhereUniqueWithoutOperatorInput | bankUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: bankUpdateManyWithWhereWithoutOperatorInput | bankUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: bankScalarWhereInput | bankScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutOperatorNestedInput = {
    create?: XOR<userCreateWithoutOperatorInput, userUncheckedCreateWithoutOperatorInput>
    connectOrCreate?: userCreateOrConnectWithoutOperatorInput
    upsert?: userUpsertWithoutOperatorInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOperatorInput, userUpdateWithoutOperatorInput>, userUncheckedUpdateWithoutOperatorInput>
  }

  export type operatorgameUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput> | operatorgameCreateWithoutOperatorInput[] | operatorgameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: operatorgameCreateOrConnectWithoutOperatorInput | operatorgameCreateOrConnectWithoutOperatorInput[]
    upsert?: operatorgameUpsertWithWhereUniqueWithoutOperatorInput | operatorgameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: operatorgameCreateManyOperatorInputEnvelope
    set?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    disconnect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    delete?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    connect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    update?: operatorgameUpdateWithWhereUniqueWithoutOperatorInput | operatorgameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: operatorgameUpdateManyWithWhereWithoutOperatorInput | operatorgameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: operatorgameScalarWhereInput | operatorgameScalarWhereInput[]
  }

  export type profileUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput> | profileCreateWithoutOperatorInput[] | profileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: profileCreateOrConnectWithoutOperatorInput | profileCreateOrConnectWithoutOperatorInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutOperatorInput | profileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: profileCreateManyOperatorInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutOperatorInput | profileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: profileUpdateManyWithWhereWithoutOperatorInput | profileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type tournamentUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: tournamentUpsertWithWhereUniqueWithoutOperatorInput | tournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    set?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    disconnect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    delete?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    update?: tournamentUpdateWithWhereUniqueWithoutOperatorInput | tournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: tournamentUpdateManyWithWhereWithoutOperatorInput | tournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
  }

  export type bankUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput> | bankCreateWithoutOperatorInput[] | bankUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: bankCreateOrConnectWithoutOperatorInput | bankCreateOrConnectWithoutOperatorInput[]
    upsert?: bankUpsertWithWhereUniqueWithoutOperatorInput | bankUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: bankCreateManyOperatorInputEnvelope
    set?: bankWhereUniqueInput | bankWhereUniqueInput[]
    disconnect?: bankWhereUniqueInput | bankWhereUniqueInput[]
    delete?: bankWhereUniqueInput | bankWhereUniqueInput[]
    connect?: bankWhereUniqueInput | bankWhereUniqueInput[]
    update?: bankUpdateWithWhereUniqueWithoutOperatorInput | bankUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: bankUpdateManyWithWhereWithoutOperatorInput | bankUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: bankScalarWhereInput | bankScalarWhereInput[]
  }

  export type operatorgameUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput> | operatorgameCreateWithoutOperatorInput[] | operatorgameUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: operatorgameCreateOrConnectWithoutOperatorInput | operatorgameCreateOrConnectWithoutOperatorInput[]
    upsert?: operatorgameUpsertWithWhereUniqueWithoutOperatorInput | operatorgameUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: operatorgameCreateManyOperatorInputEnvelope
    set?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    disconnect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    delete?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    connect?: operatorgameWhereUniqueInput | operatorgameWhereUniqueInput[]
    update?: operatorgameUpdateWithWhereUniqueWithoutOperatorInput | operatorgameUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: operatorgameUpdateManyWithWhereWithoutOperatorInput | operatorgameUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: operatorgameScalarWhereInput | operatorgameScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput> | profileCreateWithoutOperatorInput[] | profileUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: profileCreateOrConnectWithoutOperatorInput | profileCreateOrConnectWithoutOperatorInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutOperatorInput | profileUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: profileCreateManyOperatorInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutOperatorInput | profileUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: profileUpdateManyWithWhereWithoutOperatorInput | profileUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type tournamentUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput> | tournamentCreateWithoutOperatorInput[] | tournamentUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: tournamentCreateOrConnectWithoutOperatorInput | tournamentCreateOrConnectWithoutOperatorInput[]
    upsert?: tournamentUpsertWithWhereUniqueWithoutOperatorInput | tournamentUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: tournamentCreateManyOperatorInputEnvelope
    set?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    disconnect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    delete?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    connect?: tournamentWhereUniqueInput | tournamentWhereUniqueInput[]
    update?: tournamentUpdateWithWhereUniqueWithoutOperatorInput | tournamentUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: tournamentUpdateManyWithWhereWithoutOperatorInput | tournamentUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
  }

  export type gamesessionCreateNestedManyWithoutOperatorgameInput = {
    create?: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput> | gamesessionCreateWithoutOperatorgameInput[] | gamesessionUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutOperatorgameInput | gamesessionCreateOrConnectWithoutOperatorgameInput[]
    createMany?: gamesessionCreateManyOperatorgameInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type operatorCreateNestedOneWithoutOperatorgameInput = {
    create?: XOR<operatorCreateWithoutOperatorgameInput, operatorUncheckedCreateWithoutOperatorgameInput>
    connectOrCreate?: operatorCreateOrConnectWithoutOperatorgameInput
    connect?: operatorWhereUniqueInput
  }

  export type tournamentgameCreateNestedManyWithoutOperatorgameInput = {
    create?: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput> | tournamentgameCreateWithoutOperatorgameInput[] | tournamentgameUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutOperatorgameInput | tournamentgameCreateOrConnectWithoutOperatorgameInput[]
    createMany?: tournamentgameCreateManyOperatorgameInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutOperatorgameInput = {
    create?: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput> | gamesessionCreateWithoutOperatorgameInput[] | gamesessionUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutOperatorgameInput | gamesessionCreateOrConnectWithoutOperatorgameInput[]
    createMany?: gamesessionCreateManyOperatorgameInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamentgameUncheckedCreateNestedManyWithoutOperatorgameInput = {
    create?: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput> | tournamentgameCreateWithoutOperatorgameInput[] | tournamentgameUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutOperatorgameInput | tournamentgameCreateOrConnectWithoutOperatorgameInput[]
    createMany?: tournamentgameCreateManyOperatorgameInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type gamesessionUpdateManyWithoutOperatorgameNestedInput = {
    create?: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput> | gamesessionCreateWithoutOperatorgameInput[] | gamesessionUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutOperatorgameInput | gamesessionCreateOrConnectWithoutOperatorgameInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutOperatorgameInput | gamesessionUpsertWithWhereUniqueWithoutOperatorgameInput[]
    createMany?: gamesessionCreateManyOperatorgameInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutOperatorgameInput | gamesessionUpdateWithWhereUniqueWithoutOperatorgameInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutOperatorgameInput | gamesessionUpdateManyWithWhereWithoutOperatorgameInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type operatorUpdateOneRequiredWithoutOperatorgameNestedInput = {
    create?: XOR<operatorCreateWithoutOperatorgameInput, operatorUncheckedCreateWithoutOperatorgameInput>
    connectOrCreate?: operatorCreateOrConnectWithoutOperatorgameInput
    upsert?: operatorUpsertWithoutOperatorgameInput
    connect?: operatorWhereUniqueInput
    update?: XOR<XOR<operatorUpdateToOneWithWhereWithoutOperatorgameInput, operatorUpdateWithoutOperatorgameInput>, operatorUncheckedUpdateWithoutOperatorgameInput>
  }

  export type tournamentgameUpdateManyWithoutOperatorgameNestedInput = {
    create?: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput> | tournamentgameCreateWithoutOperatorgameInput[] | tournamentgameUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutOperatorgameInput | tournamentgameCreateOrConnectWithoutOperatorgameInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutOperatorgameInput | tournamentgameUpsertWithWhereUniqueWithoutOperatorgameInput[]
    createMany?: tournamentgameCreateManyOperatorgameInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutOperatorgameInput | tournamentgameUpdateWithWhereUniqueWithoutOperatorgameInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutOperatorgameInput | tournamentgameUpdateManyWithWhereWithoutOperatorgameInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutOperatorgameNestedInput = {
    create?: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput> | gamesessionCreateWithoutOperatorgameInput[] | gamesessionUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutOperatorgameInput | gamesessionCreateOrConnectWithoutOperatorgameInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutOperatorgameInput | gamesessionUpsertWithWhereUniqueWithoutOperatorgameInput[]
    createMany?: gamesessionCreateManyOperatorgameInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutOperatorgameInput | gamesessionUpdateWithWhereUniqueWithoutOperatorgameInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutOperatorgameInput | gamesessionUpdateManyWithWhereWithoutOperatorgameInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamentgameUncheckedUpdateManyWithoutOperatorgameNestedInput = {
    create?: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput> | tournamentgameCreateWithoutOperatorgameInput[] | tournamentgameUncheckedCreateWithoutOperatorgameInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutOperatorgameInput | tournamentgameCreateOrConnectWithoutOperatorgameInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutOperatorgameInput | tournamentgameUpsertWithWhereUniqueWithoutOperatorgameInput[]
    createMany?: tournamentgameCreateManyOperatorgameInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutOperatorgameInput | tournamentgameUpdateWithWhereUniqueWithoutOperatorgameInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutOperatorgameInput | tournamentgameUpdateManyWithWhereWithoutOperatorgameInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type gamesessionCreateNestedManyWithoutProfileInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type bankCreateNestedOneWithoutProfileInput = {
    create?: XOR<bankCreateWithoutProfileInput, bankUncheckedCreateWithoutProfileInput>
    connectOrCreate?: bankCreateOrConnectWithoutProfileInput
    connect?: bankWhereUniqueInput
  }

  export type operatorCreateNestedOneWithoutProfileInput = {
    create?: XOR<operatorCreateWithoutProfileInput, operatorUncheckedCreateWithoutProfileInput>
    connectOrCreate?: operatorCreateOrConnectWithoutProfileInput
    connect?: operatorWhereUniqueInput
  }

  export type userCreateNestedOneWithoutProfile_profile_userIdTouserInput = {
    create?: XOR<userCreateWithoutProfile_profile_userIdTouserInput, userUncheckedCreateWithoutProfile_profile_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutProfile_profile_userIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type tournamententryCreateNestedManyWithoutProfileInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type transactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput> | transactionCreateWithoutProfileInput[] | transactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutProfileInput | transactionCreateOrConnectWithoutProfileInput[]
    createMany?: transactionCreateManyProfileInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type transactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput> | transactionCreateWithoutProfileInput[] | transactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutProfileInput | transactionCreateOrConnectWithoutProfileInput[]
    createMany?: transactionCreateManyProfileInputEnvelope
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type gamesessionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutProfileInput | gamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutProfileInput | gamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutProfileInput | gamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type bankUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<bankCreateWithoutProfileInput, bankUncheckedCreateWithoutProfileInput>
    connectOrCreate?: bankCreateOrConnectWithoutProfileInput
    upsert?: bankUpsertWithoutProfileInput
    connect?: bankWhereUniqueInput
    update?: XOR<XOR<bankUpdateToOneWithWhereWithoutProfileInput, bankUpdateWithoutProfileInput>, bankUncheckedUpdateWithoutProfileInput>
  }

  export type operatorUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<operatorCreateWithoutProfileInput, operatorUncheckedCreateWithoutProfileInput>
    connectOrCreate?: operatorCreateOrConnectWithoutProfileInput
    upsert?: operatorUpsertWithoutProfileInput
    connect?: operatorWhereUniqueInput
    update?: XOR<XOR<operatorUpdateToOneWithWhereWithoutProfileInput, operatorUpdateWithoutProfileInput>, operatorUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput = {
    create?: XOR<userCreateWithoutProfile_profile_userIdTouserInput, userUncheckedCreateWithoutProfile_profile_userIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutProfile_profile_userIdTouserInput
    upsert?: userUpsertWithoutProfile_profile_userIdTouserInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfile_profile_userIdTouserInput, userUpdateWithoutProfile_profile_userIdTouserInput>, userUncheckedUpdateWithoutProfile_profile_userIdTouserInput>
  }

  export type tournamententryUpdateManyWithoutProfileNestedInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutProfileInput | tournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutProfileInput | tournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutProfileInput | tournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type transactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput> | transactionCreateWithoutProfileInput[] | transactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutProfileInput | transactionCreateOrConnectWithoutProfileInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutProfileInput | transactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: transactionCreateManyProfileInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutProfileInput | transactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutProfileInput | transactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput> | gamesessionCreateWithoutProfileInput[] | gamesessionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutProfileInput | gamesessionCreateOrConnectWithoutProfileInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutProfileInput | gamesessionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: gamesessionCreateManyProfileInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutProfileInput | gamesessionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutProfileInput | gamesessionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput> | tournamententryCreateWithoutProfileInput[] | tournamententryUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutProfileInput | tournamententryCreateOrConnectWithoutProfileInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutProfileInput | tournamententryUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: tournamententryCreateManyProfileInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutProfileInput | tournamententryUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutProfileInput | tournamententryUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type transactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput> | transactionCreateWithoutProfileInput[] | transactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: transactionCreateOrConnectWithoutProfileInput | transactionCreateOrConnectWithoutProfileInput[]
    upsert?: transactionUpsertWithWhereUniqueWithoutProfileInput | transactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: transactionCreateManyProfileInputEnvelope
    set?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    disconnect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    delete?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    connect?: transactionWhereUniqueInput | transactionWhereUniqueInput[]
    update?: transactionUpdateWithWhereUniqueWithoutProfileInput | transactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: transactionUpdateManyWithWhereWithoutProfileInput | transactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: transactionScalarWhereInput | transactionScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutSessionInput = {
    create?: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    connectOrCreate?: userCreateOrConnectWithoutSessionInput
    upsert?: userUpsertWithoutSessionInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutSessionInput, userUpdateWithoutSessionInput>, userUncheckedUpdateWithoutSessionInput>
  }

  export type gamesessionCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type operatorCreateNestedOneWithoutTournamentInput = {
    create?: XOR<operatorCreateWithoutTournamentInput, operatorUncheckedCreateWithoutTournamentInput>
    connectOrCreate?: operatorCreateOrConnectWithoutTournamentInput
    connect?: operatorWhereUniqueInput
  }

  export type tournamententryCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type tournamentgameCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type gamesessionUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type tournamentgameUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type gamesessionUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutTournamentInput | gamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutTournamentInput | gamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutTournamentInput | gamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type operatorUpdateOneRequiredWithoutTournamentNestedInput = {
    create?: XOR<operatorCreateWithoutTournamentInput, operatorUncheckedCreateWithoutTournamentInput>
    connectOrCreate?: operatorCreateOrConnectWithoutTournamentInput
    upsert?: operatorUpsertWithoutTournamentInput
    connect?: operatorWhereUniqueInput
    update?: XOR<XOR<operatorUpdateToOneWithWhereWithoutTournamentInput, operatorUpdateWithoutTournamentInput>, operatorUncheckedUpdateWithoutTournamentInput>
  }

  export type tournamententryUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutTournamentInput | tournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutTournamentInput | tournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutTournamentInput | tournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type tournamentgameUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutTournamentInput | tournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutTournamentInput | tournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutTournamentInput | tournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type gamesessionUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput> | gamesessionCreateWithoutTournamentInput[] | gamesessionUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: gamesessionCreateOrConnectWithoutTournamentInput | gamesessionCreateOrConnectWithoutTournamentInput[]
    upsert?: gamesessionUpsertWithWhereUniqueWithoutTournamentInput | gamesessionUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: gamesessionCreateManyTournamentInputEnvelope
    set?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    disconnect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    delete?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    connect?: gamesessionWhereUniqueInput | gamesessionWhereUniqueInput[]
    update?: gamesessionUpdateWithWhereUniqueWithoutTournamentInput | gamesessionUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: gamesessionUpdateManyWithWhereWithoutTournamentInput | gamesessionUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput> | tournamententryCreateWithoutTournamentInput[] | tournamententryUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutTournamentInput | tournamententryCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutTournamentInput | tournamententryUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamententryCreateManyTournamentInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutTournamentInput | tournamententryUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutTournamentInput | tournamententryUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput> | tournamentgameCreateWithoutTournamentInput[] | tournamentgameUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: tournamentgameCreateOrConnectWithoutTournamentInput | tournamentgameCreateOrConnectWithoutTournamentInput[]
    upsert?: tournamentgameUpsertWithWhereUniqueWithoutTournamentInput | tournamentgameUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: tournamentgameCreateManyTournamentInputEnvelope
    set?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    disconnect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    delete?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    connect?: tournamentgameWhereUniqueInput | tournamentgameWhereUniqueInput[]
    update?: tournamentgameUpdateWithWhereUniqueWithoutTournamentInput | tournamentgameUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: tournamentgameUpdateManyWithWhereWithoutTournamentInput | tournamentgameUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
  }

  export type profileCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<profileCreateWithoutTournamententryInput, profileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: profileCreateOrConnectWithoutTournamententryInput
    connect?: profileWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamententryInput
    connect?: tournamentWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTournamententryInput = {
    create?: XOR<userCreateWithoutTournamententryInput, userUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: userCreateOrConnectWithoutTournamententryInput
    connect?: userWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<profileCreateWithoutTournamententryInput, profileUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: profileCreateOrConnectWithoutTournamententryInput
    upsert?: profileUpsertWithoutTournamententryInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutTournamententryInput, profileUpdateWithoutTournamententryInput>, profileUncheckedUpdateWithoutTournamententryInput>
  }

  export type tournamentUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamententryInput
    upsert?: tournamentUpsertWithoutTournamententryInput
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutTournamententryInput, tournamentUpdateWithoutTournamententryInput>, tournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type userUpdateOneRequiredWithoutTournamententryNestedInput = {
    create?: XOR<userCreateWithoutTournamententryInput, userUncheckedCreateWithoutTournamententryInput>
    connectOrCreate?: userCreateOrConnectWithoutTournamententryInput
    upsert?: userUpsertWithoutTournamententryInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTournamententryInput, userUpdateWithoutTournamententryInput>, userUncheckedUpdateWithoutTournamententryInput>
  }

  export type operatorgameCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<operatorgameCreateWithoutTournamentgameInput, operatorgameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: operatorgameCreateOrConnectWithoutTournamentgameInput
    connect?: operatorgameWhereUniqueInput
  }

  export type tournamentCreateNestedOneWithoutTournamentgameInput = {
    create?: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamentgameInput
    connect?: tournamentWhereUniqueInput
  }

  export type operatorgameUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<operatorgameCreateWithoutTournamentgameInput, operatorgameUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: operatorgameCreateOrConnectWithoutTournamentgameInput
    upsert?: operatorgameUpsertWithoutTournamentgameInput
    connect?: operatorgameWhereUniqueInput
    update?: XOR<XOR<operatorgameUpdateToOneWithWhereWithoutTournamentgameInput, operatorgameUpdateWithoutTournamentgameInput>, operatorgameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type tournamentUpdateOneRequiredWithoutTournamentgameNestedInput = {
    create?: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    connectOrCreate?: tournamentCreateOrConnectWithoutTournamentgameInput
    upsert?: tournamentUpsertWithoutTournamentgameInput
    connect?: tournamentWhereUniqueInput
    update?: XOR<XOR<tournamentUpdateToOneWithWhereWithoutTournamentgameInput, tournamentUpdateWithoutTournamentgameInput>, tournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type gamesessionCreateNestedOneWithoutTransactionInput = {
    create?: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutTransactionInput
    connect?: gamesessionWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutTransactionInput = {
    create?: XOR<profileCreateWithoutTransactionInput, profileUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: profileCreateOrConnectWithoutTransactionInput
    connect?: profileWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type gamesessionUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: gamesessionCreateOrConnectWithoutTransactionInput
    upsert?: gamesessionUpsertWithoutTransactionInput
    disconnect?: gamesessionWhereInput | boolean
    delete?: gamesessionWhereInput | boolean
    connect?: gamesessionWhereUniqueInput
    update?: XOR<XOR<gamesessionUpdateToOneWithWhereWithoutTransactionInput, gamesessionUpdateWithoutTransactionInput>, gamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type profileUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<profileCreateWithoutTransactionInput, profileUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: profileCreateOrConnectWithoutTransactionInput
    upsert?: profileUpsertWithoutTransactionInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutTransactionInput, profileUpdateWithoutTransactionInput>, profileUncheckedUpdateWithoutTransactionInput>
  }

  export type RainBetCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type chatmessageCreateNestedManyWithoutUserInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type operatorCreateNestedManyWithoutUserInput = {
    create?: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput> | operatorCreateWithoutUserInput[] | operatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: operatorCreateOrConnectWithoutUserInput | operatorCreateOrConnectWithoutUserInput[]
    createMany?: operatorCreateManyUserInputEnvelope
    connect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
  }

  export type profileCreateNestedManyWithoutUser_profile_userIdTouserInput = {
    create?: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput> | profileCreateWithoutUser_profile_userIdTouserInput[] | profileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: profileCreateOrConnectWithoutUser_profile_userIdTouserInput | profileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    createMany?: profileCreateManyUser_profile_userIdTouserInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type sessionCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type tournamententryCreateNestedManyWithoutUserInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type userachievementCreateNestedManyWithoutUserInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type chatmessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type operatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput> | operatorCreateWithoutUserInput[] | operatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: operatorCreateOrConnectWithoutUserInput | operatorCreateOrConnectWithoutUserInput[]
    createMany?: operatorCreateManyUserInputEnvelope
    connect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput = {
    create?: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput> | profileCreateWithoutUser_profile_userIdTouserInput[] | profileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: profileCreateOrConnectWithoutUser_profile_userIdTouserInput | profileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    createMany?: profileCreateManyUser_profile_userIdTouserInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type tournamententryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
  }

  export type userachievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableEnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus | null
  }

  export type RainBetUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type chatmessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUserInput | chatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUserInput | chatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUserInput | chatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type operatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput> | operatorCreateWithoutUserInput[] | operatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: operatorCreateOrConnectWithoutUserInput | operatorCreateOrConnectWithoutUserInput[]
    upsert?: operatorUpsertWithWhereUniqueWithoutUserInput | operatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: operatorCreateManyUserInputEnvelope
    set?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    disconnect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    delete?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    connect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    update?: operatorUpdateWithWhereUniqueWithoutUserInput | operatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: operatorUpdateManyWithWhereWithoutUserInput | operatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: operatorScalarWhereInput | operatorScalarWhereInput[]
  }

  export type profileUpdateManyWithoutUser_profile_userIdTouserNestedInput = {
    create?: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput> | profileCreateWithoutUser_profile_userIdTouserInput[] | profileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: profileCreateOrConnectWithoutUser_profile_userIdTouserInput | profileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput | profileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    createMany?: profileCreateManyUser_profile_userIdTouserInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput | profileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    updateMany?: profileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput | profileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type sessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type tournamententryUpdateManyWithoutUserNestedInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutUserInput | tournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutUserInput | tournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutUserInput | tournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type userachievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutUserInput | userachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutUserInput | userachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutUserInput | userachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput> | RainBetCreateWithoutUserInput[] | RainBetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutUserInput | RainBetCreateOrConnectWithoutUserInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutUserInput | RainBetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainBetCreateManyUserInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutUserInput | RainBetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutUserInput | RainBetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput> | RainHistoryCreateWithoutUserInput[] | RainHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainHistoryCreateOrConnectWithoutUserInput | RainHistoryCreateOrConnectWithoutUserInput[]
    upsert?: RainHistoryUpsertWithWhereUniqueWithoutUserInput | RainHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainHistoryCreateManyUserInputEnvelope
    set?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    disconnect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    delete?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    connect?: RainHistoryWhereUniqueInput | RainHistoryWhereUniqueInput[]
    update?: RainHistoryUpdateWithWhereUniqueWithoutUserInput | RainHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainHistoryUpdateManyWithWhereWithoutUserInput | RainHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput> | RainTipCreateWithoutUserInput[] | RainTipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutUserInput | RainTipCreateOrConnectWithoutUserInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutUserInput | RainTipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainTipCreateManyUserInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutUserInput | RainTipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutUserInput | RainTipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput> | RainWinnerCreateWithoutUserInput[] | RainWinnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutUserInput | RainWinnerCreateOrConnectWithoutUserInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutUserInput | RainWinnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RainWinnerCreateManyUserInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutUserInput | RainWinnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutUserInput | RainWinnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type chatmessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput> | chatmessageCreateWithoutUserInput[] | chatmessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUserInput | chatmessageCreateOrConnectWithoutUserInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUserInput | chatmessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatmessageCreateManyUserInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUserInput | chatmessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUserInput | chatmessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput> | friendshipCreateWithoutUser_friendship_friendIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput = {
    create?: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput> | friendshipCreateWithoutUser_friendship_userIdTouserInput[] | friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput[]
    connectOrCreate?: friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput | friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput[]
    upsert?: friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    createMany?: friendshipCreateManyUser_friendship_userIdTouserInputEnvelope
    set?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    disconnect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    delete?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    connect?: friendshipWhereUniqueInput | friendshipWhereUniqueInput[]
    update?: friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput | friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput[]
    updateMany?: friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput | friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput[]
    deleteMany?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput> | notificationCreateWithoutUserInput[] | notificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUserInput | notificationCreateOrConnectWithoutUserInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUserInput | notificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notificationCreateManyUserInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUserInput | notificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUserInput | notificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type operatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput> | operatorCreateWithoutUserInput[] | operatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: operatorCreateOrConnectWithoutUserInput | operatorCreateOrConnectWithoutUserInput[]
    upsert?: operatorUpsertWithWhereUniqueWithoutUserInput | operatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: operatorCreateManyUserInputEnvelope
    set?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    disconnect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    delete?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    connect?: operatorWhereUniqueInput | operatorWhereUniqueInput[]
    update?: operatorUpdateWithWhereUniqueWithoutUserInput | operatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: operatorUpdateManyWithWhereWithoutUserInput | operatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: operatorScalarWhereInput | operatorScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput = {
    create?: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput> | profileCreateWithoutUser_profile_userIdTouserInput[] | profileUncheckedCreateWithoutUser_profile_userIdTouserInput[]
    connectOrCreate?: profileCreateOrConnectWithoutUser_profile_userIdTouserInput | profileCreateOrConnectWithoutUser_profile_userIdTouserInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput | profileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    createMany?: profileCreateManyUser_profile_userIdTouserInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput | profileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput[]
    updateMany?: profileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput | profileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput> | sessionCreateWithoutUserInput[] | sessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutUserInput | sessionCreateOrConnectWithoutUserInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutUserInput | sessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: sessionCreateManyUserInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutUserInput | sessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutUserInput | sessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type tournamententryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput> | tournamententryCreateWithoutUserInput[] | tournamententryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: tournamententryCreateOrConnectWithoutUserInput | tournamententryCreateOrConnectWithoutUserInput[]
    upsert?: tournamententryUpsertWithWhereUniqueWithoutUserInput | tournamententryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: tournamententryCreateManyUserInputEnvelope
    set?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    disconnect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    delete?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    connect?: tournamententryWhereUniqueInput | tournamententryWhereUniqueInput[]
    update?: tournamententryUpdateWithWhereUniqueWithoutUserInput | tournamententryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: tournamententryUpdateManyWithWhereWithoutUserInput | tournamententryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
  }

  export type userachievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput> | userachievementCreateWithoutUserInput[] | userachievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userachievementCreateOrConnectWithoutUserInput | userachievementCreateOrConnectWithoutUserInput[]
    upsert?: userachievementUpsertWithWhereUniqueWithoutUserInput | userachievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userachievementCreateManyUserInputEnvelope
    set?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    disconnect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    delete?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    connect?: userachievementWhereUniqueInput | userachievementWhereUniqueInput[]
    update?: userachievementUpdateWithWhereUniqueWithoutUserInput | userachievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userachievementUpdateManyWithWhereWithoutUserInput | userachievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
  }

  export type achievementCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: achievementCreateOrConnectWithoutUserachievementInput
    connect?: achievementWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserachievementInput = {
    create?: XOR<userCreateWithoutUserachievementInput, userUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: userCreateOrConnectWithoutUserachievementInput
    connect?: userWhereUniqueInput
  }

  export type achievementUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: achievementCreateOrConnectWithoutUserachievementInput
    upsert?: achievementUpsertWithoutUserachievementInput
    connect?: achievementWhereUniqueInput
    update?: XOR<XOR<achievementUpdateToOneWithWhereWithoutUserachievementInput, achievementUpdateWithoutUserachievementInput>, achievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type userUpdateOneRequiredWithoutUserachievementNestedInput = {
    create?: XOR<userCreateWithoutUserachievementInput, userUncheckedCreateWithoutUserachievementInput>
    connectOrCreate?: userCreateOrConnectWithoutUserachievementInput
    upsert?: userUpsertWithoutUserachievementInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserachievementInput, userUpdateWithoutUserachievementInput>, userUncheckedUpdateWithoutUserachievementInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainBetInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRainBetInput = {
    create?: XOR<userCreateWithoutRainBetInput, userUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: userCreateOrConnectWithoutRainBetInput
    connect?: userWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainBetInput
    upsert?: RainHistoryUpsertWithoutRainBetInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainBetInput, RainHistoryUpdateWithoutRainBetInput>, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type userUpdateOneRequiredWithoutRainBetNestedInput = {
    create?: XOR<userCreateWithoutRainBetInput, userUncheckedCreateWithoutRainBetInput>
    connectOrCreate?: userCreateOrConnectWithoutRainBetInput
    upsert?: userUpsertWithoutRainBetInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRainBetInput, userUpdateWithoutRainBetInput>, userUncheckedUpdateWithoutRainBetInput>
  }

  export type RainBetCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutRainHistoryInput = {
    create?: XOR<userCreateWithoutRainHistoryInput, userUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: userCreateOrConnectWithoutRainHistoryInput
    connect?: userWhereUniqueInput
  }

  export type RainTipCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
  }

  export type RainTipUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
  }

  export type RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
  }

  export type RainBetUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutRainHistoryNestedInput = {
    create?: XOR<userCreateWithoutRainHistoryInput, userUncheckedCreateWithoutRainHistoryInput>
    connectOrCreate?: userCreateOrConnectWithoutRainHistoryInput
    upsert?: userUpsertWithoutRainHistoryInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRainHistoryInput, userUpdateWithoutRainHistoryInput>, userUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput> | RainBetCreateWithoutRainHistoryInput[] | RainBetUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainBetCreateOrConnectWithoutRainHistoryInput | RainBetCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainBetUpsertWithWhereUniqueWithoutRainHistoryInput | RainBetUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainBetCreateManyRainHistoryInputEnvelope
    set?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    disconnect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    delete?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    connect?: RainBetWhereUniqueInput | RainBetWhereUniqueInput[]
    update?: RainBetUpdateWithWhereUniqueWithoutRainHistoryInput | RainBetUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainBetUpdateManyWithWhereWithoutRainHistoryInput | RainBetUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput> | RainTipCreateWithoutRainHistoryInput[] | RainTipUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainTipCreateOrConnectWithoutRainHistoryInput | RainTipCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainTipUpsertWithWhereUniqueWithoutRainHistoryInput | RainTipUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainTipCreateManyRainHistoryInputEnvelope
    set?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    disconnect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    delete?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    connect?: RainTipWhereUniqueInput | RainTipWhereUniqueInput[]
    update?: RainTipUpdateWithWhereUniqueWithoutRainHistoryInput | RainTipUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainTipUpdateManyWithWhereWithoutRainHistoryInput | RainTipUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput = {
    create?: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput> | RainWinnerCreateWithoutRainHistoryInput[] | RainWinnerUncheckedCreateWithoutRainHistoryInput[]
    connectOrCreate?: RainWinnerCreateOrConnectWithoutRainHistoryInput | RainWinnerCreateOrConnectWithoutRainHistoryInput[]
    upsert?: RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput[]
    createMany?: RainWinnerCreateManyRainHistoryInputEnvelope
    set?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    disconnect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    delete?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    connect?: RainWinnerWhereUniqueInput | RainWinnerWhereUniqueInput[]
    update?: RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput | RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput[]
    updateMany?: RainWinnerUpdateManyWithWhereWithoutRainHistoryInput | RainWinnerUpdateManyWithWhereWithoutRainHistoryInput[]
    deleteMany?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
  }

  export type RainHistoryCreateNestedOneWithoutRainTipInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRainTipInput = {
    create?: XOR<userCreateWithoutRainTipInput, userUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: userCreateOrConnectWithoutRainTipInput
    connect?: userWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainTipInput
    upsert?: RainHistoryUpsertWithoutRainTipInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainTipInput, RainHistoryUpdateWithoutRainTipInput>, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type userUpdateOneRequiredWithoutRainTipNestedInput = {
    create?: XOR<userCreateWithoutRainTipInput, userUncheckedCreateWithoutRainTipInput>
    connectOrCreate?: userCreateOrConnectWithoutRainTipInput
    upsert?: userUpsertWithoutRainTipInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRainTipInput, userUpdateWithoutRainTipInput>, userUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
  }

  export type userCreateNestedOneWithoutRainWinnerInput = {
    create?: XOR<userCreateWithoutRainWinnerInput, userUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: userCreateOrConnectWithoutRainWinnerInput
    connect?: userWhereUniqueInput
  }

  export type RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: RainHistoryCreateOrConnectWithoutRainWinnerInput
    upsert?: RainHistoryUpsertWithoutRainWinnerInput
    connect?: RainHistoryWhereUniqueInput
    update?: XOR<XOR<RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput, RainHistoryUpdateWithoutRainWinnerInput>, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type userUpdateOneRequiredWithoutRainWinnerNestedInput = {
    create?: XOR<userCreateWithoutRainWinnerInput, userUncheckedCreateWithoutRainWinnerInput>
    connectOrCreate?: userCreateOrConnectWithoutRainWinnerInput
    upsert?: userUpsertWithoutRainWinnerInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRainWinnerInput, userUpdateWithoutRainWinnerInput>, userUncheckedUpdateWithoutRainWinnerInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumChatChannelFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelFilter<$PrismaModel> | $Enums.ChatChannel
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumChatChannelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatChannel | EnumChatChannelFieldRefInput<$PrismaModel>
    in?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatChannel[] | ListEnumChatChannelFieldRefInput<$PrismaModel>
    not?: NestedEnumChatChannelWithAggregatesFilter<$PrismaModel> | $Enums.ChatChannel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatChannelFilter<$PrismaModel>
    _max?: NestedEnumChatChannelFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumFriendshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusFilter<$PrismaModel> | $Enums.FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendshipStatus | EnumFriendshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendshipStatus[] | ListEnumFriendshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendshipStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendshipStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumUserStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableFilter<$PrismaModel> | $Enums.UserStatus | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumUserStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumUserStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumUserStatusNullableFilter<$PrismaModel>
  }

  export type userachievementCreateWithoutAchievementInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    user: userCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateWithoutAchievementInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
  }

  export type userachievementCreateOrConnectWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    create: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput>
  }

  export type userachievementCreateManyAchievementInputEnvelope = {
    data: userachievementCreateManyAchievementInput | userachievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type userachievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    update: XOR<userachievementUpdateWithoutAchievementInput, userachievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<userachievementCreateWithoutAchievementInput, userachievementUncheckedCreateWithoutAchievementInput>
  }

  export type userachievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: userachievementWhereUniqueInput
    data: XOR<userachievementUpdateWithoutAchievementInput, userachievementUncheckedUpdateWithoutAchievementInput>
  }

  export type userachievementUpdateManyWithWhereWithoutAchievementInput = {
    where: userachievementScalarWhereInput
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type userachievementScalarWhereInput = {
    AND?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
    OR?: userachievementScalarWhereInput[]
    NOT?: userachievementScalarWhereInput | userachievementScalarWhereInput[]
    id?: StringFilter<"userachievement"> | string
    progress?: IntFilter<"userachievement"> | number
    isUnlocked?: BoolFilter<"userachievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userachievement"> | Date | string | null
    createdAt?: DateTimeFilter<"userachievement"> | Date | string
    updatedAt?: DateTimeFilter<"userachievement"> | Date | string
    userId?: StringFilter<"userachievement"> | string
    achievementId?: StringFilter<"userachievement"> | string
  }

  export type operatorCreateWithoutBankInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    user: userCreateNestedOneWithoutOperatorInput
    operatorgame?: operatorgameCreateNestedManyWithoutOperatorInput
    profile?: profileCreateNestedManyWithoutOperatorInput
    tournament?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateWithoutBankInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
    operatorgame?: operatorgameUncheckedCreateNestedManyWithoutOperatorInput
    profile?: profileUncheckedCreateNestedManyWithoutOperatorInput
    tournament?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorCreateOrConnectWithoutBankInput = {
    where: operatorWhereUniqueInput
    create: XOR<operatorCreateWithoutBankInput, operatorUncheckedCreateWithoutBankInput>
  }

  export type profileCreateWithoutBankInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutBankInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutBankInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput>
  }

  export type profileCreateManyBankInputEnvelope = {
    data: profileCreateManyBankInput | profileCreateManyBankInput[]
    skipDuplicates?: boolean
  }

  export type operatorUpsertWithoutBankInput = {
    update: XOR<operatorUpdateWithoutBankInput, operatorUncheckedUpdateWithoutBankInput>
    create: XOR<operatorCreateWithoutBankInput, operatorUncheckedCreateWithoutBankInput>
    where?: operatorWhereInput
  }

  export type operatorUpdateToOneWithWhereWithoutBankInput = {
    where?: operatorWhereInput
    data: XOR<operatorUpdateWithoutBankInput, operatorUncheckedUpdateWithoutBankInput>
  }

  export type operatorUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOperatorNestedInput
    operatorgame?: operatorgameUpdateManyWithoutOperatorNestedInput
    profile?: profileUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    operatorgame?: operatorgameUncheckedUpdateManyWithoutOperatorNestedInput
    profile?: profileUncheckedUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type profileUpsertWithWhereUniqueWithoutBankInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutBankInput, profileUncheckedUpdateWithoutBankInput>
    create: XOR<profileCreateWithoutBankInput, profileUncheckedCreateWithoutBankInput>
  }

  export type profileUpdateWithWhereUniqueWithoutBankInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutBankInput, profileUncheckedUpdateWithoutBankInput>
  }

  export type profileUpdateManyWithWhereWithoutBankInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutBankInput>
  }

  export type profileScalarWhereInput = {
    AND?: profileScalarWhereInput | profileScalarWhereInput[]
    OR?: profileScalarWhereInput[]
    NOT?: profileScalarWhereInput | profileScalarWhereInput[]
    id?: StringFilter<"profile"> | string
    profileNumber?: StringFilter<"profile"> | string
    balance?: IntFilter<"profile"> | number
    xpEarned?: IntFilter<"profile"> | number
    isActive?: BoolFilter<"profile"> | boolean
    lastPlayed?: DateTimeNullableFilter<"profile"> | Date | string | null
    createdAt?: DateTimeFilter<"profile"> | Date | string
    updatedAt?: DateTimeFilter<"profile"> | Date | string
    phpId?: IntNullableFilter<"profile"> | number | null
    userId?: StringFilter<"profile"> | string
    bankId?: StringFilter<"profile"> | string
    shopId?: StringFilter<"profile"> | string
  }

  export type chatroomCreateWithoutChatmessageInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gamesession?: gamesessionCreateNestedOneWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutChatmessageInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    gameSessionId?: string | null
  }

  export type chatroomCreateOrConnectWithoutChatmessageInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
  }

  export type userCreateWithoutChatmessageInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutChatmessageInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutChatmessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutChatmessageInput, userUncheckedCreateWithoutChatmessageInput>
  }

  export type chatroomUpsertWithoutChatmessageInput = {
    update: XOR<chatroomUpdateWithoutChatmessageInput, chatroomUncheckedUpdateWithoutChatmessageInput>
    create: XOR<chatroomCreateWithoutChatmessageInput, chatroomUncheckedCreateWithoutChatmessageInput>
    where?: chatroomWhereInput
  }

  export type chatroomUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: chatroomWhereInput
    data: XOR<chatroomUpdateWithoutChatmessageInput, chatroomUncheckedUpdateWithoutChatmessageInput>
  }

  export type chatroomUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUpdateOneWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUpsertWithoutChatmessageInput = {
    update: XOR<userUpdateWithoutChatmessageInput, userUncheckedUpdateWithoutChatmessageInput>
    create: XOR<userCreateWithoutChatmessageInput, userUncheckedCreateWithoutChatmessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutChatmessageInput, userUncheckedUpdateWithoutChatmessageInput>
  }

  export type userUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutChatmessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatmessageCreateWithoutChatroomInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: userCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutChatroomInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type chatmessageCreateOrConnectWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageCreateManyChatroomInputEnvelope = {
    data: chatmessageCreateManyChatroomInput | chatmessageCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionCreateWithoutChatroomInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    operatorgame: operatorgameCreateNestedOneWithoutGamesessionInput
    profile: profileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    transaction?: transactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutChatroomInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    transaction?: transactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutChatroomInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageUpsertWithWhereUniqueWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutChatroomInput, chatmessageUncheckedUpdateWithoutChatroomInput>
    create: XOR<chatmessageCreateWithoutChatroomInput, chatmessageUncheckedCreateWithoutChatroomInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutChatroomInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutChatroomInput, chatmessageUncheckedUpdateWithoutChatroomInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutChatroomInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutChatroomInput>
  }

  export type chatmessageScalarWhereInput = {
    AND?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    OR?: chatmessageScalarWhereInput[]
    NOT?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    id?: StringFilter<"chatmessage"> | string
    content?: StringFilter<"chatmessage"> | string
    channel?: EnumChatChannelFilter<"chatmessage"> | $Enums.ChatChannel
    metadata?: JsonNullableFilter<"chatmessage">
    createdAt?: DateTimeFilter<"chatmessage"> | Date | string
    userId?: StringFilter<"chatmessage"> | string
    roomId?: StringNullableFilter<"chatmessage"> | string | null
  }

  export type gamesessionUpsertWithoutChatroomInput = {
    update: XOR<gamesessionUpdateWithoutChatroomInput, gamesessionUncheckedUpdateWithoutChatroomInput>
    create: XOR<gamesessionCreateWithoutChatroomInput, gamesessionUncheckedCreateWithoutChatroomInput>
    where?: gamesessionWhereInput
  }

  export type gamesessionUpdateToOneWithWhereWithoutChatroomInput = {
    where?: gamesessionWhereInput
    data: XOR<gamesessionUpdateWithoutChatroomInput, gamesessionUncheckedUpdateWithoutChatroomInput>
  }

  export type gamesessionUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    operatorgame?: operatorgameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: profileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    transaction?: transactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    transaction?: transactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type userCreateWithoutFriendship_friendship_friendIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFriendship_friendship_friendIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type userCreateWithoutFriendship_friendship_userIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFriendship_friendship_userIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFriendship_friendship_userIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFriendship_friendship_userIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type userUpsertWithoutFriendship_friendship_friendIdTouserInput = {
    update: XOR<userUpdateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
    create: XOR<userCreateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_friendIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFriendship_friendship_friendIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFriendship_friendship_friendIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput>
  }

  export type userUpdateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFriendship_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutFriendship_friendship_userIdTouserInput = {
    update: XOR<userUpdateWithoutFriendship_friendship_userIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
    create: XOR<userCreateWithoutFriendship_friendship_userIdTouserInput, userUncheckedCreateWithoutFriendship_friendship_userIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFriendship_friendship_userIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFriendship_friendship_userIdTouserInput, userUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput>
  }

  export type userUpdateWithoutFriendship_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFriendship_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatroomCreateWithoutGamesessionInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutGamesessionInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomCreateOrConnectWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type chatroomCreateManyGamesessionInputEnvelope = {
    data: chatroomCreateManyGamesessionInput | chatroomCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type operatorgameCreateWithoutGamesessionInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operator: operatorCreateNestedOneWithoutOperatorgameInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameUncheckedCreateWithoutGamesessionInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameCreateOrConnectWithoutGamesessionInput = {
    where: operatorgameWhereUniqueInput
    create: XOR<operatorgameCreateWithoutGamesessionInput, operatorgameUncheckedCreateWithoutGamesessionInput>
  }

  export type profileCreateWithoutGamesessionInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    bank: bankCreateNestedOneWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutGamesessionInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    shopId: string
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutGamesessionInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutGamesessionInput, profileUncheckedCreateWithoutGamesessionInput>
  }

  export type tournamentCreateWithoutGamesessionInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator: operatorCreateNestedOneWithoutTournamentInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutGamesessionInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutGamesessionInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
  }

  export type transactionCreateWithoutGamesessionInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profile: profileCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutGamesessionInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId: string
  }

  export type transactionCreateOrConnectWithoutGamesessionInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput>
  }

  export type transactionCreateManyGamesessionInputEnvelope = {
    data: transactionCreateManyGamesessionInput | transactionCreateManyGamesessionInput[]
    skipDuplicates?: boolean
  }

  export type chatroomUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    update: XOR<chatroomUpdateWithoutGamesessionInput, chatroomUncheckedUpdateWithoutGamesessionInput>
    create: XOR<chatroomCreateWithoutGamesessionInput, chatroomUncheckedCreateWithoutGamesessionInput>
  }

  export type chatroomUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: chatroomWhereUniqueInput
    data: XOR<chatroomUpdateWithoutGamesessionInput, chatroomUncheckedUpdateWithoutGamesessionInput>
  }

  export type chatroomUpdateManyWithWhereWithoutGamesessionInput = {
    where: chatroomScalarWhereInput
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type chatroomScalarWhereInput = {
    AND?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
    OR?: chatroomScalarWhereInput[]
    NOT?: chatroomScalarWhereInput | chatroomScalarWhereInput[]
    id?: StringFilter<"chatroom"> | string
    name?: StringFilter<"chatroom"> | string
    isGameRoom?: BoolFilter<"chatroom"> | boolean
    createdAt?: DateTimeFilter<"chatroom"> | Date | string
    gameSessionId?: StringNullableFilter<"chatroom"> | string | null
  }

  export type operatorgameUpsertWithoutGamesessionInput = {
    update: XOR<operatorgameUpdateWithoutGamesessionInput, operatorgameUncheckedUpdateWithoutGamesessionInput>
    create: XOR<operatorgameCreateWithoutGamesessionInput, operatorgameUncheckedCreateWithoutGamesessionInput>
    where?: operatorgameWhereInput
  }

  export type operatorgameUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: operatorgameWhereInput
    data: XOR<operatorgameUpdateWithoutGamesessionInput, operatorgameUncheckedUpdateWithoutGamesessionInput>
  }

  export type operatorgameUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: operatorUpdateOneRequiredWithoutOperatorgameNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutOperatorgameNestedInput
  }

  export type operatorgameUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutOperatorgameNestedInput
  }

  export type profileUpsertWithoutGamesessionInput = {
    update: XOR<profileUpdateWithoutGamesessionInput, profileUncheckedUpdateWithoutGamesessionInput>
    create: XOR<profileCreateWithoutGamesessionInput, profileUncheckedCreateWithoutGamesessionInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutGamesessionInput, profileUncheckedUpdateWithoutGamesessionInput>
  }

  export type profileUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type tournamentUpsertWithoutGamesessionInput = {
    update: XOR<tournamentUpdateWithoutGamesessionInput, tournamentUncheckedUpdateWithoutGamesessionInput>
    create: XOR<tournamentCreateWithoutGamesessionInput, tournamentUncheckedCreateWithoutGamesessionInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutGamesessionInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutGamesessionInput, tournamentUncheckedUpdateWithoutGamesessionInput>
  }

  export type tournamentUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    operator?: operatorUpdateOneRequiredWithoutTournamentNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type transactionUpsertWithWhereUniqueWithoutGamesessionInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutGamesessionInput, transactionUncheckedUpdateWithoutGamesessionInput>
    create: XOR<transactionCreateWithoutGamesessionInput, transactionUncheckedCreateWithoutGamesessionInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutGamesessionInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutGamesessionInput, transactionUncheckedUpdateWithoutGamesessionInput>
  }

  export type transactionUpdateManyWithWhereWithoutGamesessionInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutGamesessionInput>
  }

  export type transactionScalarWhereInput = {
    AND?: transactionScalarWhereInput | transactionScalarWhereInput[]
    OR?: transactionScalarWhereInput[]
    NOT?: transactionScalarWhereInput | transactionScalarWhereInput[]
    id?: StringFilter<"transaction"> | string
    type?: EnumTransactionTypeFilter<"transaction"> | $Enums.TransactionType
    amount?: DecimalFilter<"transaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"transaction"> | string | null
    status?: EnumTransactionStatusFilter<"transaction"> | $Enums.TransactionStatus
    metadata?: JsonNullableFilter<"transaction">
    isRealMoney?: BoolFilter<"transaction"> | boolean
    paymentMethod?: StringNullableFilter<"transaction"> | string | null
    paymentDetails?: JsonNullableFilter<"transaction">
    createdAt?: DateTimeFilter<"transaction"> | Date | string
    processedAt?: DateTimeNullableFilter<"transaction"> | Date | string | null
    gameSessionId?: StringNullableFilter<"transaction"> | string | null
    profileId?: StringFilter<"transaction"> | string
  }

  export type userCreateWithoutNotificationInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
  }

  export type userUpsertWithoutNotificationInput = {
    update: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
    create: XOR<userCreateWithoutNotificationInput, userUncheckedCreateWithoutNotificationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutNotificationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutNotificationInput, userUncheckedUpdateWithoutNotificationInput>
  }

  export type userUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type bankCreateWithoutOperatorInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    profile?: profileCreateNestedManyWithoutBankInput
  }

  export type bankUncheckedCreateWithoutOperatorInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    profile?: profileUncheckedCreateNestedManyWithoutBankInput
  }

  export type bankCreateOrConnectWithoutOperatorInput = {
    where: bankWhereUniqueInput
    create: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput>
  }

  export type bankCreateManyOperatorInputEnvelope = {
    data: bankCreateManyOperatorInput | bankCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutOperatorInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOperatorInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOperatorInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOperatorInput, userUncheckedCreateWithoutOperatorInput>
  }

  export type operatorgameCreateWithoutOperatorInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    gamesession?: gamesessionCreateNestedManyWithoutOperatorgameInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameUncheckedCreateWithoutOperatorInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutOperatorgameInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameCreateOrConnectWithoutOperatorInput = {
    where: operatorgameWhereUniqueInput
    create: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput>
  }

  export type operatorgameCreateManyOperatorInputEnvelope = {
    data: operatorgameCreateManyOperatorInput | operatorgameCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type profileCreateWithoutOperatorInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    bank: bankCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutOperatorInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutOperatorInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput>
  }

  export type profileCreateManyOperatorInputEnvelope = {
    data: profileCreateManyOperatorInput | profileCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type tournamentCreateWithoutOperatorInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutOperatorInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput>
  }

  export type tournamentCreateManyOperatorInputEnvelope = {
    data: tournamentCreateManyOperatorInput | tournamentCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type bankUpsertWithWhereUniqueWithoutOperatorInput = {
    where: bankWhereUniqueInput
    update: XOR<bankUpdateWithoutOperatorInput, bankUncheckedUpdateWithoutOperatorInput>
    create: XOR<bankCreateWithoutOperatorInput, bankUncheckedCreateWithoutOperatorInput>
  }

  export type bankUpdateWithWhereUniqueWithoutOperatorInput = {
    where: bankWhereUniqueInput
    data: XOR<bankUpdateWithoutOperatorInput, bankUncheckedUpdateWithoutOperatorInput>
  }

  export type bankUpdateManyWithWhereWithoutOperatorInput = {
    where: bankScalarWhereInput
    data: XOR<bankUpdateManyMutationInput, bankUncheckedUpdateManyWithoutOperatorInput>
  }

  export type bankScalarWhereInput = {
    AND?: bankScalarWhereInput | bankScalarWhereInput[]
    OR?: bankScalarWhereInput[]
    NOT?: bankScalarWhereInput | bankScalarWhereInput[]
    id?: StringFilter<"bank"> | string
    name?: StringFilter<"bank"> | string
    currency?: StringFilter<"bank"> | string
    isActive?: BoolFilter<"bank"> | boolean
    createdAt?: DateTimeFilter<"bank"> | Date | string
    operatorId?: StringFilter<"bank"> | string
  }

  export type userUpsertWithoutOperatorInput = {
    update: XOR<userUpdateWithoutOperatorInput, userUncheckedUpdateWithoutOperatorInput>
    create: XOR<userCreateWithoutOperatorInput, userUncheckedCreateWithoutOperatorInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOperatorInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOperatorInput, userUncheckedUpdateWithoutOperatorInput>
  }

  export type userUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type operatorgameUpsertWithWhereUniqueWithoutOperatorInput = {
    where: operatorgameWhereUniqueInput
    update: XOR<operatorgameUpdateWithoutOperatorInput, operatorgameUncheckedUpdateWithoutOperatorInput>
    create: XOR<operatorgameCreateWithoutOperatorInput, operatorgameUncheckedCreateWithoutOperatorInput>
  }

  export type operatorgameUpdateWithWhereUniqueWithoutOperatorInput = {
    where: operatorgameWhereUniqueInput
    data: XOR<operatorgameUpdateWithoutOperatorInput, operatorgameUncheckedUpdateWithoutOperatorInput>
  }

  export type operatorgameUpdateManyWithWhereWithoutOperatorInput = {
    where: operatorgameScalarWhereInput
    data: XOR<operatorgameUpdateManyMutationInput, operatorgameUncheckedUpdateManyWithoutOperatorInput>
  }

  export type operatorgameScalarWhereInput = {
    AND?: operatorgameScalarWhereInput | operatorgameScalarWhereInput[]
    OR?: operatorgameScalarWhereInput[]
    NOT?: operatorgameScalarWhereInput | operatorgameScalarWhereInput[]
    id?: StringFilter<"operatorgame"> | string
    name?: StringFilter<"operatorgame"> | string
    slug?: StringFilter<"operatorgame"> | string
    description?: StringNullableFilter<"operatorgame"> | string | null
    thumbnail?: StringNullableFilter<"operatorgame"> | string | null
    minBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    maxBet?: DecimalNullableFilter<"operatorgame"> | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFilter<"operatorgame"> | number
    isActive?: BoolFilter<"operatorgame"> | boolean
    isPromoted?: BoolFilter<"operatorgame"> | boolean
    createdAt?: DateTimeFilter<"operatorgame"> | Date | string
    updatedAt?: DateTimeFilter<"operatorgame"> | Date | string
    operatorId?: StringFilter<"operatorgame"> | string
  }

  export type profileUpsertWithWhereUniqueWithoutOperatorInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutOperatorInput, profileUncheckedUpdateWithoutOperatorInput>
    create: XOR<profileCreateWithoutOperatorInput, profileUncheckedCreateWithoutOperatorInput>
  }

  export type profileUpdateWithWhereUniqueWithoutOperatorInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutOperatorInput, profileUncheckedUpdateWithoutOperatorInput>
  }

  export type profileUpdateManyWithWhereWithoutOperatorInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutOperatorInput>
  }

  export type tournamentUpsertWithWhereUniqueWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    update: XOR<tournamentUpdateWithoutOperatorInput, tournamentUncheckedUpdateWithoutOperatorInput>
    create: XOR<tournamentCreateWithoutOperatorInput, tournamentUncheckedCreateWithoutOperatorInput>
  }

  export type tournamentUpdateWithWhereUniqueWithoutOperatorInput = {
    where: tournamentWhereUniqueInput
    data: XOR<tournamentUpdateWithoutOperatorInput, tournamentUncheckedUpdateWithoutOperatorInput>
  }

  export type tournamentUpdateManyWithWhereWithoutOperatorInput = {
    where: tournamentScalarWhereInput
    data: XOR<tournamentUpdateManyMutationInput, tournamentUncheckedUpdateManyWithoutOperatorInput>
  }

  export type tournamentScalarWhereInput = {
    AND?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
    OR?: tournamentScalarWhereInput[]
    NOT?: tournamentScalarWhereInput | tournamentScalarWhereInput[]
    id?: StringFilter<"tournament"> | string
    name?: StringFilter<"tournament"> | string
    description?: StringNullableFilter<"tournament"> | string | null
    startTime?: DateTimeFilter<"tournament"> | Date | string
    endTime?: DateTimeFilter<"tournament"> | Date | string
    entryFee?: DecimalNullableFilter<"tournament"> | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFilter<"tournament"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"tournament"> | boolean
    createdAt?: DateTimeFilter<"tournament"> | Date | string
    updatedAt?: DateTimeFilter<"tournament"> | Date | string
    operatorId?: StringFilter<"tournament"> | string
    leaderboard?: JsonNullableFilter<"tournament">
  }

  export type gamesessionCreateWithoutOperatorgameInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    profile: profileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    transaction?: transactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutOperatorgameInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    transaction?: transactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutOperatorgameInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput>
  }

  export type gamesessionCreateManyOperatorgameInputEnvelope = {
    data: gamesessionCreateManyOperatorgameInput | gamesessionCreateManyOperatorgameInput[]
    skipDuplicates?: boolean
  }

  export type operatorCreateWithoutOperatorgameInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankCreateNestedManyWithoutOperatorInput
    user: userCreateNestedOneWithoutOperatorInput
    profile?: profileCreateNestedManyWithoutOperatorInput
    tournament?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateWithoutOperatorgameInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
    bank?: bankUncheckedCreateNestedManyWithoutOperatorInput
    profile?: profileUncheckedCreateNestedManyWithoutOperatorInput
    tournament?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorCreateOrConnectWithoutOperatorgameInput = {
    where: operatorWhereUniqueInput
    create: XOR<operatorCreateWithoutOperatorgameInput, operatorUncheckedCreateWithoutOperatorgameInput>
  }

  export type tournamentgameCreateWithoutOperatorgameInput = {
    id: string
    multiplier?: number
    tournament: tournamentCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateWithoutOperatorgameInput = {
    id: string
    multiplier?: number
    tournamentId: string
  }

  export type tournamentgameCreateOrConnectWithoutOperatorgameInput = {
    where: tournamentgameWhereUniqueInput
    create: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput>
  }

  export type tournamentgameCreateManyOperatorgameInputEnvelope = {
    data: tournamentgameCreateManyOperatorgameInput | tournamentgameCreateManyOperatorgameInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionUpsertWithWhereUniqueWithoutOperatorgameInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutOperatorgameInput, gamesessionUncheckedUpdateWithoutOperatorgameInput>
    create: XOR<gamesessionCreateWithoutOperatorgameInput, gamesessionUncheckedCreateWithoutOperatorgameInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutOperatorgameInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutOperatorgameInput, gamesessionUncheckedUpdateWithoutOperatorgameInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutOperatorgameInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutOperatorgameInput>
  }

  export type gamesessionScalarWhereInput = {
    AND?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
    OR?: gamesessionScalarWhereInput[]
    NOT?: gamesessionScalarWhereInput | gamesessionScalarWhereInput[]
    id?: StringFilter<"gamesession"> | string
    startTime?: DateTimeFilter<"gamesession"> | Date | string
    endTime?: DateTimeNullableFilter<"gamesession"> | Date | string | null
    betAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    winAmount?: DecimalNullableFilter<"gamesession"> | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFilter<"gamesession"> | number
    metadata?: JsonNullableFilter<"gamesession">
    gameId?: StringFilter<"gamesession"> | string
    tournamentId?: StringNullableFilter<"gamesession"> | string | null
    active?: BoolFilter<"gamesession"> | boolean
    profileId?: StringFilter<"gamesession"> | string
  }

  export type operatorUpsertWithoutOperatorgameInput = {
    update: XOR<operatorUpdateWithoutOperatorgameInput, operatorUncheckedUpdateWithoutOperatorgameInput>
    create: XOR<operatorCreateWithoutOperatorgameInput, operatorUncheckedCreateWithoutOperatorgameInput>
    where?: operatorWhereInput
  }

  export type operatorUpdateToOneWithWhereWithoutOperatorgameInput = {
    where?: operatorWhereInput
    data: XOR<operatorUpdateWithoutOperatorgameInput, operatorUncheckedUpdateWithoutOperatorgameInput>
  }

  export type operatorUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUpdateManyWithoutOperatorNestedInput
    user?: userUpdateOneRequiredWithoutOperatorNestedInput
    profile?: profileUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    bank?: bankUncheckedUpdateManyWithoutOperatorNestedInput
    profile?: profileUncheckedUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type tournamentgameUpsertWithWhereUniqueWithoutOperatorgameInput = {
    where: tournamentgameWhereUniqueInput
    update: XOR<tournamentgameUpdateWithoutOperatorgameInput, tournamentgameUncheckedUpdateWithoutOperatorgameInput>
    create: XOR<tournamentgameCreateWithoutOperatorgameInput, tournamentgameUncheckedCreateWithoutOperatorgameInput>
  }

  export type tournamentgameUpdateWithWhereUniqueWithoutOperatorgameInput = {
    where: tournamentgameWhereUniqueInput
    data: XOR<tournamentgameUpdateWithoutOperatorgameInput, tournamentgameUncheckedUpdateWithoutOperatorgameInput>
  }

  export type tournamentgameUpdateManyWithWhereWithoutOperatorgameInput = {
    where: tournamentgameScalarWhereInput
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyWithoutOperatorgameInput>
  }

  export type tournamentgameScalarWhereInput = {
    AND?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
    OR?: tournamentgameScalarWhereInput[]
    NOT?: tournamentgameScalarWhereInput | tournamentgameScalarWhereInput[]
    id?: StringFilter<"tournamentgame"> | string
    multiplier?: FloatFilter<"tournamentgame"> | number
    tournamentId?: StringFilter<"tournamentgame"> | string
    gameId?: StringFilter<"tournamentgame"> | string
  }

  export type gamesessionCreateWithoutProfileInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    operatorgame: operatorgameCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
    transaction?: transactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutProfileInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    transaction?: transactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput>
  }

  export type gamesessionCreateManyProfileInputEnvelope = {
    data: gamesessionCreateManyProfileInput | gamesessionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type bankCreateWithoutProfileInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    operator: operatorCreateNestedOneWithoutBankInput
  }

  export type bankUncheckedCreateWithoutProfileInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
    operatorId: string
  }

  export type bankCreateOrConnectWithoutProfileInput = {
    where: bankWhereUniqueInput
    create: XOR<bankCreateWithoutProfileInput, bankUncheckedCreateWithoutProfileInput>
  }

  export type operatorCreateWithoutProfileInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankCreateNestedManyWithoutOperatorInput
    user: userCreateNestedOneWithoutOperatorInput
    operatorgame?: operatorgameCreateNestedManyWithoutOperatorInput
    tournament?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateWithoutProfileInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
    bank?: bankUncheckedCreateNestedManyWithoutOperatorInput
    operatorgame?: operatorgameUncheckedCreateNestedManyWithoutOperatorInput
    tournament?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorCreateOrConnectWithoutProfileInput = {
    where: operatorWhereUniqueInput
    create: XOR<operatorCreateWithoutProfileInput, operatorUncheckedCreateWithoutProfileInput>
  }

  export type userCreateWithoutProfile_profile_userIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfile_profile_userIdTouserInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfile_profile_userIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfile_profile_userIdTouserInput, userUncheckedCreateWithoutProfile_profile_userIdTouserInput>
  }

  export type tournamententryCreateWithoutProfileInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
    user: userCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutProfileInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type tournamententryCreateOrConnectWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput>
  }

  export type tournamententryCreateManyProfileInputEnvelope = {
    data: tournamententryCreateManyProfileInput | tournamententryCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type transactionCreateWithoutProfileInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gamesession?: gamesessionCreateNestedOneWithoutTransactionInput
  }

  export type transactionUncheckedCreateWithoutProfileInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
  }

  export type transactionCreateOrConnectWithoutProfileInput = {
    where: transactionWhereUniqueInput
    create: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput>
  }

  export type transactionCreateManyProfileInputEnvelope = {
    data: transactionCreateManyProfileInput | transactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionUpsertWithWhereUniqueWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutProfileInput, gamesessionUncheckedUpdateWithoutProfileInput>
    create: XOR<gamesessionCreateWithoutProfileInput, gamesessionUncheckedCreateWithoutProfileInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutProfileInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutProfileInput, gamesessionUncheckedUpdateWithoutProfileInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutProfileInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutProfileInput>
  }

  export type bankUpsertWithoutProfileInput = {
    update: XOR<bankUpdateWithoutProfileInput, bankUncheckedUpdateWithoutProfileInput>
    create: XOR<bankCreateWithoutProfileInput, bankUncheckedCreateWithoutProfileInput>
    where?: bankWhereInput
  }

  export type bankUpdateToOneWithWhereWithoutProfileInput = {
    where?: bankWhereInput
    data: XOR<bankUpdateWithoutProfileInput, bankUncheckedUpdateWithoutProfileInput>
  }

  export type bankUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operator?: operatorUpdateOneRequiredWithoutBankNestedInput
  }

  export type bankUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
  }

  export type operatorUpsertWithoutProfileInput = {
    update: XOR<operatorUpdateWithoutProfileInput, operatorUncheckedUpdateWithoutProfileInput>
    create: XOR<operatorCreateWithoutProfileInput, operatorUncheckedCreateWithoutProfileInput>
    where?: operatorWhereInput
  }

  export type operatorUpdateToOneWithWhereWithoutProfileInput = {
    where?: operatorWhereInput
    data: XOR<operatorUpdateWithoutProfileInput, operatorUncheckedUpdateWithoutProfileInput>
  }

  export type operatorUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUpdateManyWithoutOperatorNestedInput
    user?: userUpdateOneRequiredWithoutOperatorNestedInput
    operatorgame?: operatorgameUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    bank?: bankUncheckedUpdateManyWithoutOperatorNestedInput
    operatorgame?: operatorgameUncheckedUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type userUpsertWithoutProfile_profile_userIdTouserInput = {
    update: XOR<userUpdateWithoutProfile_profile_userIdTouserInput, userUncheckedUpdateWithoutProfile_profile_userIdTouserInput>
    create: XOR<userCreateWithoutProfile_profile_userIdTouserInput, userUncheckedCreateWithoutProfile_profile_userIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfile_profile_userIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfile_profile_userIdTouserInput, userUncheckedUpdateWithoutProfile_profile_userIdTouserInput>
  }

  export type userUpdateWithoutProfile_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfile_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tournamententryUpsertWithWhereUniqueWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutProfileInput, tournamententryUncheckedUpdateWithoutProfileInput>
    create: XOR<tournamententryCreateWithoutProfileInput, tournamententryUncheckedCreateWithoutProfileInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutProfileInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutProfileInput, tournamententryUncheckedUpdateWithoutProfileInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutProfileInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutProfileInput>
  }

  export type tournamententryScalarWhereInput = {
    AND?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
    OR?: tournamententryScalarWhereInput[]
    NOT?: tournamententryScalarWhereInput | tournamententryScalarWhereInput[]
    id?: StringFilter<"tournamententry"> | string
    score?: IntFilter<"tournamententry"> | number
    wagered?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    won?: DecimalFilter<"tournamententry"> | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFilter<"tournamententry"> | Date | string
    userId?: StringFilter<"tournamententry"> | string
    tournamentId?: StringFilter<"tournamententry"> | string
    profileId?: StringFilter<"tournamententry"> | string
  }

  export type transactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: transactionWhereUniqueInput
    update: XOR<transactionUpdateWithoutProfileInput, transactionUncheckedUpdateWithoutProfileInput>
    create: XOR<transactionCreateWithoutProfileInput, transactionUncheckedCreateWithoutProfileInput>
  }

  export type transactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: transactionWhereUniqueInput
    data: XOR<transactionUpdateWithoutProfileInput, transactionUncheckedUpdateWithoutProfileInput>
  }

  export type transactionUpdateManyWithWhereWithoutProfileInput = {
    where: transactionScalarWhereInput
    data: XOR<transactionUpdateManyMutationInput, transactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type userCreateWithoutSessionInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSessionInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSessionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
  }

  export type userUpsertWithoutSessionInput = {
    update: XOR<userUpdateWithoutSessionInput, userUncheckedUpdateWithoutSessionInput>
    create: XOR<userCreateWithoutSessionInput, userUncheckedCreateWithoutSessionInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutSessionInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutSessionInput, userUncheckedUpdateWithoutSessionInput>
  }

  export type userUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type gamesessionCreateWithoutTournamentInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    operatorgame: operatorgameCreateNestedOneWithoutGamesessionInput
    profile: profileCreateNestedOneWithoutGamesessionInput
    transaction?: transactionCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutTournamentInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
    transaction?: transactionUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type gamesessionCreateManyTournamentInputEnvelope = {
    data: gamesessionCreateManyTournamentInput | gamesessionCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type operatorCreateWithoutTournamentInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankCreateNestedManyWithoutOperatorInput
    user: userCreateNestedOneWithoutOperatorInput
    operatorgame?: operatorgameCreateNestedManyWithoutOperatorInput
    profile?: profileCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateWithoutTournamentInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    ownerId: string
    bank?: bankUncheckedCreateNestedManyWithoutOperatorInput
    operatorgame?: operatorgameUncheckedCreateNestedManyWithoutOperatorInput
    profile?: profileUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorCreateOrConnectWithoutTournamentInput = {
    where: operatorWhereUniqueInput
    create: XOR<operatorCreateWithoutTournamentInput, operatorUncheckedCreateWithoutTournamentInput>
  }

  export type tournamententryCreateWithoutTournamentInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    profile: profileCreateNestedOneWithoutTournamententryInput
    user: userCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutTournamentInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type tournamententryCreateOrConnectWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type tournamententryCreateManyTournamentInputEnvelope = {
    data: tournamententryCreateManyTournamentInput | tournamententryCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type tournamentgameCreateWithoutTournamentInput = {
    id: string
    multiplier?: number
    operatorgame: operatorgameCreateNestedOneWithoutTournamentgameInput
  }

  export type tournamentgameUncheckedCreateWithoutTournamentInput = {
    id: string
    multiplier?: number
    gameId: string
  }

  export type tournamentgameCreateOrConnectWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    create: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type tournamentgameCreateManyTournamentInputEnvelope = {
    data: tournamentgameCreateManyTournamentInput | tournamentgameCreateManyTournamentInput[]
    skipDuplicates?: boolean
  }

  export type gamesessionUpsertWithWhereUniqueWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    update: XOR<gamesessionUpdateWithoutTournamentInput, gamesessionUncheckedUpdateWithoutTournamentInput>
    create: XOR<gamesessionCreateWithoutTournamentInput, gamesessionUncheckedCreateWithoutTournamentInput>
  }

  export type gamesessionUpdateWithWhereUniqueWithoutTournamentInput = {
    where: gamesessionWhereUniqueInput
    data: XOR<gamesessionUpdateWithoutTournamentInput, gamesessionUncheckedUpdateWithoutTournamentInput>
  }

  export type gamesessionUpdateManyWithWhereWithoutTournamentInput = {
    where: gamesessionScalarWhereInput
    data: XOR<gamesessionUpdateManyMutationInput, gamesessionUncheckedUpdateManyWithoutTournamentInput>
  }

  export type operatorUpsertWithoutTournamentInput = {
    update: XOR<operatorUpdateWithoutTournamentInput, operatorUncheckedUpdateWithoutTournamentInput>
    create: XOR<operatorCreateWithoutTournamentInput, operatorUncheckedCreateWithoutTournamentInput>
    where?: operatorWhereInput
  }

  export type operatorUpdateToOneWithWhereWithoutTournamentInput = {
    where?: operatorWhereInput
    data: XOR<operatorUpdateWithoutTournamentInput, operatorUncheckedUpdateWithoutTournamentInput>
  }

  export type operatorUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUpdateManyWithoutOperatorNestedInput
    user?: userUpdateOneRequiredWithoutOperatorNestedInput
    operatorgame?: operatorgameUpdateManyWithoutOperatorNestedInput
    profile?: profileUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownerId?: StringFieldUpdateOperationsInput | string
    bank?: bankUncheckedUpdateManyWithoutOperatorNestedInput
    operatorgame?: operatorgameUncheckedUpdateManyWithoutOperatorNestedInput
    profile?: profileUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type tournamententryUpsertWithWhereUniqueWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutTournamentInput, tournamententryUncheckedUpdateWithoutTournamentInput>
    create: XOR<tournamententryCreateWithoutTournamentInput, tournamententryUncheckedCreateWithoutTournamentInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutTournamentInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutTournamentInput, tournamententryUncheckedUpdateWithoutTournamentInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutTournamentInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutTournamentInput>
  }

  export type tournamentgameUpsertWithWhereUniqueWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    update: XOR<tournamentgameUpdateWithoutTournamentInput, tournamentgameUncheckedUpdateWithoutTournamentInput>
    create: XOR<tournamentgameCreateWithoutTournamentInput, tournamentgameUncheckedCreateWithoutTournamentInput>
  }

  export type tournamentgameUpdateWithWhereUniqueWithoutTournamentInput = {
    where: tournamentgameWhereUniqueInput
    data: XOR<tournamentgameUpdateWithoutTournamentInput, tournamentgameUncheckedUpdateWithoutTournamentInput>
  }

  export type tournamentgameUpdateManyWithWhereWithoutTournamentInput = {
    where: tournamentgameScalarWhereInput
    data: XOR<tournamentgameUpdateManyMutationInput, tournamentgameUncheckedUpdateManyWithoutTournamentInput>
  }

  export type profileCreateWithoutTournamententryInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    bank: bankCreateNestedOneWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutTournamententryInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutTournamententryInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutTournamententryInput, profileUncheckedCreateWithoutTournamententryInput>
  }

  export type tournamentCreateWithoutTournamententryInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: operatorCreateNestedOneWithoutTournamentInput
    tournamentgame?: tournamentgameCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutTournamententryInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamentgame?: tournamentgameUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutTournamententryInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
  }

  export type userCreateWithoutTournamententryInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTournamententryInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTournamententryInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTournamententryInput, userUncheckedCreateWithoutTournamententryInput>
  }

  export type profileUpsertWithoutTournamententryInput = {
    update: XOR<profileUpdateWithoutTournamententryInput, profileUncheckedUpdateWithoutTournamententryInput>
    create: XOR<profileCreateWithoutTournamententryInput, profileUncheckedCreateWithoutTournamententryInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutTournamententryInput, profileUncheckedUpdateWithoutTournamententryInput>
  }

  export type profileUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type tournamentUpsertWithoutTournamententryInput = {
    update: XOR<tournamentUpdateWithoutTournamententryInput, tournamentUncheckedUpdateWithoutTournamententryInput>
    create: XOR<tournamentCreateWithoutTournamententryInput, tournamentUncheckedCreateWithoutTournamententryInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutTournamententryInput, tournamentUncheckedUpdateWithoutTournamententryInput>
  }

  export type tournamentUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: operatorUpdateOneRequiredWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type userUpsertWithoutTournamententryInput = {
    update: XOR<userUpdateWithoutTournamententryInput, userUncheckedUpdateWithoutTournamententryInput>
    create: XOR<userCreateWithoutTournamententryInput, userUncheckedCreateWithoutTournamententryInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTournamententryInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTournamententryInput, userUncheckedUpdateWithoutTournamententryInput>
  }

  export type userUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTournamententryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type operatorgameCreateWithoutTournamentgameInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    gamesession?: gamesessionCreateNestedManyWithoutOperatorgameInput
    operator: operatorCreateNestedOneWithoutOperatorgameInput
  }

  export type operatorgameUncheckedCreateWithoutTournamentgameInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutOperatorgameInput
  }

  export type operatorgameCreateOrConnectWithoutTournamentgameInput = {
    where: operatorgameWhereUniqueInput
    create: XOR<operatorgameCreateWithoutTournamentgameInput, operatorgameUncheckedCreateWithoutTournamentgameInput>
  }

  export type tournamentCreateWithoutTournamentgameInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionCreateNestedManyWithoutTournamentInput
    operator: operatorCreateNestedOneWithoutTournamentInput
    tournamententry?: tournamententryCreateNestedManyWithoutTournamentInput
  }

  export type tournamentUncheckedCreateWithoutTournamentgameInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    operatorId: string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutTournamentInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type tournamentCreateOrConnectWithoutTournamentgameInput = {
    where: tournamentWhereUniqueInput
    create: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
  }

  export type operatorgameUpsertWithoutTournamentgameInput = {
    update: XOR<operatorgameUpdateWithoutTournamentgameInput, operatorgameUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<operatorgameCreateWithoutTournamentgameInput, operatorgameUncheckedCreateWithoutTournamentgameInput>
    where?: operatorgameWhereInput
  }

  export type operatorgameUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: operatorgameWhereInput
    data: XOR<operatorgameUpdateWithoutTournamentgameInput, operatorgameUncheckedUpdateWithoutTournamentgameInput>
  }

  export type operatorgameUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUpdateManyWithoutOperatorgameNestedInput
    operator?: operatorUpdateOneRequiredWithoutOperatorgameNestedInput
  }

  export type operatorgameUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutOperatorgameNestedInput
  }

  export type tournamentUpsertWithoutTournamentgameInput = {
    update: XOR<tournamentUpdateWithoutTournamentgameInput, tournamentUncheckedUpdateWithoutTournamentgameInput>
    create: XOR<tournamentCreateWithoutTournamentgameInput, tournamentUncheckedCreateWithoutTournamentgameInput>
    where?: tournamentWhereInput
  }

  export type tournamentUpdateToOneWithWhereWithoutTournamentgameInput = {
    where?: tournamentWhereInput
    data: XOR<tournamentUpdateWithoutTournamentgameInput, tournamentUncheckedUpdateWithoutTournamentgameInput>
  }

  export type tournamentUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    operator?: operatorUpdateOneRequiredWithoutTournamentNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutTournamentgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operatorId?: StringFieldUpdateOperationsInput | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type gamesessionCreateWithoutTransactionInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean
    chatroom?: chatroomCreateNestedManyWithoutGamesessionInput
    operatorgame: operatorgameCreateNestedOneWithoutGamesessionInput
    profile: profileCreateNestedOneWithoutGamesessionInput
    tournament?: tournamentCreateNestedOneWithoutGamesessionInput
  }

  export type gamesessionUncheckedCreateWithoutTransactionInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
    profileId: string
    chatroom?: chatroomUncheckedCreateNestedManyWithoutGamesessionInput
  }

  export type gamesessionCreateOrConnectWithoutTransactionInput = {
    where: gamesessionWhereUniqueInput
    create: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
  }

  export type profileCreateWithoutTransactionInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    bank: bankCreateNestedOneWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    user_profile_userIdTouser: userCreateNestedOneWithoutProfile_profile_userIdTouserInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutTransactionInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutTransactionInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutTransactionInput, profileUncheckedCreateWithoutTransactionInput>
  }

  export type gamesessionUpsertWithoutTransactionInput = {
    update: XOR<gamesessionUpdateWithoutTransactionInput, gamesessionUncheckedUpdateWithoutTransactionInput>
    create: XOR<gamesessionCreateWithoutTransactionInput, gamesessionUncheckedCreateWithoutTransactionInput>
    where?: gamesessionWhereInput
  }

  export type gamesessionUpdateToOneWithWhereWithoutTransactionInput = {
    where?: gamesessionWhereInput
    data: XOR<gamesessionUpdateWithoutTransactionInput, gamesessionUncheckedUpdateWithoutTransactionInput>
  }

  export type gamesessionUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    operatorgame?: operatorgameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: profileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type profileUpsertWithoutTransactionInput = {
    update: XOR<profileUpdateWithoutTransactionInput, profileUncheckedUpdateWithoutTransactionInput>
    create: XOR<profileCreateWithoutTransactionInput, profileUncheckedCreateWithoutTransactionInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutTransactionInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutTransactionInput, profileUncheckedUpdateWithoutTransactionInput>
  }

  export type profileUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type RainBetCreateWithoutUserInput = {
    id: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
    RainHistory: RainHistoryCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutUserInput = {
    id: string
    rainHistoryId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutUserInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetCreateManyUserInputEnvelope = {
    data: RainBetCreateManyUserInput | RainBetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainHistoryCreateWithoutUserInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutUserInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryCreateManyUserInputEnvelope = {
    data: RainHistoryCreateManyUserInput | RainHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainTipCreateWithoutUserInput = {
    id: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutUserInput = {
    id: string
    rainHistoryId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutUserInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipCreateManyUserInputEnvelope = {
    data: RainTipCreateManyUserInput | RainTipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutUserInput = {
    id: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
    RainHistory: RainHistoryCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutUserInput = {
    id: string
    rainHistoryId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerCreateManyUserInputEnvelope = {
    data: RainWinnerCreateManyUserInput | RainWinnerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type chatmessageCreateWithoutUserInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatroom?: chatroomCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutUserInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type chatmessageCreateOrConnectWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput>
  }

  export type chatmessageCreateManyUserInputEnvelope = {
    data: chatmessageCreateManyUserInput | chatmessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_friendIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    user_friendship_userIdTouser: userCreateNestedOneWithoutFriendship_friendship_userIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_friendIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_friendIdTouserInput | friendshipCreateManyUser_friendship_friendIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type friendshipCreateWithoutUser_friendship_userIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    user_friendship_friendIdTouser: userCreateNestedOneWithoutFriendship_friendship_friendIdTouserInput
  }

  export type friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    friendId: string
  }

  export type friendshipCreateOrConnectWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    create: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipCreateManyUser_friendship_userIdTouserInputEnvelope = {
    data: friendshipCreateManyUser_friendship_userIdTouserInput | friendshipCreateManyUser_friendship_userIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutUserInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateManyUserInputEnvelope = {
    data: notificationCreateManyUserInput | notificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type operatorCreateWithoutUserInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankCreateNestedManyWithoutOperatorInput
    operatorgame?: operatorgameCreateNestedManyWithoutOperatorInput
    profile?: profileCreateNestedManyWithoutOperatorInput
    tournament?: tournamentCreateNestedManyWithoutOperatorInput
  }

  export type operatorUncheckedCreateWithoutUserInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    bank?: bankUncheckedCreateNestedManyWithoutOperatorInput
    operatorgame?: operatorgameUncheckedCreateNestedManyWithoutOperatorInput
    profile?: profileUncheckedCreateNestedManyWithoutOperatorInput
    tournament?: tournamentUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type operatorCreateOrConnectWithoutUserInput = {
    where: operatorWhereUniqueInput
    create: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput>
  }

  export type operatorCreateManyUserInputEnvelope = {
    data: operatorCreateManyUserInput | operatorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type profileCreateWithoutUser_profile_userIdTouserInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    gamesession?: gamesessionCreateNestedManyWithoutProfileInput
    bank: bankCreateNestedOneWithoutProfileInput
    operator: operatorCreateNestedOneWithoutProfileInput
    tournamententry?: tournamententryCreateNestedManyWithoutProfileInput
    transaction?: transactionCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutUser_profile_userIdTouserInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    bankId: string
    shopId: string
    gamesession?: gamesessionUncheckedCreateNestedManyWithoutProfileInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutProfileInput
    transaction?: transactionUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutUser_profile_userIdTouserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput>
  }

  export type profileCreateManyUser_profile_userIdTouserInputEnvelope = {
    data: profileCreateManyUser_profile_userIdTouserInput | profileCreateManyUser_profile_userIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type sessionCreateWithoutUserInput = {
    id: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
  }

  export type sessionUncheckedCreateWithoutUserInput = {
    id: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
  }

  export type sessionCreateOrConnectWithoutUserInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionCreateManyUserInputEnvelope = {
    data: sessionCreateManyUserInput | sessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type tournamententryCreateWithoutUserInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    profile: profileCreateNestedOneWithoutTournamententryInput
    tournament: tournamentCreateNestedOneWithoutTournamententryInput
  }

  export type tournamententryUncheckedCreateWithoutUserInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type tournamententryCreateOrConnectWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    create: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput>
  }

  export type tournamententryCreateManyUserInputEnvelope = {
    data: tournamententryCreateManyUserInput | tournamententryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userachievementCreateWithoutUserInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    achievement: achievementCreateNestedOneWithoutUserachievementInput
  }

  export type userachievementUncheckedCreateWithoutUserInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    achievementId: string
  }

  export type userachievementCreateOrConnectWithoutUserInput = {
    where: userachievementWhereUniqueInput
    create: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput>
  }

  export type userachievementCreateManyUserInputEnvelope = {
    data: userachievementCreateManyUserInput | userachievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RainBetUpsertWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
    create: XOR<RainBetCreateWithoutUserInput, RainBetUncheckedCreateWithoutUserInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutUserInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutUserInput, RainBetUncheckedUpdateWithoutUserInput>
  }

  export type RainBetUpdateManyWithWhereWithoutUserInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutUserInput>
  }

  export type RainBetScalarWhereInput = {
    AND?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    OR?: RainBetScalarWhereInput[]
    NOT?: RainBetScalarWhereInput | RainBetScalarWhereInput[]
    id?: StringFilter<"RainBet"> | string
    rainHistoryId?: StringFilter<"RainBet"> | string
    userId?: StringFilter<"RainBet"> | string
    betAmount?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    odds?: DecimalFilter<"RainBet"> | Decimal | DecimalJsLike | number | string
    outcome?: StringNullableFilter<"RainBet"> | string | null
    settledAt?: DateTimeNullableFilter<"RainBet"> | Date | string | null
  }

  export type RainHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    update: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<RainHistoryCreateWithoutUserInput, RainHistoryUncheckedCreateWithoutUserInput>
  }

  export type RainHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: RainHistoryWhereUniqueInput
    data: XOR<RainHistoryUpdateWithoutUserInput, RainHistoryUncheckedUpdateWithoutUserInput>
  }

  export type RainHistoryUpdateManyWithWhereWithoutUserInput = {
    where: RainHistoryScalarWhereInput
    data: XOR<RainHistoryUpdateManyMutationInput, RainHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type RainHistoryScalarWhereInput = {
    AND?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    OR?: RainHistoryScalarWhereInput[]
    NOT?: RainHistoryScalarWhereInput | RainHistoryScalarWhereInput[]
    id?: StringFilter<"RainHistory"> | string
    userId?: StringFilter<"RainHistory"> | string
    amount?: DecimalFilter<"RainHistory"> | Decimal | DecimalJsLike | number | string
    rainType?: StringFilter<"RainHistory"> | string
    createdAt?: DateTimeFilter<"RainHistory"> | Date | string
  }

  export type RainTipUpsertWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
    create: XOR<RainTipCreateWithoutUserInput, RainTipUncheckedCreateWithoutUserInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutUserInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutUserInput, RainTipUncheckedUpdateWithoutUserInput>
  }

  export type RainTipUpdateManyWithWhereWithoutUserInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutUserInput>
  }

  export type RainTipScalarWhereInput = {
    AND?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    OR?: RainTipScalarWhereInput[]
    NOT?: RainTipScalarWhereInput | RainTipScalarWhereInput[]
    id?: StringFilter<"RainTip"> | string
    rainHistoryId?: StringFilter<"RainTip"> | string
    userId?: StringFilter<"RainTip"> | string
    tipAmount?: DecimalFilter<"RainTip"> | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFilter<"RainTip"> | Date | string
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
    create: XOR<RainWinnerCreateWithoutUserInput, RainWinnerUncheckedCreateWithoutUserInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutUserInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutUserInput, RainWinnerUncheckedUpdateWithoutUserInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutUserInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutUserInput>
  }

  export type RainWinnerScalarWhereInput = {
    AND?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    OR?: RainWinnerScalarWhereInput[]
    NOT?: RainWinnerScalarWhereInput | RainWinnerScalarWhereInput[]
    id?: StringFilter<"RainWinner"> | string
    rainHistoryId?: StringFilter<"RainWinner"> | string
    userId?: StringFilter<"RainWinner"> | string
    wonAmount?: DecimalFilter<"RainWinner"> | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFilter<"RainWinner"> | Date | string
  }

  export type chatmessageUpsertWithWhereUniqueWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutUserInput, chatmessageUncheckedUpdateWithoutUserInput>
    create: XOR<chatmessageCreateWithoutUserInput, chatmessageUncheckedCreateWithoutUserInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutUserInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutUserInput, chatmessageUncheckedUpdateWithoutUserInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutUserInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutUserInput>
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_friendIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_friendIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserInput>
  }

  export type friendshipScalarWhereInput = {
    AND?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    OR?: friendshipScalarWhereInput[]
    NOT?: friendshipScalarWhereInput | friendshipScalarWhereInput[]
    id?: StringFilter<"friendship"> | string
    status?: EnumFriendshipStatusFilter<"friendship"> | $Enums.FriendshipStatus
    createdAt?: DateTimeFilter<"friendship"> | Date | string
    updatedAt?: DateTimeFilter<"friendship"> | Date | string
    userId?: StringFilter<"friendship"> | string
    friendId?: StringFilter<"friendship"> | string
  }

  export type friendshipUpsertWithWhereUniqueWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    update: XOR<friendshipUpdateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput>
    create: XOR<friendshipCreateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedCreateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipUpdateWithWhereUniqueWithoutUser_friendship_userIdTouserInput = {
    where: friendshipWhereUniqueInput
    data: XOR<friendshipUpdateWithoutUser_friendship_userIdTouserInput, friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput>
  }

  export type friendshipUpdateManyWithWhereWithoutUser_friendship_userIdTouserInput = {
    where: friendshipScalarWhereInput
    data: XOR<friendshipUpdateManyMutationInput, friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUserInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: StringFilter<"notification"> | string
    type?: EnumNotificationTypeFilter<"notification"> | $Enums.NotificationType
    title?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    readAt?: DateTimeNullableFilter<"notification"> | Date | string | null
    metadata?: JsonNullableFilter<"notification">
    createdAt?: DateTimeFilter<"notification"> | Date | string
    userId?: StringFilter<"notification"> | string
  }

  export type operatorUpsertWithWhereUniqueWithoutUserInput = {
    where: operatorWhereUniqueInput
    update: XOR<operatorUpdateWithoutUserInput, operatorUncheckedUpdateWithoutUserInput>
    create: XOR<operatorCreateWithoutUserInput, operatorUncheckedCreateWithoutUserInput>
  }

  export type operatorUpdateWithWhereUniqueWithoutUserInput = {
    where: operatorWhereUniqueInput
    data: XOR<operatorUpdateWithoutUserInput, operatorUncheckedUpdateWithoutUserInput>
  }

  export type operatorUpdateManyWithWhereWithoutUserInput = {
    where: operatorScalarWhereInput
    data: XOR<operatorUpdateManyMutationInput, operatorUncheckedUpdateManyWithoutUserInput>
  }

  export type operatorScalarWhereInput = {
    AND?: operatorScalarWhereInput | operatorScalarWhereInput[]
    OR?: operatorScalarWhereInput[]
    NOT?: operatorScalarWhereInput | operatorScalarWhereInput[]
    id?: StringFilter<"operator"> | string
    name?: StringFilter<"operator"> | string
    slug?: StringFilter<"operator"> | string
    logo?: StringNullableFilter<"operator"> | string | null
    description?: StringNullableFilter<"operator"> | string | null
    isActive?: BoolFilter<"operator"> | boolean
    createdAt?: DateTimeFilter<"operator"> | Date | string
    updatedAt?: DateTimeFilter<"operator"> | Date | string
    ownerId?: StringFilter<"operator"> | string
  }

  export type profileUpsertWithWhereUniqueWithoutUser_profile_userIdTouserInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutUser_profile_userIdTouserInput, profileUncheckedUpdateWithoutUser_profile_userIdTouserInput>
    create: XOR<profileCreateWithoutUser_profile_userIdTouserInput, profileUncheckedCreateWithoutUser_profile_userIdTouserInput>
  }

  export type profileUpdateWithWhereUniqueWithoutUser_profile_userIdTouserInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutUser_profile_userIdTouserInput, profileUncheckedUpdateWithoutUser_profile_userIdTouserInput>
  }

  export type profileUpdateManyWithWhereWithoutUser_profile_userIdTouserInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutUser_profile_userIdTouserInput>
  }

  export type sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
    create: XOR<sessionCreateWithoutUserInput, sessionUncheckedCreateWithoutUserInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutUserInput, sessionUncheckedUpdateWithoutUserInput>
  }

  export type sessionUpdateManyWithWhereWithoutUserInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutUserInput>
  }

  export type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[]
    OR?: sessionScalarWhereInput[]
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[]
    id?: StringFilter<"session"> | string
    userId?: StringFilter<"session"> | string
    activeGameId?: StringNullableFilter<"session"> | string | null
    ipAddress?: StringNullableFilter<"session"> | string | null
    userAgent?: StringNullableFilter<"session"> | string | null
    expiresAt?: DateTimeFilter<"session"> | Date | string
    createdAt?: DateTimeFilter<"session"> | Date | string
    refreshToken?: StringFilter<"session"> | string
    active?: BoolFilter<"session"> | boolean
  }

  export type tournamententryUpsertWithWhereUniqueWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    update: XOR<tournamententryUpdateWithoutUserInput, tournamententryUncheckedUpdateWithoutUserInput>
    create: XOR<tournamententryCreateWithoutUserInput, tournamententryUncheckedCreateWithoutUserInput>
  }

  export type tournamententryUpdateWithWhereUniqueWithoutUserInput = {
    where: tournamententryWhereUniqueInput
    data: XOR<tournamententryUpdateWithoutUserInput, tournamententryUncheckedUpdateWithoutUserInput>
  }

  export type tournamententryUpdateManyWithWhereWithoutUserInput = {
    where: tournamententryScalarWhereInput
    data: XOR<tournamententryUpdateManyMutationInput, tournamententryUncheckedUpdateManyWithoutUserInput>
  }

  export type userachievementUpsertWithWhereUniqueWithoutUserInput = {
    where: userachievementWhereUniqueInput
    update: XOR<userachievementUpdateWithoutUserInput, userachievementUncheckedUpdateWithoutUserInput>
    create: XOR<userachievementCreateWithoutUserInput, userachievementUncheckedCreateWithoutUserInput>
  }

  export type userachievementUpdateWithWhereUniqueWithoutUserInput = {
    where: userachievementWhereUniqueInput
    data: XOR<userachievementUpdateWithoutUserInput, userachievementUncheckedUpdateWithoutUserInput>
  }

  export type userachievementUpdateManyWithWhereWithoutUserInput = {
    where: userachievementScalarWhereInput
    data: XOR<userachievementUpdateManyMutationInput, userachievementUncheckedUpdateManyWithoutUserInput>
  }

  export type achievementCreateWithoutUserachievementInput = {
    id: string
    name: string
    description: string
    targetXp: number
    reward?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type achievementUncheckedCreateWithoutUserachievementInput = {
    id: string
    name: string
    description: string
    targetXp: number
    reward?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type achievementCreateOrConnectWithoutUserachievementInput = {
    where: achievementWhereUniqueInput
    create: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
  }

  export type userCreateWithoutUserachievementInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserachievementInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserachievementInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserachievementInput, userUncheckedCreateWithoutUserachievementInput>
  }

  export type achievementUpsertWithoutUserachievementInput = {
    update: XOR<achievementUpdateWithoutUserachievementInput, achievementUncheckedUpdateWithoutUserachievementInput>
    create: XOR<achievementCreateWithoutUserachievementInput, achievementUncheckedCreateWithoutUserachievementInput>
    where?: achievementWhereInput
  }

  export type achievementUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: achievementWhereInput
    data: XOR<achievementUpdateWithoutUserachievementInput, achievementUncheckedUpdateWithoutUserachievementInput>
  }

  export type achievementUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type achievementUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    targetXp?: IntFieldUpdateOperationsInput | number
    reward?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutUserachievementInput = {
    update: XOR<userUpdateWithoutUserachievementInput, userUncheckedUpdateWithoutUserachievementInput>
    create: XOR<userCreateWithoutUserachievementInput, userUncheckedCreateWithoutUserachievementInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserachievementInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserachievementInput, userUncheckedUpdateWithoutUserachievementInput>
  }

  export type userUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserachievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainBetInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    user: userCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainBetInput = {
    id: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainBetInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
  }

  export type userCreateWithoutRainBetInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRainBetInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRainBetInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRainBetInput, userUncheckedCreateWithoutRainBetInput>
  }

  export type RainHistoryUpsertWithoutRainBetInput = {
    update: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
    create: XOR<RainHistoryCreateWithoutRainBetInput, RainHistoryUncheckedCreateWithoutRainBetInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainBetInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainBetInput, RainHistoryUncheckedUpdateWithoutRainBetInput>
  }

  export type RainHistoryUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type userUpsertWithoutRainBetInput = {
    update: XOR<userUpdateWithoutRainBetInput, userUncheckedUpdateWithoutRainBetInput>
    create: XOR<userCreateWithoutRainBetInput, userUncheckedCreateWithoutRainBetInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRainBetInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRainBetInput, userUncheckedUpdateWithoutRainBetInput>
  }

  export type userUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRainBetInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainBetCreateWithoutRainHistoryInput = {
    id: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
    user: userCreateNestedOneWithoutRainBetInput
  }

  export type RainBetUncheckedCreateWithoutRainHistoryInput = {
    id: string
    userId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainBetCreateOrConnectWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetCreateManyRainHistoryInputEnvelope = {
    data: RainBetCreateManyRainHistoryInput | RainBetCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutRainHistoryInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRainHistoryInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRainHistoryInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRainHistoryInput, userUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateWithoutRainHistoryInput = {
    id: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
    user: userCreateNestedOneWithoutRainTipInput
  }

  export type RainTipUncheckedCreateWithoutRainHistoryInput = {
    id: string
    userId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainTipCreateOrConnectWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipCreateManyRainHistoryInputEnvelope = {
    data: RainTipCreateManyRainHistoryInput | RainTipCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainWinnerCreateWithoutRainHistoryInput = {
    id: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
    user: userCreateNestedOneWithoutRainWinnerInput
  }

  export type RainWinnerUncheckedCreateWithoutRainHistoryInput = {
    id: string
    userId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type RainWinnerCreateOrConnectWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerCreateManyRainHistoryInputEnvelope = {
    data: RainWinnerCreateManyRainHistoryInput | RainWinnerCreateManyRainHistoryInput[]
    skipDuplicates?: boolean
  }

  export type RainBetUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    update: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainBetCreateWithoutRainHistoryInput, RainBetUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainBetUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainBetWhereUniqueInput
    data: XOR<RainBetUpdateWithoutRainHistoryInput, RainBetUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainBetUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainBetScalarWhereInput
    data: XOR<RainBetUpdateManyMutationInput, RainBetUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type userUpsertWithoutRainHistoryInput = {
    update: XOR<userUpdateWithoutRainHistoryInput, userUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<userCreateWithoutRainHistoryInput, userUncheckedCreateWithoutRainHistoryInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRainHistoryInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRainHistoryInput, userUncheckedUpdateWithoutRainHistoryInput>
  }

  export type userUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainTipUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    update: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainTipCreateWithoutRainHistoryInput, RainTipUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainTipUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainTipWhereUniqueInput
    data: XOR<RainTipUpdateWithoutRainHistoryInput, RainTipUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainTipUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainTipScalarWhereInput
    data: XOR<RainTipUpdateManyMutationInput, RainTipUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainWinnerUpsertWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    update: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
    create: XOR<RainWinnerCreateWithoutRainHistoryInput, RainWinnerUncheckedCreateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateWithWhereUniqueWithoutRainHistoryInput = {
    where: RainWinnerWhereUniqueInput
    data: XOR<RainWinnerUpdateWithoutRainHistoryInput, RainWinnerUncheckedUpdateWithoutRainHistoryInput>
  }

  export type RainWinnerUpdateManyWithWhereWithoutRainHistoryInput = {
    where: RainWinnerScalarWhereInput
    data: XOR<RainWinnerUpdateManyMutationInput, RainWinnerUncheckedUpdateManyWithoutRainHistoryInput>
  }

  export type RainHistoryCreateWithoutRainTipInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: userCreateNestedOneWithoutRainHistoryInput
    RainWinner?: RainWinnerCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainTipInput = {
    id: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainTipInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
  }

  export type userCreateWithoutRainTipInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRainTipInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainWinner?: RainWinnerUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRainTipInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRainTipInput, userUncheckedCreateWithoutRainTipInput>
  }

  export type RainHistoryUpsertWithoutRainTipInput = {
    update: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
    create: XOR<RainHistoryCreateWithoutRainTipInput, RainHistoryUncheckedCreateWithoutRainTipInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainTipInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainTipInput, RainHistoryUncheckedUpdateWithoutRainTipInput>
  }

  export type RainHistoryUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: userUpdateOneRequiredWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type userUpsertWithoutRainTipInput = {
    update: XOR<userUpdateWithoutRainTipInput, userUncheckedUpdateWithoutRainTipInput>
    create: XOR<userCreateWithoutRainTipInput, userUncheckedCreateWithoutRainTipInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRainTipInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRainTipInput, userUncheckedUpdateWithoutRainTipInput>
  }

  export type userUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRainTipInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RainHistoryCreateWithoutRainWinnerInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetCreateNestedManyWithoutRainHistoryInput
    user: userCreateNestedOneWithoutRainHistoryInput
    RainTip?: RainTipCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryUncheckedCreateWithoutRainWinnerInput = {
    id: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
    RainBet?: RainBetUncheckedCreateNestedManyWithoutRainHistoryInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutRainHistoryInput
  }

  export type RainHistoryCreateOrConnectWithoutRainWinnerInput = {
    where: RainHistoryWhereUniqueInput
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
  }

  export type userCreateWithoutRainWinnerInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryCreateNestedManyWithoutUserInput
    RainTip?: RainTipCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationCreateNestedManyWithoutUserInput
    operator?: operatorCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryCreateNestedManyWithoutUserInput
    userachievement?: userachievementCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRainWinnerInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    avatar?: string | null
    totalXp?: number
    balance?: Decimal | DecimalJsLike | number | string
    lastLogin?: Date | string | null
    isVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    active?: boolean
    activeProfileId?: string | null
    gender?: $Enums.Gender | null
    status?: $Enums.UserStatus | null
    cashtag?: string | null
    phpId?: number | null
    accessToken?: string | null
    RainBet?: RainBetUncheckedCreateNestedManyWithoutUserInput
    RainHistory?: RainHistoryUncheckedCreateNestedManyWithoutUserInput
    RainTip?: RainTipUncheckedCreateNestedManyWithoutUserInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUserInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_friendIdTouserInput
    friendship_friendship_userIdTouser?: friendshipUncheckedCreateNestedManyWithoutUser_friendship_userIdTouserInput
    notification?: notificationUncheckedCreateNestedManyWithoutUserInput
    operator?: operatorUncheckedCreateNestedManyWithoutUserInput
    profile_profile_userIdTouser?: profileUncheckedCreateNestedManyWithoutUser_profile_userIdTouserInput
    session?: sessionUncheckedCreateNestedManyWithoutUserInput
    tournamententry?: tournamententryUncheckedCreateNestedManyWithoutUserInput
    userachievement?: userachievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRainWinnerInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRainWinnerInput, userUncheckedCreateWithoutRainWinnerInput>
  }

  export type RainHistoryUpsertWithoutRainWinnerInput = {
    update: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<RainHistoryCreateWithoutRainWinnerInput, RainHistoryUncheckedCreateWithoutRainWinnerInput>
    where?: RainHistoryWhereInput
  }

  export type RainHistoryUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: RainHistoryWhereInput
    data: XOR<RainHistoryUpdateWithoutRainWinnerInput, RainHistoryUncheckedUpdateWithoutRainWinnerInput>
  }

  export type RainHistoryUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    user?: userUpdateOneRequiredWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type userUpsertWithoutRainWinnerInput = {
    update: XOR<userUpdateWithoutRainWinnerInput, userUncheckedUpdateWithoutRainWinnerInput>
    create: XOR<userCreateWithoutRainWinnerInput, userUncheckedCreateWithoutRainWinnerInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRainWinnerInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRainWinnerInput, userUncheckedUpdateWithoutRainWinnerInput>
  }

  export type userUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUpdateManyWithoutUserNestedInput
    operator?: operatorUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRainWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    totalXp?: IntFieldUpdateOperationsInput | number
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    activeProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    status?: NullableEnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus | null
    cashtag?: NullableStringFieldUpdateOperationsInput | string | null
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    RainBet?: RainBetUncheckedUpdateManyWithoutUserNestedInput
    RainHistory?: RainHistoryUncheckedUpdateManyWithoutUserNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutUserNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUserNestedInput
    friendship_friendship_friendIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserNestedInput
    friendship_friendship_userIdTouser?: friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUserNestedInput
    operator?: operatorUncheckedUpdateManyWithoutUserNestedInput
    profile_profile_userIdTouser?: profileUncheckedUpdateManyWithoutUser_profile_userIdTouserNestedInput
    session?: sessionUncheckedUpdateManyWithoutUserNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutUserNestedInput
    userachievement?: userachievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userachievementCreateManyAchievementInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
  }

  export type userachievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type profileCreateManyBankInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    shopId: string
  }

  export type profileUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutBankInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageCreateManyChatroomInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    userId: string
  }

  export type chatmessageUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatmessageUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatroomCreateManyGamesessionInput = {
    id: string
    name: string
    isGameRoom?: boolean
    createdAt?: Date | string
  }

  export type transactionCreateManyGamesessionInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    profileId: string
  }

  export type chatroomUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatmessage?: chatmessageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isGameRoom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type transactionUncheckedUpdateManyWithoutGamesessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type bankCreateManyOperatorInput = {
    id: string
    name: string
    currency?: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type operatorgameCreateManyOperatorInput = {
    id: string
    name: string
    slug: string
    description?: string | null
    thumbnail?: string | null
    minBet?: Decimal | DecimalJsLike | number | string | null
    maxBet?: Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: number
    isActive?: boolean
    isPromoted?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type profileCreateManyOperatorInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    userId: string
    bankId: string
  }

  export type tournamentCreateManyOperatorInput = {
    id: string
    name: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    entryFee?: Decimal | DecimalJsLike | number | string | null
    prizePool?: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type bankUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateManyWithoutBankNestedInput
  }

  export type bankUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateManyWithoutBankNestedInput
  }

  export type bankUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operatorgameUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUpdateManyWithoutOperatorgameNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutOperatorgameNestedInput
  }

  export type operatorgameUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutOperatorgameNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutOperatorgameNestedInput
  }

  export type operatorgameUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    minBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxBet?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpMultiplier?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPromoted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type profileUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    user_profile_userIdTouser?: userUpdateOneRequiredWithoutProfile_profile_userIdTouserNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: StringFieldUpdateOperationsInput | string
    bankId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
    gamesession?: gamesessionUncheckedUpdateManyWithoutTournamentNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutTournamentNestedInput
    tournamentgame?: tournamentgameUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type tournamentUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    entryFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    prizePool?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaderboard?: NullableJsonNullValueInput | InputJsonValue
  }

  export type gamesessionCreateManyOperatorgameInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: string | null
    active?: boolean
    profileId: string
  }

  export type tournamentgameCreateManyOperatorgameInput = {
    id: string
    multiplier?: number
    tournamentId: string
  }

  export type gamesessionUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    profile?: profileUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    transaction?: transactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournament?: tournamentUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUncheckedUpdateManyWithoutOperatorgameInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type gamesessionCreateManyProfileInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    tournamentId?: string | null
    active?: boolean
  }

  export type tournamententryCreateManyProfileInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    tournamentId: string
  }

  export type transactionCreateManyProfileInput = {
    id: string
    type: $Enums.TransactionType
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: boolean
    paymentMethod?: string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    processedAt?: Date | string | null
    gameSessionId?: string | null
  }

  export type gamesessionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    operatorgame?: operatorgameUpdateOneRequiredWithoutGamesessionNestedInput
    tournament?: tournamentUpdateOneWithoutGamesessionNestedInput
    transaction?: transactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    tournamentId?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tournamententryUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
    user?: userUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    tournamentId?: StringFieldUpdateOperationsInput | string
  }

  export type transactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesession?: gamesessionUpdateOneWithoutTransactionNestedInput
  }

  export type transactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isRealMoney?: BoolFieldUpdateOperationsInput | boolean
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gameSessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type gamesessionCreateManyTournamentInput = {
    id: string
    startTime?: Date | string
    endTime?: Date | string | null
    betAmount?: Decimal | DecimalJsLike | number | string | null
    winAmount?: Decimal | DecimalJsLike | number | string | null
    xpEarned?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId: string
    active?: boolean
    profileId: string
  }

  export type tournamententryCreateManyTournamentInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    userId: string
    profileId: string
  }

  export type tournamentgameCreateManyTournamentInput = {
    id: string
    multiplier?: number
    gameId: string
  }

  export type gamesessionUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    active?: BoolFieldUpdateOperationsInput | boolean
    chatroom?: chatroomUpdateManyWithoutGamesessionNestedInput
    operatorgame?: operatorgameUpdateOneRequiredWithoutGamesessionNestedInput
    profile?: profileUpdateOneRequiredWithoutGamesessionNestedInput
    transaction?: transactionUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
    chatroom?: chatroomUncheckedUpdateManyWithoutGamesessionNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutGamesessionNestedInput
  }

  export type gamesessionUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    betAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    winAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    xpEarned?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    gameId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneRequiredWithoutTournamententryNestedInput
    user?: userUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    operatorgame?: operatorgameUpdateOneRequiredWithoutTournamentgameNestedInput
  }

  export type tournamentgameUncheckedUpdateWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamentgameUncheckedUpdateManyWithoutTournamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    multiplier?: FloatFieldUpdateOperationsInput | number
    gameId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateManyUserInput = {
    id: string
    rainHistoryId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainHistoryCreateManyUserInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    rainType: string
    createdAt?: Date | string
  }

  export type RainTipCreateManyUserInput = {
    id: string
    rainHistoryId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyUserInput = {
    id: string
    rainHistoryId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type chatmessageCreateManyUserInput = {
    id: string
    content: string
    channel: $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    roomId?: string | null
  }

  export type friendshipCreateManyUser_friendship_friendIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    userId: string
  }

  export type friendshipCreateManyUser_friendship_userIdTouserInput = {
    id: string
    status?: $Enums.FriendshipStatus
    createdAt?: Date | string
    updatedAt: Date | string
    friendId: string
  }

  export type notificationCreateManyUserInput = {
    id: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type operatorCreateManyUserInput = {
    id: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type profileCreateManyUser_profile_userIdTouserInput = {
    id: string
    profileNumber: string
    balance?: number
    xpEarned?: number
    isActive?: boolean
    lastPlayed?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    phpId?: number | null
    bankId: string
    shopId: string
  }

  export type sessionCreateManyUserInput = {
    id: string
    activeGameId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken: string
    active?: boolean
  }

  export type tournamententryCreateManyUserInput = {
    id: string
    score?: number
    wagered?: Decimal | DecimalJsLike | number | string
    won?: Decimal | DecimalJsLike | number | string
    joinedAt?: Date | string
    tournamentId: string
    profileId: string
  }

  export type userachievementCreateManyUserInput = {
    id: string
    progress?: number
    isUnlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    achievementId: string
  }

  export type RainBetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainBet?: RainBetUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainTip?: RainTipUncheckedUpdateManyWithoutRainHistoryNestedInput
    RainWinner?: RainWinnerUncheckedUpdateManyWithoutRainHistoryNestedInput
  }

  export type RainHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rainType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RainHistory?: RainHistoryUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rainHistoryId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom?: chatroomUpdateOneWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatmessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    channel?: EnumChatChannelFieldUpdateOperationsInput | $Enums.ChatChannel
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type friendshipUpdateWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_userIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_userIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_friendIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUpdateWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user_friendship_friendIdTouser?: userUpdateOneRequiredWithoutFriendship_friendship_friendIdTouserNestedInput
  }

  export type friendshipUncheckedUpdateWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type friendshipUncheckedUpdateManyWithoutUser_friendship_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | $Enums.FriendshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendId?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type operatorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUpdateManyWithoutOperatorNestedInput
    operatorgame?: operatorgameUpdateManyWithoutOperatorNestedInput
    profile?: profileUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bank?: bankUncheckedUpdateManyWithoutOperatorNestedInput
    operatorgame?: operatorgameUncheckedUpdateManyWithoutOperatorNestedInput
    profile?: profileUncheckedUpdateManyWithoutOperatorNestedInput
    tournament?: tournamentUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type operatorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type profileUpdateWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    gamesession?: gamesessionUpdateManyWithoutProfileNestedInput
    bank?: bankUpdateOneRequiredWithoutProfileNestedInput
    operator?: operatorUpdateOneRequiredWithoutProfileNestedInput
    tournamententry?: tournamententryUpdateManyWithoutProfileNestedInput
    transaction?: transactionUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    gamesession?: gamesessionUncheckedUpdateManyWithoutProfileNestedInput
    tournamententry?: tournamententryUncheckedUpdateManyWithoutProfileNestedInput
    transaction?: transactionUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutUser_profile_userIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileNumber?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    xpEarned?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastPlayed?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phpId?: NullableIntFieldUpdateOperationsInput | number | null
    bankId?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
  }

  export type sessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type sessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    activeGameId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tournamententryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneRequiredWithoutTournamententryNestedInput
    tournament?: tournamentUpdateOneRequiredWithoutTournamententryNestedInput
  }

  export type tournamententryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type tournamententryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    wagered?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    won?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tournamentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: achievementUpdateOneRequiredWithoutUserachievementNestedInput
  }

  export type userachievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type userachievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievementId?: StringFieldUpdateOperationsInput | string
  }

  export type RainBetCreateManyRainHistoryInput = {
    id: string
    userId: string
    betAmount: Decimal | DecimalJsLike | number | string
    odds: Decimal | DecimalJsLike | number | string
    outcome?: string | null
    settledAt?: Date | string | null
  }

  export type RainTipCreateManyRainHistoryInput = {
    id: string
    userId: string
    tipAmount: Decimal | DecimalJsLike | number | string
    tippedAt?: Date | string
  }

  export type RainWinnerCreateManyRainHistoryInput = {
    id: string
    userId: string
    wonAmount: Decimal | DecimalJsLike | number | string
    wonAt?: Date | string
  }

  export type RainBetUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutRainBetNestedInput
  }

  export type RainBetUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainBetUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    betAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    odds?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RainTipUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRainTipNestedInput
  }

  export type RainTipUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainTipUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tipAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tippedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutRainWinnerNestedInput
  }

  export type RainWinnerUncheckedUpdateWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RainWinnerUncheckedUpdateManyWithoutRainHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wonAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    wonAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}